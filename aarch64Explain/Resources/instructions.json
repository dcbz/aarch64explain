[{"id": 1127, "asmtemplate": "LASTA   <V><d>, <Pg>, <Zn>.<T>", "brief": "Extract element after last to SIMD&FP scalar register", "heading": "LASTA (SIMD&FP scalar)", "para": "Extract element after last to SIMD&FP scalar register. \n\nIf there is an active element then extract the element after the last active  element modulo the number of elements from the final source vector register.  If there are no active elements, extract element zero. Then place the  extracted element in the destination SIMD&FP scalar register.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LASTA   <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 1034, "asmtemplate": "UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Minimum (vector)", "heading": "UMIN", "para": "Unsigned Minimum (vector). This instruction compares corresponding vector  elements in the two source SIMD&FP registers, places the smaller of each of  the two unsigned integer values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 892, "asmtemplate": "NOT<Vd>.<T>, <Vn>.<T>", "brief": "Bitwise NOT (vector)", "heading": "MVN", "para": "Bitwise NOT (vector). This instruction reads each vector element from the  source SIMD&FP register, places the inverse of each value into a vector, and  writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of NOT. This means:  \n* The encodings in this description are named to match the encodings of NOT. \n* The description of NOT gives the operational pseudocode for this \n  instruction.", "explanations": {"<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["MVN  <Vd>.<T>, <Vn>.<T>"]}, {"id": 812, "asmtemplate": "UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Maximum Pairwise", "heading": "UMAXP", "para": "Unsigned Maximum Pairwise. This instruction creates a vector by concatenating  the vector elements of the first source SIMD&FP register after the vector  elements of the second source SIMD&FP register, reads each pair of adjacent  vector elements in the two source SIMD&FP registers, writes the largest of  each pair of unsigned integer values into a vector, and writes the vector to  the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 439, "asmtemplate": "SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Absolute difference and Accumulate", "heading": "SABA", "para": "Signed Absolute difference and Accumulate. This instruction subtracts the  elements of the vector of the second source SIMD&FP register from the  corresponding elements of the first source SIMD&FP register, and accumulates  the absolute values of the results into the elements of the vector of the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 709, "asmtemplate": "AESIMC  <Vd>.16B, <Vn>.16B", "brief": "AES inverse mix columns", "heading": "AESIMC", "para": "AES inverse mix columns.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["AESIMC  <Vd>.16B, <Vn>.16B"]}, {"id": 909, "asmtemplate": "LD1RQH  {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate eight halfwords (immediate index)", "heading": "LD1RQH (scalar plus immediate)", "para": "Contiguous load and replicate eight halfwords (immediate index). \n\nLoad eight contiguous halfwords to elements of a short, 128-bit (quadword)  vector from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 16 in the range -128 to +112 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first eight predicate elements are used and  higher numbered predicate elements are ignored.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1RQH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 968, "asmtemplate": "EOR<Pd>.B, <Pg>/Z, <Pn>.B, <Pg>.B", "brief": "Bitwise invert predicate", "heading": "NOT (predicate)", "para": "Bitwise invert predicate. \n\nBitwise invert each active element of the source predicate, and place the  results in the corresponding elements of the destination predicate. Inactive  elements in the destination predicate register are set to zero. Does not set  the condition flags. \n\nThis is an alias of EOR, EORS (predicates). This means:  \n* The encodings in this description are named to match the encodings of EOR, \n  EORS (predicates). \n* The description of EOR, EORS (predicates) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["NOT     <Pd>.B, <Pg>/Z, <Pn>.B"]}, {"id": 972, "asmtemplate": "SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", "brief": "SM3TT1B", "heading": "SM3TT1B", "para": "SM3TT1B takes three 128-bit vectors from three source SIMD&FP registers and a  2-bit immediate index value, and returns a 128-bit result in the destination  SIMD&FP register. It performs a 32-bit majority function between the three  32-bit fields held in the upper three elements of the first source vector, and  adds the resulting 32-bit value and the following three other 32-bit values:  \n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the 32-bit majority function. \n* The result of the exclusive OR of the top 32-bit element of the second \n  source vector, Vn, with a rotation left by 12 of the top 32-bit element of \n  the first source vector. \n* A 32-bit element indexed out of the third source vector, Vm.  The result of this addition is returned as the top element of the result. The  other elements of the result are taken from elements of the first source  vector, with the element returned in bits<63:32> being rotated left by 9. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": ", encoded in \"imm2\".", "<Vd>": "Is the name of the SIMD", "<imm2>": "Is a 32-bit element indexed out of ", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SM3TT1B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"]}, {"id": 1228, "asmtemplate": "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Add (vector)", "heading": "ADD (vector)", "para": "Add (vector). This instruction adds corresponding elements in the two source  SIMD&FP registers, places the results into a vector, and writes the vector to  the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["ADD  <V><d>, <V><n>, <V><m>", "ADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 658, "asmtemplate": "CSNEG  <Xd>, <Xn>, <Xm>, <cond>", "brief": "Conditional Select Negation", "heading": "CSNEG", "para": "Conditional Select Negation returns, in the destination register, the value of  the first source register if the condition is TRUE, and otherwise returns the  negated value of the second source register. \n\nThis instruction is used by the alias CNEG.", "explanations": {"<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CSNEG  <Wd>, <Wn>, <Wm>, <cond>"]}, {"id": 633, "asmtemplate": "LD1D    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load doublewords to vector (scalar index)", "heading": "LD1D (scalar plus scalar)", "para": "Contiguous load doublewords to vector (scalar index). \n\nContiguous load of doublewords to elements of a vector register from the  memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 8 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 802, "asmtemplate": "SHA256H2  <Qd>, <Qn>, <Vm>.4S", "brief": "SHA256 hash update (part 2)", "heading": "SHA256H2", "para": "SHA256 hash update (part 2).", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Qn>": "Is the 128-bit name of the second SIMD", "<Vm>": "Is the name of the third SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA256H2  <Qd>, <Qn>, <Vm>.4S"]}, {"id": 28, "asmtemplate": "SHA1SU1  <Vd>.4S, <Vn>.4S", "brief": "SHA1 schedule update 1", "heading": "SHA1SU1", "para": "SHA1 schedule update 1.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the second SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["SHA1SU1  <Vd>.4S, <Vn>.4S"]}, {"id": 833, "asmtemplate": "MOVK  <Xd>, #<imm>{, LSL #<shift>}", "brief": "Move wide with keep", "heading": "MOVK", "para": "Move wide with keep moves an optionally-shifted 16-bit immediate value into a  register, keeping other bits unchanged.", "explanations": {"<imm>": "Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "": "/16.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MOVK  <Wd>, #<imm>{, LSL #<shift>}"]}, {"id": 780, "asmtemplate": "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]", "brief": "Gather prefetch doublewords (scalar plus vector)", "heading": "PRFD (scalar plus vector)", "para": "Gather prefetch doublewords (scalar plus vector). \n\nGather prefetch of doublewords from the active memory addresses generated by a  64-bit scalar base plus vector index. The index values are optionally first  sign or zero-extended from 32 to 64 bits and then multiplied by 8. Inactive  addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 3 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset and 64-bit scaled offset", "explanations": {"<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #3]", "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]", "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]"]}, {"id": 1003, "asmtemplate": "LD2  {<Vt>.<T>, <Vt2>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load multiple 2-element structures to two registers", "heading": "LD2 (multiple structures)", "para": "Load multiple 2-element structures to two registers. This instruction loads  multiple 2-element structures from memory and writes the result to the two  SIMD&FP registers, with de-interleaving. \n\nFor an example of de-interleaving, see LD3 (multiple structures). \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<T><Vt2>": "Is the name of the second SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", "LD2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 1121, "asmtemplate": "STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", "brief": "Store Exclusive Register Byte", "heading": "STXRB", "para": "Store Exclusive Register Byte stores a byte from a register to memory if the  PE has exclusive access to the memory address, and returns a status value of 0  if the store was successful, or of 1 if no store was performed. See  Synchronization and semaphores. The memory access is atomic. \n\nFor information about memory accesses see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:"}, "encodings": ["STXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1027, "asmtemplate": "FCMUO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point compare vectors", "heading": "FCM<cc> (vectors)", "para": "Floating-point compare vectors. \n\nCompare active floating-point elements in the first source vector with  corresponding elements in the second source vector, and place the boolean  results of the specified comparison in the corresponding elements of the  destination predicate. Inactive elements in the destination predicate register  are set to zero. Does not set the condition flags. \n\n \n\nThe <cc> symbol specifies one of the standard ARM condition codes: EQ, GE, GT,  or NE, with the addition of UO for an unordered comparison. \n\nThis instruction is used by the pseudo-instructions FCMLE (vectors), and FCMLT \n(vectors). \n\nIt has encodings from 5 classes: Equal , Greater than , Greater than or equal \n, Not equal and Unordered", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["FCMEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "FCMGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "FCMGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "FCMUO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>"]}, {"id": 100, "asmtemplate": "URECPE  <Vd>.<T>, <Vn>.<T>", "brief": "Unsigned Reciprocal Estimate", "heading": "URECPE", "para": "Unsigned Reciprocal Estimate. This instruction reads each vector element from  the source SIMD&FP register, calculates an approximate inverse for the  unsigned integer value, places the result into a vector, and writes the vector  to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["URECPE  <Vd>.<T>, <Vn>.<T>"]}, {"id": 995, "asmtemplate": "SBCS<Xd>, XZR, <Xm>", "brief": "Negate with Carry, setting flags", "heading": "NGCS", "para": "Negate with Carry, setting flags, negates the sum of a register value and the  value of NOT (Carry flag), and writes the result to the destination register.  It updates the condition flags based on the result. \n\nThis is an alias of SBCS. This means:  \n* The encodings in this description are named to match the encodings of SBCS. \n* The description of SBCS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xm>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Wm>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["NGCS  <Wd>, <Wm>"]}, {"id": 512, "asmtemplate": "STNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", "brief": "Store Pair of Registers, with non-temporal hint", "heading": "STNP", "para": "Store Pair of Registers, with non-temporal hint, calculates an address from a  base register value and an immediate offset, and stores two 32-bit words or  two 64-bit doublewords to the calculated address, from two registers. For  information about memory accesses, see Load/Store addressing modes. For  information about Non-temporal pair instructions, see Load/Store Non-temporal  pair.", "explanations": {"": "/8.", "<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<imm>": "For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 623, "asmtemplate": "LDSETL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic bit set on word or doubleword in memory", "heading": "LDSET, LDSETA, LDSETAL, LDSETL", "para": "Atomic bit set on word or doubleword in memory atomically loads a 32-bit word  or 64-bit doubleword from memory, performs a bitwise OR with the value held in  a register on it, and stores the result back to memory. The value initially  loaded from memory is returned in the destination register.  \n* If the destination register is not one of WZR or XZR, LDSETA and LDSETAL \n  load from memory with acquire semantics. \n* LDSETL and LDSETAL store to memory with release semantics. \n* LDSET has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSET, STSETL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDSET  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 776, "asmtemplate": "LDSMINLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic signed minimum on byte in memory", "heading": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB", "para": "Atomic signed minimum on byte in memory atomically loads an 8-bit byte from  memory, compares it against the value held in a register, and stores the  smaller value back to memory, treating the values as signed numbers. The value  initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDSMINAB and LDSMINALB load from \n  memory with acquire semantics. \n* LDSMINLB and LDSMINALB store to memory with release semantics. \n* LDSMINB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMINB, STSMINLB.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDSMINAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 513, "asmtemplate": "REV64  <Vd>.<T>, <Vn>.<T>", "brief": "Reverse elements in 64-bit doublewords (vector)", "heading": "REV64", "para": "Reverse elements in 64-bit doublewords (vector). This instruction reverses the  order of 8-bit, 16-bit, or 32-bit elements in each doubleword of the vector in  the source SIMD&FP register, places the results into a vector, and writes the  vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD"}, "encodings": ["REV64  <Vd>.<T>, <Vn>.<T>"]}, {"id": 317, "asmtemplate": "FNEG  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Negate (vector)", "heading": "FNEG (vector)", "para": "Floating-point Negate (vector). This instruction negates the value of each  vector element in the source SIMD&FP register, writes the result to a vector,  and writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"<Vd>": "Is the name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FNEG  <Vd>.<T>, <Vn>.<T>", "FNEG  <Vd>.<T>, <Vn>.<T>"]}, {"id": 20, "asmtemplate": "STUR  <Qt>, [<Xn|SP>{, #<simm>}]", "brief": "Store SIMD&FP register (unscaled offset)", "heading": "STUR (SIMD&FP)", "para": "Store SIMD&FP register (unscaled offset). This instruction stores a single  SIMD&FP register to memory. The address that is used for the store is  calculated from a base register value and an optional immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register to be transferred, encoded in the \"Rt\" field.", "<St>": "Is the 32-bit name of the SIMD", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ht>": "Is the 16-bit name of the SIMD", "<Dt>": "Is the 64-bit name of the SIMD", "<Qt>": "Is the 128-bit name of the SIMD", "<Bt>": "Is the 8-bit name of the SIMD"}, "encodings": ["STUR  <Bt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 90, "asmtemplate": "UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Halving Subtract", "heading": "UHSUB", "para": "Unsigned Halving Subtract. This instruction subtracts the vector elements in  the second source SIMD&FP register from the corresponding vector elements in  the first source SIMD&FP register, shifts each result right one bit, places  each result into a vector, and writes the vector to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 2, "asmtemplate": "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Floating-point fused Multiply-Add Long to accumulator (vector)", "heading": "FMLAL, FMLAL2 (vector)", "para": "Floating-point fused Multiply-Add Long to accumulator (vector). This  instruction multiplies corresponding half-precision floating-point values in  the vectors in the two source SIMD&FP registers, and accumulates the product  to the corresponding vector element of the destination SIMD&FP register. The  instruction does not round the result of the multiply before the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLAL and FMLAL2", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 923, "asmtemplate": "SDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Signed divide (predicated)", "heading": "SDIV", "para": "Signed Divide divides a signed integer register value by another signed  integer register value, and writes the result to the destination register. The  condition flags are not affected.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SDIV  <Wd>, <Wn>, <Wm>"]}, {"id": 277, "asmtemplate": "PACGA  <Xd>, <Xn>, <Xm|SP>", "brief": "Pointer Authentication Code, using Generic key", "heading": "PACGA", "para": "Pointer Authentication Code, using Generic key. This instruction computes the  pointer authentication code for an address in the first source register, using  a modifier in the second source register, and the Generic key. The computed  pointer authentication code is returned in the upper 32 bits of the  destination register.", "explanations": {"<Xm|SP>": "Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field."}, "encodings": ["PACGA  <Xd>, <Xn>, <Xm|SP>"]}, {"id": 156, "asmtemplate": "STTRB  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Store Register Byte (unprivileged)", "heading": "STTRB", "para": "Store Register Byte (unprivileged) stores a byte from a 32-bit register to  memory. The address that is used for the store is calculated from a base  register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STTRB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 1186, "asmtemplate": "PNEXT   <Pdn>.<T>, <Pg>, <Pdn>.<T>", "brief": "Find next active predicate", "heading": "PNEXT", "para": "Find next active predicate. \n\nAn instruction used to construct a loop which iterates over all active  elements in a predicate. If all source predicate elements are false it sets  the first active predicate element in the destination predicate to true.  Otherwise it determines the next active predicate element following the last  true source predicate element, and if one is found sets the corresponding  destination predicate element to true. All other destination predicate  elements are set to false. Sets the First (N), None (Z), !Last (C) condition  flags based on the predicate result, and the V flag to zero.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pdn>": "Is the name of the source and destination scalable predicate register, encoded in the \"Pdn\" field."}, "encodings": ["PNEXT   <Pdn>.<T>, <Pg>, <Pdn>.<T>"]}, {"id": 858, "asmtemplate": "ST1B    {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>]", "brief": "Contiguous store bytes from vector (scalar index)", "heading": "ST1B (scalar plus scalar)", "para": "Contiguous store bytes from vector (scalar index). \n\nContiguous store of bytes from elements of a vector register to the memory  address generated by a 64-bit scalar base and scalar index which is added to  the base address. After each element access the index value is incremented,  but the index register is not updated. Inactive elements are not written to  memory.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST1B    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>]"]}, {"id": 691, "asmtemplate": "LDR  <Qt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load SIMD&FP Register (immediate offset)", "heading": "LDR (immediate, SIMD&FP)", "para": "Load SIMD&FP Register (immediate offset). This instruction loads an element  from memory, and writes the result as a scalar to the SIMD&FP register. The  address that is used for the load is calculated from a base register value, a  signed immediate offset, and an optional offset that is a multiple of the  element size. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/16.", "<St>": "Is the 32-bit name of the SIMD", "<pimm>": "For the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the \"imm12\" field as ", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<Dt>": "Is the 64-bit name of the SIMD", "<Ht>": "Is the 16-bit name of the SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Qt>": "Is the 128-bit name of the SIMD", "<Bt>": "Is the 8-bit name of the SIMD"}, "encodings": ["LDR  <Bt>, [<Xn|SP>], #<simm>", "LDR  <Bt>, [<Xn|SP>, #<simm>]!", "LDR  <Bt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 213, "asmtemplate": "CASPL  <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]", "brief": "Compare and Swap Pair of words or doublewords in memory", "heading": "CASP, CASPA, CASPAL, CASPL", "para": "Compare and Swap Pair of words or doublewords in memory reads a pair of 32-bit  words or 64-bit doublewords from memory, and compares them against the values  held in the first pair of registers. If the comparison is equal, the values in  the second pair of registers are written to memory. If the writes are  performed, the reads and writes occur atomically such that no other  modification of the memory location can take place between the reads and  writes.  \n* CASPA and CASPAL load from memory with acquire semantics. \n* CASPL and CASPAL store to memory with release semantics. \n* CAS has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors  associated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the registers which are  compared and loaded, that is <Ws> and <W(s+1)>, or <Xs> and <X(s+1)>, are  restored to the values held in the registers before the instruction was  executed.", "explanations": {"<Ws>": "Is the 32-bit name of the first general-purpose register to be compared and loaded, encoded in the \"Rs\" field. ", "<Wt>": "Is the 32-bit name of the first general-purpose register to be conditionally stored, encoded in the \"Rt\" field. ", "": " must be an even-numbered register.", "<W(t+1)>": "Is the 32-bit name of the second general-purpose register to be conditionally stored.", "<X(s+1)>": "Is the 64-bit name of the second general-purpose register to be compared and loaded.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<X(t+1)>": "Is the 64-bit name of the second general-purpose register to be conditionally stored.", "<W(s+1)>": "Is the 32-bit name of the second general-purpose register to be compared and loaded.", "<Xs>": "Is the 64-bit name of the first general-purpose register to be compared and loaded, encoded in the \"Rs\" field. ", "<Xt>": "Is the 64-bit name of the first general-purpose register to be conditionally stored, encoded in the \"Rt\" field. "}, "encodings": ["CASP  <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"]}, {"id": 486, "asmtemplate": "BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}", "brief": "Bitwise bit Clear (vector, immediate)", "heading": "BIC (vector, immediate)", "para": "Bitwise bit Clear (vector, immediate). This instruction reads each vector  element from the destination SIMD&FP register, performs a bitwise AND between  each result and the complement of an immediate constant, places the result  into a vector, and writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Vd>": "Is the name of the SIMD", "": "FP register, encoded in the \"Rd\" field.", "<T><T><imm8>": "Is an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\"."}, "encodings": ["BIC  <Vd>.<T>, #<imm8>{, LSL #<amount>}"]}, {"id": 541, "asmtemplate": "ADDS  <Xd>, <Xn|SP>, <R><m>{, <extend>{#<amount>}}", "brief": "Add (extended register), setting flags", "heading": "ADDS (extended register)", "para": "Add (extended register), setting flags, adds a register value and a sign or  zero-extended register value, followed by an optional left shift amount, and  writes the result to the destination register. The argument that is extended  from the <Rm> register can be a byte, halfword, word, or doubleword. It  updates the condition flags based on the result. \n\nThis instruction is used by the alias CMN (extended register).", "explanations": {"": " is present but not LSL.", "<R><m>": "Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<extend><extend><amount>": "Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn|WSP>": "Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["ADDS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"]}, {"id": 1061, "asmtemplate": "FRINT32Z  <Dd>, <Dn>", "brief": "Floating-point Round to 32-bit Integer toward Zero (scalar)", "heading": "FRINT32Z (scalar)", "para": "Floating-point Round to 32-bit Integer toward Zero (scalar). This instruction  rounds a floating-point value in the SIMD&FP source register to an integral  floating-point value that fits into a 32-bit integer size using the Round  towards Zero rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA zero input returns a zero result with the same sign. When the result value  is not numerically equal to the {corresponding} input value, an Inexact  exception is raised. When the input is infinite, NaN or out-of-range, the  instruction returns {for the corresponding result value} the most negative  integer representable in the destination size, and an Invalid Operation  floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Sd>": "Is the 32-bit name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FRINT32Z  <Sd>, <Sn>"]}, {"id": 730, "asmtemplate": "SUB     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Subtract vectors (unpredicated)", "heading": "SUB (vectors, unpredicated)", "para": "Subtract vectors (unpredicated). \n\nSubtract all elements of the second source vector from corresponding elements  of the first source vector and place the results in the corresponding elements  of the destination vector. This instruction is unpredicated.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SUB     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 419, "asmtemplate": "UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Maximum (vector)", "heading": "UMAX", "para": "Unsigned Maximum (vector). This instruction compares corresponding elements in  the vectors in the two source SIMD&FP registers, places the larger of each  pair of unsigned integer values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1092, "asmtemplate": "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Shift Left and Insert (immediate)", "heading": "SLI", "para": "Shift Left and Insert (immediate). This instruction reads each vector element  in the source SIMD&FP register, left shifts each vector element by an  immediate value, and inserts the result into the corresponding vector element  in the destination SIMD&FP register such that the new zero bits created by the  shift are not inserted but retain their existing value. Bits shifted out of  the left of each vector element in the source register are lost. \n\nThe following figure shows an example of the operation of shift left by 3 for  an 8-bit vector element. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SLI  <V><d>, <V><n>, #<shift>", "SLI  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 205, "asmtemplate": "FRINTZ  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral, toward Zero (vector)", "heading": "FRINTZ (vector)", "para": "Floating-point Round to Integral, toward Zero (vector). This instruction  rounds a vector of floating-point values in the SIMD&FP source register to  integral floating-point values of the same size using the Round towards Zero  rounding mode, and writes the result to the SIMD&FP destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["FRINTZ  <Vd>.<T>, <Vn>.<T>", "FRINTZ  <Vd>.<T>, <Vn>.<T>"]}, {"id": 177, "asmtemplate": "FTMAD   <Zdn>.<T>, <Zdn>.<T>, <Zm>.<T>, #<imm>", "brief": "Floating-point trigonometric multiply-add coefficient", "heading": "FTMAD", "para": "Floating-point trigonometric multiply-add coefficient. \n\nThe FTMAD instruction calculates the series terms for either sin(x) or cos(x),  where the argument x has been adjusted to be in the range -\u03c0/4 < x \u2264 \u03c0/4. \n\nTo calculate the series terms of sin(x) and cos(x) the initial source operands  of FTMAD should be zero in the first source vector and x2 in the second source  vector. The FTMAD instruction is then executed eight times to calculate the  sum of eight series terms, which gives a result of sufficient precision. \n\nThe FTMAD instruction multiplies each element of the first source vector by  the absolute value of the corresponding element of the second source vector  and performs a fused addition of each product with a value obtained from a  table of hard-wired coefficients, and places the results destructively in the  first source vector. \n\nThe coefficients are different for sin(x) and cos(x), and are selected by a  combination of the sign bit in the second source element and an immediate  index in the range 0 to 7. \n\nThis instruction is unpredicated.", "explanations": {"<imm>": "Is the unsigned immediate operand, in the range 0 to 7, encoded in the \"imm3\" field.", "<T><Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FTMAD   <Zdn>.<T>, <Zdn>.<T>, <Zm>.<T>, #<imm>"]}, {"id": 1132, "asmtemplate": "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Maximum Number Pairwise (vector)", "heading": "FMAXNMP (vector)", "para": "Floating-point Maximum Number Pairwise (vector). This instruction creates a  vector by concatenating the vector elements of the first source SIMD&FP  register after the vector elements of the second source SIMD&FP register,  reads each pair of adjacent vector elements in the two source SIMD&FP  registers, writes the largest of each pair of values into a vector, and writes  the vector to the destination SIMD&FP register. All the values in this  instruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result is the numerical  value, otherwise the result is identical to FMAX (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMAXNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1250, "asmtemplate": "SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Rounding Halving Add", "heading": "SRHADD", "para": "Signed Rounding Halving Add. This instruction adds corresponding signed  integer values from the two source SIMD&FP registers, shifts each result right  one bit, places the results into a vector, and writes the vector to the  destination SIMD&FP register. \n\nThe results are rounded. For truncated results, see SHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SRHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 350, "asmtemplate": "BRKPBS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Break before first true condition, propagating from previous partition", "heading": "BRKPB, BRKPBS", "para": "Break before first true condition, propagating from previous partition. \n\nIf the last active element of the first source predicate is false then set the  destination predicate to all-false. Otherwise sets destination predicate  elements up to but not including the first active and true source element to  true, then sets subsequent elements to false. Inactive elements in the  destination predicate register are set to zero. Optionally sets the First (N),  None (Z), !Last (C) condition flags based on the predicate result, and the V  flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["BRKPB   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "BRKPBS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 959, "asmtemplate": "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Compare bitwise Test bits nonzero (vector)", "heading": "CMTST", "para": "Compare bitwise Test bits nonzero (vector). This instruction reads each vector  element in the first source SIMD&FP register, performs an AND with the  corresponding vector element in the second source SIMD&FP register, and if the  result is not zero, sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["CMTST  <V><d>, <V><n>, <V><m>", "CMTST  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 410, "asmtemplate": "STLRB  <Wt>, [<Xn|SP>{,#0}]", "brief": "Store-Release Register Byte", "heading": "STLRB", "para": "Store-Release Register Byte stores a byte from a 32-bit register to a memory  location. The instruction also has memory ordering semantics as described in  Load-Acquire, Store-Release. For information about memory accesses, see  Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STLRB  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 399, "asmtemplate": "LDSMINLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic signed minimum on halfword in memory, without return", "heading": "STSMINH, STSMINLH", "para": "Atomic signed minimum on halfword in memory, without return, atomically loads  a 16-bit halfword from memory, compares it against the value held in a  register, and stores the smaller value back to memory, treating the values as  signed numbers.  \n* STSMINH does not have release semantics. \n* STSMINLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH. \n* The description of LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSMINH  <Ws>, [<Xn|SP>]"]}, {"id": 685, "asmtemplate": "LDXR  <Xt>, [<Xn|SP>{,#0}]", "brief": "Load Exclusive Register", "heading": "LDXR", "para": "Load Exclusive Register derives an address from a base register value, loads a  32-bit word or a 64-bit doubleword from memory, and writes it to a register.  The memory access is atomic. The PE marks the physical address being accessed  as an exclusive access. This exclusive access mark is checked by Store  Exclusive instructions. See Synchronization and semaphores. For information  about memory accesses see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDXR  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 74, "asmtemplate": "UDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Unsigned reversed divide (predicated)", "heading": "UDIVR", "para": "Unsigned reversed divide (predicated). \n\nUnsigned reversed divide active elements of the second source vector by  corresponding elements of the first source vector and destructively place the  quotient in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1154, "asmtemplate": "ADDV  <V><d>, <Vn>.<T>", "brief": "Add across Vector", "heading": "ADDV", "para": "Add across Vector. This instruction adds every vector element in the source  SIMD&FP register together, and writes the scalar result to the destination  SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["ADDV  <V><d>, <Vn>.<T>"]}, {"id": 96, "asmtemplate": "LD1RQW  {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate four words (immediate index)", "heading": "LD1RQW (scalar plus immediate)", "para": "Contiguous load and replicate four words (immediate index). \n\nLoad four contiguous words to elements of a short, 128-bit (quadword) vector  from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 16 in the range -128 to +112 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first four predicate elements are used and  higher numbered predicate elements are ignored.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 362, "asmtemplate": "ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D", "brief": "Arithmetic shift right by 64-bit wide elements (predicated)", "heading": "ASR (wide elements, predicated)", "para": "Arithmetic shift right by 64-bit wide elements (predicated). \n\nShift right, preserving the sign bit, active elements of the first source  vector by corresponding overlapping 64-bit elements of the second source  vector and destructively place the results in the corresponding elements of  the first source vector. The shift amount is a vector of unsigned 64-bit  doubleword elements in which all bits are significant, and not used modulo the  destination element size. Inactive elements in the destination vector register  remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D"]}, {"id": 123, "asmtemplate": "ASRD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>", "brief": "Arithmetic shift right for divide by immediate (predicated)", "heading": "ASRD", "para": "Arithmetic shift right for divide by immediate (predicated). \n\nShift right by immediate, preserving the sign bit, each active element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. The result rounds toward zero as in a signed  division. The immediate shift amount is an unsigned value in the range 1 to  number of bits per element. Inactive elements in the destination vector  register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>": "Is the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\".", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["ASRD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>"]}, {"id": 788, "asmtemplate": "LD4  {<Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Load single 4-element structure to one lane of four registers", "heading": "LD4 (single structure)", "para": "Load single 4-element structure to one lane of four registers. This  instruction loads a 4-element structure from memory and writes the result to  the corresponding elements of the four SIMD&FP registers without affecting the  other bits of the registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "\".", "<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Vt3>": "Is the name of the third SIMD", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Vt>": "Is the name of the first or only SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]", "LD4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4"]}, {"id": 556, "asmtemplate": "TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Transpose vectors (primary)", "heading": "TRN1", "para": "Transpose vectors (primary). This instruction reads corresponding  even-numbered vector elements from the two source SIMD&FP registers, starting  at zero, places each result into consecutive elements of a vector, and writes  the vector to the destination SIMD&FP register. Vector elements from the first  source register are placed into even-numbered elements of the destination  vector, starting at zero, while vector elements from the second source  register are placed into odd-numbered elements of the destination vector. \n\nBy using this instruction with TRN2, a 2 x 2 matrix can be transposed. \n\nThe following figure shows an example of the operation of TRN1 and TRN2  halfword operations where Q = 0. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["TRN1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 839, "asmtemplate": "LD1SB   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load signed bytes to vector (immediate index)", "heading": "LD1SB (scalar plus immediate)", "para": "Contiguous load signed bytes to vector (immediate index). \n\nContiguous load of signed bytes to elements of a vector register from the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements will not not  cause a read from Device memory or signal a fault, and are set to zero in the  destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1SB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 457, "asmtemplate": "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector)", "heading": "SQRDMLAH (vector)", "para": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half \n(vector). This instruction multiplies the vector elements of the first source  SIMD&FP register with the corresponding vector elements of the second source  SIMD&FP register without saturating the multiply results, doubles the results,  and accumulates the most significant half of the final results with the vector  elements of the destination SIMD&FP register. The results are rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation  bit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQRDMLAH  <V><d>, <V><n>, <V><m>", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1159, "asmtemplate": "MVNI  <Vd>.<T>, #<imm8>, MSL #<amount>", "brief": "Move inverted Immediate (vector)", "heading": "MVNI", "para": "Move inverted Immediate (vector). This instruction places the inverse of an  immediate constant into every vector element of the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD", "<T><T><imm8>": "Is an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\"."}, "encodings": ["MVNI  <Vd>.<T>, #<imm8>{, LSL #<amount>}"]}, {"id": 93, "asmtemplate": "UZP2    <Zd>.Q, <Zn>.Q, <Zm>.Q", "brief": "Concatenate even or odd elements from two vectors", "heading": "UZP1, UZP2 (vectors)", "para": "Concatenate even or odd elements from two vectors. \n\nConcatenate adjacent even or odd-numbered elements from the first and second  source vectors and place in elements of the destination vector. This  instruction is unpredicated. The 128-bit element variant of this instruction  requires that the current vector length is at least 256 bits, and if the  current vector length is not an integer multiple of 256 bits then the trailing  bits are set to zero. \n\nID_AA64ZFR0_EL1.F64MM indicates whether the 128-bit element variant of the  instruction is implemented. \n\nIt has encodings from 4 classes: Even , Even (quadwords) , Odd and Odd \n(quadwords)", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["UZP1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "UZP1    <Zd>.Q, <Zn>.Q, <Zm>.Q", "UZP2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "UZP2    <Zd>.Q, <Zn>.Q, <Zm>.Q"]}, {"id": 1152, "asmtemplate": "UMINV  <V><d>, <Vn>.<T>", "brief": "Unsigned Minimum across Vector", "heading": "UMINV", "para": "Unsigned minimum reduction to scalar. \n\nUnsigned minimum horizontally across all lanes of a vector, and place the  result in the SIMD&FP scalar destination register. Inactive elements in the  source vector are treated as the maximum unsigned integer for the element  size.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["UMINV   <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 1229, "asmtemplate": "CCMN  <Xn>, <Xm>, #<nzcv>, <cond>", "brief": "Conditional Compare Negative (register)", "heading": "CCMN (register)", "para": "Conditional Compare Negative (register) sets the value of the condition flags  to the result of the comparison of a register value and the inverse of another  register value if the condition is TRUE, and an immediate value otherwise.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<nzcv>": "Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["CCMN  <Wn>, <Wm>, #<nzcv>, <cond>"]}, {"id": 285, "asmtemplate": "FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point subtract vectors (predicated)", "heading": "FSUB (vectors, predicated)", "para": "Floating-point subtract vectors (predicated). \n\nSubtract active floating-point elements of the second source vector from  corresponding floating-point elements of the first source vector and  destructively place the results in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 934, "asmtemplate": "FRINTI  <Dd>, <Dn>", "brief": "Floating-point Round to Integral, using current rounding mode (scalar)", "heading": "FRINTI (scalar)", "para": "Floating-point Round to Integral, using current rounding mode (scalar). This  instruction rounds a floating-point value in the SIMD&FP source register to an  integral floating-point value of the same size using the rounding mode that is  determined by the FPCR, and writes the result to the SIMD&FP destination  register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Dn>": "Is the 64-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTI  <Hd>, <Hn>"]}, {"id": 888, "asmtemplate": "SMAXV  <V><d>, <Vn>.<T>", "brief": "Signed Maximum across Vector", "heading": "SMAXV", "para": "Signed Maximum across Vector. This instruction compares all the vector  elements in the source SIMD&FP register, and writes the largest of the values  as a scalar to the destination SIMD&FP register. All the values in this  instruction are signed integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["SMAXV  <V><d>, <Vn>.<T>"]}, {"id": 249, "asmtemplate": "BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "BFloat16 floating-point dot product (vector)", "heading": "BFDOT (vector)", "para": "BFloat16 floating-point dot product (vector). This instruction delimits the  source vectors into pairs of 16-bit BF16 elements. Within each pair, the  elements in the first source vector are multiplied by the corresponding  elements in the second source vector. The resulting single-precision products  are then summed and added destructively to the single-precision element of the  destination vector that aligns with the pair of BF16 values in the first  source vector. The instruction ignores the FPCR and does not update the FPSR  exception status.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 406, "asmtemplate": "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed saturating Doubling Multiply returning High half", "heading": "SQDMULH (vector)", "para": "Signed saturating Doubling Multiply returning High half. This instruction  multiplies the values of corresponding elements of the two source SIMD&FP  registers, doubles the results, places the most significant half of the final  results into a vector, and writes the vector to the destination SIMD&FP  register. \n\nThe results are truncated. For rounded results, see SQRDMULH. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQDMULH  <V><d>, <V><n>, <V><m>", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1255, "asmtemplate": "BFM<Xd>, XZR, #(-<lsb> MOD 64), #(<width>-1)", "brief": "Bitfield Clear", "heading": "BFC", "para": "Bitfield Clear sets a bitfield of <width> bits at bit position <lsb> of the  destination register to zero, leaving the other destination bits unchanged. \n\nThis is an alias of BFM. This means:  \n* The encodings in this description are named to match the encodings of BFM. \n* The description of BFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["BFC  <Wd>, #<lsb>, #<width>"]}, {"id": 226, "asmtemplate": "FCMLA   <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>", "brief": "Floating-point complex multiply-add by indexed values with rotate", "heading": "FCMLA (indexed)", "para": "Floating-point complex multiply-add by indexed values with rotate. \n\nMultiply the duplicated real components for rotations 0 and 180, or imaginary  components for rotations 90 and 270, of the floating-point complex numbers in  each 128-bit segment of the first source vector by the specified complex  number in the corresponding the second source vector segment rotated by 0, 90,  180 or 270 degrees in the direction from the positive real axis towards the  positive imaginary axis, when considered in polar representation. \n\nThen destructively add the products to the corresponding components of the  complex numbers in the addend and destination vector, without intermediate  rounding. \n\nThese transformations permit the creation of a variety of multiply-add and  multiply-subtract operations on complex numbers by combining two of these  instructions with the same vector operands but with rotations that are 90  degrees apart. \n\nEach complex number is represented in a vector register as an even/odd pair of  elements with the real part in the even-numbered element and the imaginary  part in the odd-numbered element. \n\nThe complex numbers within the second source vector are specified using an  immediate index which selects the same complex number position within each  128-bit vector segment. The index range is from 0 to one less than the number  of complex numbers per 128-bit segment, encoded in 1 to 2 bits depending on  the size of the complex number. This instruction is unpredicated. \n\nIt has encodings from 2 classes: Half-precision and Single-precision", "explanations": {"<imm>": "For the single-precision variant: is the index of a Real and Imaginary pair, in the range 0 to 1, encoded in the \"i1\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "For the single-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["FCMLA   <Zda>.H, <Zn>.H, <Zm>.H[<imm>], <const>", "FCMLA   <Zda>.S, <Zn>.S, <Zm>.S[<imm>], <const>"]}, {"id": 704, "asmtemplate": "SQINCP  <Xdn>, <Pm>.<T>", "brief": "Signed saturating increment scalar by count of true predicate elements", "heading": "SQINCP (scalar)", "para": "Signed saturating increment scalar by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to increment the scalar destination. The result is saturated to the  source general-purpose register's signed integer range. A 32-bit saturated  result is then sign-extended to 64 bits. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<T><Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field."}, "encodings": ["SQINCP  <Xdn>, <Pm>.<T>, <Wdn>", "SQINCP  <Xdn>, <Pm>.<T>"]}, {"id": 1032, "asmtemplate": "LDURSH  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Signed Halfword (unscaled)", "heading": "LDURSH", "para": "Load Register Signed Halfword (unscaled) calculates an address from a base  register and an immediate offset, loads a signed halfword from memory,  sign-extends it, and writes it to a register. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDURSH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 974, "asmtemplate": "ORR<Xd>, XZR, <Xm>", "brief": "Move (register)", "heading": "MOV (register)", "para": "Move (register) copies the value in a source register to the destination  register. \n\nThis is an alias of ORR (shifted register). This means:  \n* The encodings in this description are named to match the encodings of ORR \n  (shifted register). \n* The description of ORR (shifted register) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["MOV  <Wd>, <Wm>"]}, {"id": 315, "asmtemplate": "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load Register Byte (immediate)", "heading": "LDRB (immediate)", "para": "Load Register Byte (immediate) loads a byte from memory, zero-extends it, and  writes the result to a register. The address that is used for the load is  calculated from a base register and an immediate offset. For information about  memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."}, "encodings": ["LDRB  <Wt>, [<Xn|SP>], #<simm>", "LDRB  <Wt>, [<Xn|SP>, #<simm>]!", "LDRB  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 341, "asmtemplate": "UQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Unsigned saturating add vectors (unpredicated)", "heading": "UQADD (vectors)", "para": "Unsigned saturating add vectors (unpredicated). \n\nUnsigned saturating add all elements of the second source vector to  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. Each result element is  saturated to the N-bit element's unsigned integer range 0 to (2N)-1. This  instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["UQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 1041, "asmtemplate": "UQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement scalar by multiple of 16-bit predicate constraint element count", "heading": "UQDECH (scalar)", "para": "Unsigned saturating decrement scalar by multiple of 16-bit predicate  constraint element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECH  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 367, "asmtemplate": "PRFM  (<prfop>|#<imm5>), <label>", "brief": "Prefetch Memory (literal)", "heading": "PRFM (literal)", "para": "Prefetch Memory (literal) signals the memory system that data memory accesses  from a specified address are likely to occur in the near future. The memory  system can respond by taking actions that are expected to speed up the memory  accesses when they do occur, such as preloading the cache line containing the  specified address into one or more caches. \n\nThe effect of an PRFM instruction is implementation defined. For more  information, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"": "This syntax is only for encodings that are not accessible using ", "<prfop>": "Is the prefetch operation, defined as ", "<imm5>": "Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<label>": "Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."}, "encodings": ["PRFM  (<prfop>|#<imm5>), <label>"]}, {"id": 101, "asmtemplate": "LDFF1B  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "brief": "Contiguous load first-fault unsigned bytes to vector (scalar index)", "heading": "LDFF1B (scalar plus scalar)", "para": "Contiguous load first-fault unsigned bytes to vector (scalar index). \n\nContiguous load with first-faulting behavior of unsigned bytes to elements of  a vector register from the memory address generated by a 64-bit scalar base  and scalar index which is added to the base address. After each element access  the index value is incremented, but the index register is not updated.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nIt has encodings from 4 classes: 8-bit element , 16-bit element , 32-bit  element and 64-bit element", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "LDFF1B  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "LDFF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]"]}, {"id": 842, "asmtemplate": "AND     <Zdn>.<T>, <Zdn>.<T>, #<const>", "brief": "Bitwise AND with immediate (unpredicated)", "heading": "AND (immediate)", "para": "Bitwise AND with immediate (unpredicated). \n\nBitwise AND an immediate with each 64-bit element of the source vector, and  destructively place the results in the corresponding elements of the source  vector. The immediate is a 64-bit value consisting of a single run of ones or  zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction is  unpredicated. \n\nThis instruction is used by the pseudo-instruction BIC (immediate).", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><const>": "Is a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."}, "encodings": ["AND     <Zdn>.<T>, <Zdn>.<T>, #<const>"]}, {"id": 320, "asmtemplate": "UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Absolute Difference (vector)", "heading": "UABD", "para": "Unsigned Absolute Difference (vector). This instruction subtracts the elements  of the vector of the second source SIMD&FP register from the corresponding  elements of the first source SIMD&FP register, places the the absolute values  of the results into a vector, and writes the vector to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 580, "asmtemplate": "UQRSHRN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Unsigned saturating Rounded Shift Right Narrow (immediate)", "heading": "UQRSHRN, UQRSHRN2", "para": "Unsigned saturating Rounded Shift Right Narrow (immediate). This instruction  reads each vector element in the source SIMD&FP register, right shifts each  result by an immediate value, puts the final result into a vector, and writes  the vector to the lower or upper half of the destination SIMD&FP register. All  the values in this instruction are unsigned integer values. The results are  rounded. For truncated results, see UQSHRN. \n\nThe UQRSHRN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the UQRSHRN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Va><n>": "Is the number of the first SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["UQRSHRN  <Vb><d>, <Va><n>, #<shift>", "UQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 555, "asmtemplate": "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Minimum Pairwise (vector)", "heading": "FMINP (vector)", "para": "Floating-point Minimum Pairwise (vector). This instruction creates a vector by  concatenating the vector elements of the first source SIMD&FP register after  the vector elements of the second source SIMD&FP register, reads each pair of  adjacent vector elements from the concatenated vector, writes the smaller of  each pair of values into a vector, and writes the vector to the destination  SIMD&FP register. All the values in this instruction are floating-point  values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 119, "asmtemplate": "BIC     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Bitwise clear vectors (predicated)", "heading": "BIC (vectors, predicated)", "para": "Bitwise clear vectors (predicated). \n\nBitwise AND inverted active elements of the second source vector with  corresponding elements of the first source vector and destructively place the  results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["BIC     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 387, "asmtemplate": "FCVTMU  <Xd>, <Dn>", "brief": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar)", "heading": "FCVTMU (scalar)", "para": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP  source register to a 32-bit or 64-bit unsigned integer using the Round towards  Minus Infinity rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTMU  <Wd>, <Hn>"]}, {"id": 1219, "asmtemplate": "SMLSL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Signed Multiply-Subtract Long (vector, by element)", "heading": "SMLSL, SMLSL2 (by element)", "para": "Signed Multiply-Subtract Long (vector, by element). This instruction  multiplies each vector element in the lower or upper half of the first source  SIMD&FP register by the specified vector element of the second source SIMD&FP  register and subtracts the results from the vector elements of the destination  SIMD&FP register. The destination vector elements are twice as long as the  elements that are multiplied. \n\nThe SMLSL instruction extracts vector elements from the lower half of the  first source register, while the SMLSL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 427, "asmtemplate": "BFMLALB <Zda>.S, <Zn>.H, <Zm>.H", "brief": "BFloat16 floating-point multiply-add long to single-precision (bottom)", "heading": "BFMLALB (vectors)", "para": "BFloat16 floating-point multiply-add long to single-precision (bottom). \n\nThis BFloat16 floating-point multiply-add long instruction widens the  even-numbered 16-bit BFloat16 elements in the first source vector and the  corresponding elements in the second source vector to single-precision format  and then destructively multiplies and adds these values without intermediate  rounding to the overlapping 32-bit single-precision elements of the addend and  destination vector. This instruction is unpredicated. \n\nUnlike the BFloat16 matrix multiplication and dot product instructions, this  instruction performs a fused multiply-add that honors all of the FPCR bits  that apply to single-precision arithmetic. It can also generate a  floating-point exception that causes cumulative exception bits in the FPSR to  be set, or a synchronous exception to be taken, depending on the enable bits  in the FPCR. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["BFMLALB <Zda>.S, <Zn>.H, <Zm>.H"]}, {"id": 88, "asmtemplate": "LDARH  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Register Halfword", "heading": "LDARH", "para": "Load-Acquire Register Halfword derives an address from a base register value,  loads a halfword from memory, zero-extends it, and writes it to a register.  The instruction also has memory ordering semantics as described in  Load-Acquire, Store-Release. For information about memory accesses, see  Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/XZR, it is impossible for  software to observe the presence of the acquire semantic other than its effect  on the arrival at endpoints.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDARH  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 186, "asmtemplate": "LDUMAXLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic unsigned maximum on byte in memory, without return", "heading": "STUMAXB, STUMAXLB", "para": "Atomic unsigned maximum on byte in memory, without return, atomically loads an  8-bit byte from memory, compares it against the value held in a register, and  stores the larger value back to memory, treating the values as unsigned  numbers.  \n* STUMAXB does not have release semantics. \n* STUMAXLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB. \n* The description of LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STUMAXB  <Ws>, [<Xn|SP>]"]}, {"id": 602, "asmtemplate": "SSBB", "brief": "Speculative Store Bypass Barrier", "heading": "SSBB", "para": "Speculative Store Bypass Barrier is a memory barrier which prevents  speculative loads from bypassing earlier stores to the same virtual address  under certain conditions. \n\nThe semantics of the Speculative Store Bypass Barrier are:  \n* When a load to a location appears in program order after the SSBB, then the \n  load does not speculatively read an entry earlier in the coherence order for \n  that location than the entry generated by the latest store satisfying all of \n  the following conditions:The store is to the same location as the load.The \n  store uses the same virtual address as the load.The store appears in program \n  order before the SSBB. \n* When a load to a location appears in program order before the SSBB, then the \n  load does not speculatively read data from any store satisfying all of the \n  following conditions:The store is to the same location as the load.The store \n  uses the same virtual address as the load.The store appears in program order \n  after the SSBB.", "explanations": {}, "encodings": ["SSBB"]}, {"id": 38, "asmtemplate": "LD3H    {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load three-halfword structures to three vectors (immediate index)", "heading": "LD3H (scalar plus immediate)", "para": "Contiguous load three-halfword structures to three vectors (immediate index). \n\nContiguous load three-halfword structures, each to the same element number in  three vector registers from the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 3 in the range -24 to 21  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive halfwords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 107, "asmtemplate": "UBFM<Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)", "brief": "Unsigned Bitfield Insert in Zero", "heading": "UBFIZ", "para": "Unsigned Bitfield Insert in Zeros copies a bitfield of <width> bits from the  least significant bits of the source register to bit position <lsb> of the  destination register, setting the destination bits above and below the  bitfield to zero. \n\nThis is an alias of UBFM. This means:  \n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-"}, "encodings": ["UBFIZ  <Wd>, <Wn>, #<lsb>, #<width>"]}, {"id": 517, "asmtemplate": "FCCMPE  <Dn>, <Dm>, #<nzcv>, <cond>", "brief": "Floating-point Conditional signaling Compare (scalar)", "heading": "FCCMPE", "para": "Floating-point Conditional signaling Compare (scalar). This instruction  compares the two SIMD&FP source register values and writes the result to the  PSTATE.{N, Z, C, V} flags. If the condition does not pass then the PSTATE.{N,  Z, C, V} flags are set to the flag bit specifier. \n\nThis instruction raises an Invalid Operation floating-point exception if  either or both of the operands is any type of NaN. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<nzcv>": "Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<Dn>": "Is the 64-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FCCMPE  <Hn>, <Hm>, #<nzcv>, <cond>"]}, {"id": 1116, "asmtemplate": "FMINNM  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Minimum Number (scalar)", "heading": "FMINNM (scalar)", "para": "Floating-point Minimum Number (scalar). This instruction compares the first  and second source SIMD&FP register values, and writes the smaller of the two  floating-point values to the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result that is placed in  the vector is the numerical value, otherwise the result is identical to FMIN \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Hm>": "Is the 16-bit name of the second SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMINNM  <Hd>, <Hn>, <Hm>"]}, {"id": 669, "asmtemplate": "EORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise exclusive OR predicates", "heading": "EOR, EORS (predicates)", "para": "Bitwise exclusive OR predicates. \n\nBitwise exclusive OR active elements of the second source predicate with  corresponding elements of the first source predicate and place the results in  the corresponding elements of the destination predicate. Inactive elements in  the destination predicate register are set to zero. Optionally sets the First \n(N), None (Z), !Last (C) condition flags based on the predicate result, and  the V flag to zero. \n\nThis instruction is used by the aliases NOTS, and NOT (predicate). \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["EOR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "EORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 426, "asmtemplate": "UMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B", "brief": "Unsigned 8-bit integer matrix multiply-accumulate (vector)", "heading": "UMMLA (vector)", "para": "Unsigned 8-bit integer matrix multiply-accumulate. This instruction multiplies  the 2x8 matrix of unsigned 8-bit integer values in the first source vector by  the 8x2 matrix of unsigned 8-bit integer values in the second source vector.  The resulting 2x2 32-bit integer matrix product is destructively added to the  32-bit integer matrix accumulator in the destination vector. This is  equivalent to performing an 8-way dot product per destination element. \n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is  mandatory for implementations that include Advanced SIMD to support it.  ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["UMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"]}, {"id": 919, "asmtemplate": "LDR  <Xt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load Register (immediate)", "heading": "LDR (immediate)", "para": "Load Register (immediate) loads a word or doubleword from memory and writes it  to a register. The address that is used for the load is calculated from a base  register and an immediate offset. For information about memory accesses, see  Load/Store addressing modes. The Unsigned offset variant scales the immediate  offset value by the size of the value accessed before adding it to the base  register value. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/8.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as ", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDR  <Wt>, [<Xn|SP>], #<simm>", "LDR  <Wt>, [<Xn|SP>, #<simm>]!", "LDR  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 1211, "asmtemplate": "LD4H    {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load four-halfword structures to four vectors (immediate index)", "heading": "LD4H (scalar plus immediate)", "para": "Contiguous load four-halfword structures to four vectors (immediate index). \n\nContiguous load four-halfword structures, each to the same element number in  four vector registers from the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 4 in the range -32 to 28  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive halfwords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 782, "asmtemplate": "MUL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Multiply vectors (predicated)", "heading": "MUL (vectors)", "para": "Multiply vectors (predicated). \n\nMultiply active elements of the first source vector by corresponding elements  of the second source vector and destructively place the results in the  corresponding elements of the first source vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["MUL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 371, "asmtemplate": "FMADD  <Dd>, <Dn>, <Dm>, <Da>", "brief": "Floating-point fused Multiply-Add (scalar)", "heading": "FMADD", "para": "Floating-point fused Multiply-Add (scalar). This instruction multiplies the  values of the first two SIMD&FP source registers, adds the product to the  value of the third SIMD&FP source register, and writes the result to the  SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register holding the addend, encoded in the \"Ra\" field.", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Da>": "Is the 64-bit name of the third SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Ha>": "Is the 16-bit name of the third SIMD", "<Sa>": "Is the 32-bit name of the third SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMADD  <Hd>, <Hn>, <Hm>, <Ha>"]}, {"id": 688, "asmtemplate": "DSB  <option>nXS|#<imm>", "brief": "Data Synchronization Barrier", "heading": "DSB", "para": "Data Synchronization Barrier is a memory barrier that ensures the completion  of memory accesses, see Data Synchronization Barrier. \n\nA DSB instruction with the nXS qualifier is complete when the subset of these  memory accesses with the XS attribute set to 0 are complete. It does not  require that memory accesses with the XS attribute set to 1 are complete. \n\nIt has encodings from 2 classes: Memory barrier and Memory nXS barrier", "explanations": {"": "The value ", "<imm>": "For the memory barrier variant: is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field.", "<option>": "For the memory nXS barrier variant: specifies the limitation on the barrier operation. Values are:"}, "encodings": ["DSB  <option>|#<imm>", "DSB  <option>nXS|#<imm>"]}, {"id": 614, "asmtemplate": "UDF  #<imm>", "brief": "Permanently Undefined", "heading": "UDF", "para": "Permanently Undefined generates an Undefined Instruction exception (ESR_ELx.EC \n= 0b000000). The encodings for UDF used in this section are defined as  permanently undefined in the Armv8-A architecture.", "explanations": {"<imm>": "is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field. The PE ignores the value of this constant."}, "encodings": ["UDF  #<imm>"]}, {"id": 1028, "asmtemplate": "CCMP  <Xn>, #<imm>, #<nzcv>, <cond>", "brief": "Conditional Compare (immediate)", "heading": "CCMP (immediate)", "para": "Conditional Compare (immediate) sets the value of the condition flags to the  result of the comparison of a register value and an immediate value if the  condition is TRUE, and an immediate value otherwise.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<imm>": "Is a five bit unsigned (positive) immediate encoded in the \"imm5\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<nzcv>": "Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way."}, "encodings": ["CCMP  <Wn>, #<imm>, #<nzcv>, <cond>"]}, {"id": 133, "asmtemplate": "LSR     <Zd>.<T>, <Zn>.<T>, <Zm>.D", "brief": "Logical shift right by 64-bit wide elements (unpredicated)", "heading": "LSR (wide elements, unpredicated)", "para": "Logical shift right by 64-bit wide elements (unpredicated). \n\nShift right, inserting zeroes, all elements of the first source vector by  corresponding overlapping 64-bit elements of the second source vector and  place the first in the corresponding elements of the destination vector. The  shift amount is a vector of unsigned 64-bit doubleword elements in which all  bits are significant, and not used modulo the destination element size. This  instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["LSR     <Zd>.<T>, <Zn>.<T>, <Zm>.D"]}, {"id": 349, "asmtemplate": "PRFB    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous prefetch bytes (immediate index)", "heading": "PRFB (scalar plus immediate)", "para": "Contiguous prefetch bytes (immediate index). \n\nContiguous prefetch of byte elements from the memory address generated by a  64-bit scalar base and immediate index in the range -32 to 31 which is  multiplied by the vector's in-memory size, irrespective of predication, and  added to the base address. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFB    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 729, "asmtemplate": "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Minimum Number (vector)", "heading": "FMINNM (vector)", "para": "Floating-point Minimum Number (vector). This instruction compares  corresponding vector elements in the two source SIMD&FP registers, writes the  smaller of the two floating-point values into a vector, and writes the vector  to the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result placed in the  vector is the numerical value, otherwise the result is identical to FMIN \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMINNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 560, "asmtemplate": "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Multiply-Add to accumulator (vector, by element)", "heading": "MLA (by element)", "para": "Multiply-Add to accumulator (vector, by element). This instruction multiplies  the vector elements in the first source SIMD&FP register by the specified  value in the second source SIMD&FP register, and accumulates the results with  the vector elements of the destination SIMD&FP register. All the values in  this instruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 1217, "asmtemplate": "PACIBZ", "brief": "Pointer Authentication Code for Instruction address, using key B", "heading": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB", "para": "Pointer Authentication Code for Instruction address, using key B. This  instruction computes and inserts a pointer authentication code for an  instruction address, using a modifier and key B. \n\nThe address is:  \n* In the general-purpose register that is specified by <Xd> for PACIB and \n  PACIZB. \n* In X17, for PACIB1716. \n* In X30, for PACIBSP and PACIBZ.  The modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACIB. \n* The value zero, for PACIZB and PACIBZ. \n* In X16, for PACIB1716. \n* In SP, for PACIBSP.  It has encodings from 2 classes: Integer and System", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["PACIB  <Xd>, <Xn|SP>", "PACIB1716"]}, {"id": 1, "asmtemplate": "ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Zip vectors (primary)", "heading": "ZIP1", "para": "Zip vectors (primary). This instruction reads adjacent vector elements from  the lower half of two source SIMD&FP registers as pairs, interleaves the pairs  and places them into a vector, and writes the vector to the destination  SIMD&FP register. The first pair from the first source register is placed into  the two lowest vector elements, with subsequent pairs taken alternately from  each source register. \n\nThis instruction can be used with ZIP2 to interleave two vectors. \n\nThe following figure shows an example of the operation of ZIP1 and ZIP2 with  the arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["ZIP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 274, "asmtemplate": "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Compare signed Greater than or Equal (vector)", "heading": "CMGE (register)", "para": "Compare signed Greater than or Equal (vector). This instruction compares each  vector element in the first source SIMD&FP register with the corresponding  vector element in the second source SIMD&FP register and if the first signed  integer value is greater than or equal to the second signed integer value sets  every bit of the corresponding vector element in the destination SIMD&FP  register to one, otherwise sets every bit of the corresponding vector element  in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["CMGE  <V><d>, <V><n>, <V><m>", "CMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 528, "asmtemplate": "PRFD    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Gather prefetch doublewords (vector plus immediate)", "heading": "PRFD (vector plus immediate)", "para": "Gather prefetch doublewords (vector plus immediate). \n\nGather prefetch of doublewords from the active memory addresses generated by a  vector base plus immediate index. The index is a multiple of 8 in the range 0  to 248. Inactive addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFD    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]", "PRFD    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 1151, "asmtemplate": "BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise Select", "heading": "BSL", "para": "Bitwise Select. This instruction sets each bit in the destination SIMD&FP  register to the corresponding bit from the first source SIMD&FP register when  the original destination bit was 1, otherwise from the second source SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["BSL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 755, "asmtemplate": "DUP<Zd>.<T>, #0", "brief": "Move floating-point +0.0 to vector elements (unpredicated)", "heading": "FMOV (zero, unpredicated)", "para": "Move floating-point +0.0 to vector elements (unpredicated). \n\nUnconditionally broadcast the floating-point constant +0.0 into each element  of the destination vector. This instruction is unpredicated. \n\nThis is a pseudo-instruction of DUP (immediate). This means:  \n* The encodings in this description are named to match the encodings of DUP \n  (immediate). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of DUP (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FMOV    <Zd>.<T>, #0.0"]}, {"id": 522, "asmtemplate": "FMAXV   <V><d>, <Pg>, <Zn>.<T>", "brief": "Floating-point maximum recursive reduction to scalar", "heading": "FMAXV", "para": "Floating-point Maximum across Vector. This instruction compares all the vector  elements in the source SIMD&FP register, and writes the largest of the values  as a scalar to the destination SIMD&FP register. All the values in this  instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD"}, "encodings": ["FMAXV  <V><d>, <Vn>.<T>", "FMAXV  <V><d>, <Vn>.<T>"]}, {"id": 489, "asmtemplate": "FMAXNM  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Maximum Number (scalar)", "heading": "FMAXNM (scalar)", "para": "Floating-point Maximum Number (scalar). This instruction compares the first  and second source SIMD&FP register values, and writes the larger of the two  floating-point values to the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result that is placed in  the vector is the numerical value, otherwise the result is identical to FMAX \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Dn>": "Is the 64-bit name of the first SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMAXNM  <Hd>, <Hn>, <Hm>"]}, {"id": 498, "asmtemplate": "CMLE  <Vd>.<T>, <Vn>.<T>, #0", "brief": "Compare signed Less than or Equal to zero (vector)", "heading": "CMLE (zero)", "para": "Compare signed Less than or Equal to zero (vector). This instruction reads  each vector element in the source SIMD&FP register and if the signed integer  value is less than or equal to zero sets every bit of the corresponding vector  element in the destination SIMD&FP register to one, otherwise sets every bit  of the corresponding vector element in the destination SIMD&FP register to  zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["CMLE  <V><d>, <V><n>, #0", "CMLE  <Vd>.<T>, <Vn>.<T>, #0"]}, {"id": 238, "asmtemplate": "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Floating-point convert to unsigned integer, rounding toward zero (predicated)", "heading": "FCVTZU", "para": "Floating-point convert to unsigned integer, rounding toward zero (predicated). \n\nConvert to the unsigned integer nearer to zero from each active floating-point  element of the source vector, and place the results in the corresponding  elements of the destination vector. Inactive elements in the destination  vector register remain unmodified. \n\nIf the input and result types have a different size the smaller type is held  unpacked in the least significant bits of elements of the larger size. When  the input is the smaller type the upper bits of each source element are  ignored. When the result is the smaller type the results are zero-extended to  fill each destination element. \n\nIt has encodings from 7 classes: Half-precision to 16-bit , Half-precision to  32-bit , Half-precision to 64-bit , Single-precision to 32-bit ,  Single-precision to 64-bit , Double-precision to 32-bit and Double-precision  to 64-bit", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FCVTZU  <Zd>.H, <Pg>/M, <Zn>.H", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.H", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.H", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.S", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.S", "FCVTZU  <Zd>.S, <Pg>/M, <Zn>.D", "FCVTZU  <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 1087, "asmtemplate": "COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>", "brief": "Shuffle active elements of vector to the right and fill with zero", "heading": "COMPACT", "para": "Shuffle active elements of vector to the right and fill with zero. \n\nRead the active elements from the source vector and pack them into the  lowest-numbered elements of the destination vector. Then set any remaining  elements of the destination vector to zero.", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["COMPACT <Zd>.<T>, <Pg>, <Zn>.<T>"]}, {"id": 215, "asmtemplate": "SUBPS XZR, <Xn|SP>, <Xm|SP>", "brief": "Compare with Tag", "heading": "CMPP", "para": "Compare with Tag subtracts the 56-bit address held in the second source  register from the 56-bit address held in the first source register, updates  the condition flags based on the result of the subtraction, and discards the  result. \n\nThis is an alias of SUBPS. This means:  \n* The encodings in this description are named to match the encodings of SUBPS. \n* The description of SUBPS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm|SP>": "Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Xm\" field."}, "encodings": ["CMPP  <Xn|SP>, <Xm|SP>"]}, {"id": 750, "asmtemplate": "FRINTZ  <Dd>, <Dn>", "brief": "Floating-point Round to Integral, toward Zero (scalar)", "heading": "FRINTZ (scalar)", "para": "Floating-point Round to Integral, toward Zero (scalar). This instruction  rounds a floating-point value in the SIMD&FP source register to an integral  floating-point value of the same size using the Round towards Zero rounding  mode, and writes the result to the SIMD&FP destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTZ  <Hd>, <Hn>"]}, {"id": 586, "asmtemplate": "STR  <Qt>, [<Xn|SP>{, #<pimm>}]", "brief": "Store SIMD&FP register (immediate offset)", "heading": "STR (immediate, SIMD&FP)", "para": "Store SIMD&FP register (immediate offset). This instruction stores a single  SIMD&FP register to memory. The address that is used for the store is  calculated from a base register value and an immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/16.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "For the 128-bit variant: is the optional positive immediate byte offset, a multiple of 16 in the range 0 to 65520, defaulting to 0 and encoded in the \"imm12\" field as ", "<St>": "Is the 32-bit name of the SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Dt>": "Is the 64-bit name of the SIMD", "<Qt>": "Is the 128-bit name of the SIMD", "<Ht>": "Is the 16-bit name of the SIMD", "<Bt>": "Is the 8-bit name of the SIMD"}, "encodings": ["STR  <Bt>, [<Xn|SP>], #<simm>", "STR  <Bt>, [<Xn|SP>, #<simm>]!", "STR  <Bt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 110, "asmtemplate": "UQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment vector by multiple of 64-bit predicate constraint element count", "heading": "UQINCD (vector)", "para": "Unsigned saturating increment vector by multiple of 64-bit predicate  constraint element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. The  results are saturated to the 64-bit unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}"]}, {"id": 743, "asmtemplate": "MLA     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>", "brief": "Multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]", "heading": "MLA", "para": "Multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]. \n\nMultiply the corresponding active elements of the first and second source  vectors and add to elements of the third source (addend) vector. Destructively  place the results in the destination and third source (addend) vector.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["MLA     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>"]}, {"id": 282, "asmtemplate": "USDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]", "brief": "Unsigned by signed integer indexed dot product", "heading": "USDOT (indexed)", "para": "Unsigned by signed integer indexed dot product. \n\nThe unsigned by signed integer indexed dot product instruction computes the  dot product of a group of four unsigned 8-bit integer values held in each  32-bit element of the first source vector multiplied by a group of four signed  8-bit integer values in an indexed 32-bit element of the second source vector,  and then destructively adds the widened dot product to the corresponding  32-bit element of the destination vector. \n\nThe groups within the second source vector are specified using an immediate  index which selects the same group position within each 128-bit vector  segment. The index range is from 0 to 3. This instruction is unpredicated. \n\nID_AA64ZFR0_EL1.I8MM indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the immediate index of a quadtuplet of four 8-bit elements within each 128-bit vector segment, in the range 0 to 3, encoded in the \"i2\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["USDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]"]}, {"id": 1004, "asmtemplate": "SEL     <Zd>.<T>, <Pg>, <Zn>.<T>, <Zm>.<T>", "brief": "Conditionally select elements from two vectors", "heading": "SEL (vectors)", "para": "Conditionally select elements from two vectors. \n\nRead active elements from the first source vector and inactive elements from  the second source vector and place in the corresponding elements of the  destination vector. \n\nThis instruction is used by the alias MOV (vector, predicated).", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["SEL     <Zd>.<T>, <Pg>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 570, "asmtemplate": "ANDS<Pd>.B, <Pg>/Z, <Pn>.B, <Pn>.B", "brief": "Move predicates (zeroing), setting the condition flags", "heading": "MOVS (predicated)", "para": "Move predicates (zeroing), setting the condition flags. \n\nRead active elements from the source predicate and place in the corresponding  elements of the destination predicate. Inactive elements in the destination  predicate register are set to zero. Sets the First (N), None (Z), !Last (C)  condition flags based on the predicate result, and the V flag to zero. \n\nThis is an alias of AND, ANDS (predicates). This means:  \n* The encodings in this description are named to match the encodings of AND, \n  ANDS (predicates). \n* The description of AND, ANDS (predicates) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["MOVS    <Pd>.B, <Pg>/Z, <Pn>.B"]}, {"id": 442, "asmtemplate": "FADD    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point add vector (unpredicated)", "heading": "FADD (vectors, unpredicated)", "para": "Floating-point add vector (unpredicated). \n\nAdd all floating-point elements of the second source vector to corresponding  elements of the first source vector and place the results in the corresponding  elements of the destination vector. This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FADD    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 250, "asmtemplate": "CNOT    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Logically invert boolean condition in vector (predicated)", "heading": "CNOT", "para": "Logically invert boolean condition in vector (predicated). \n\nLogically invert the boolean value in each active element of the source  vector, and place the results in the corresponding elements of the destination  vector. Inactive elements in the destination vector register remain  unmodified. \n\nBoolean TRUE is any non-zero value in a source, and one in a result element.  Boolean FALSE is always zero.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["CNOT    <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 538, "asmtemplate": "UMLAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Unsigned Multiply-Add Long (vector, by element)", "heading": "UMLAL, UMLAL2 (by element)", "para": "Unsigned Multiply-Add Long (vector, by element). This instruction multiplies  each vector element in the lower or upper half of the first source SIMD&FP  register by the specified vector element of the second source SIMD&FP register  and accumulates the results with the vector elements of the destination  SIMD&FP register. The destination vector elements are twice as long as the  elements that are multiplied. \n\nThe UMLAL instruction extracts vector elements from the lower half of the  first source register, while the UMLAL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 689, "asmtemplate": "LDAR  <Xt>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Register", "heading": "LDAR", "para": "Load-Acquire Register derives an address from a base register value, loads a  32-bit word or 64-bit doubleword from memory, and writes it to a register. The  instruction also has memory ordering semantics as described in Load-Acquire,  Store-Release. For information about memory accesses, see Load/Store  addressing modes. \n\nFor this instruction, if the destination is WZR/XZR, it is impossible for  software to observe the presence of the acquire semantic other than its effect  on the arrival at endpoints.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAR  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 353, "asmtemplate": "UADDV   <Dd>, <Pg>, <Zn>.<T>", "brief": "Unsigned add reduction to scalar", "heading": "UADDV", "para": "Unsigned add reduction to scalar. \n\nUnsigned add horizontally across all lanes of a vector, and place the result  in the SIMD&FP scalar destination register. Narrow elements are first  zero-extended to 64 bits. Inactive elements in the source vector are treated  as zero.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Dd>": "Is the 64-bit name of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["UADDV   <Dd>, <Pg>, <Zn>.<T>"]}, {"id": 735, "asmtemplate": "ANDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise AND (shifted register), setting flags", "heading": "ANDS (shifted register)", "para": "Bitwise AND (shifted register), setting flags, performs a bitwise AND of a  register value and an optionally-shifted register value, and writes the result  to the destination register. It updates the condition flags based on the  result. \n\nThis instruction is used by the alias TST (shifted register).", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ANDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 545, "asmtemplate": "FJCVTZS  <Wd>, <Dn>", "brief": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero", "heading": "FJCVTZS", "para": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero.  This instruction converts the double-precision floating-point value in the  SIMD&FP source register to a 32-bit signed integer using the Round towards  Zero rounding mode, and writes the result to the general-purpose destination  register. If the result is too large to be represented as a signed 32-bit  integer, then the result is the integer modulo 232, as held in a 32-bit signed  integer. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Dn>": "Is the 64-bit name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FJCVTZS  <Wd>, <Dn>"]}, {"id": 915, "asmtemplate": "SETFFR  ", "brief": "Initialise the first-fault register to all true", "heading": "SETFFR", "para": "Initialise the first-fault register to all true. \n\nInitialise the first-fault register (FFR) to all true prior to a sequence of  first-fault or non-fault loads. This instruction is unpredicated.", "explanations": {}, "encodings": ["SETFFR  "]}, {"id": 289, "asmtemplate": "PSB CSYNC", "brief": "Profiling Synchronization Barrier", "heading": "PSB CSYNC", "para": "Profiling Synchronization Barrier. This instruction is a barrier that ensures  that all existing profiling data for the current PE has been formatted, and  profiling buffer addresses have been translated such that all writes to the  profiling buffer have been initiated. A following DSB instruction completes  when the writes to the profiling buffer have completed. \n\nIf the Statistical Profiling Extension is not implemented, this instruction  executes as a NOP.", "explanations": {}, "encodings": ["PSB CSYNC"]}, {"id": 52, "asmtemplate": "FRSQRTE  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Reciprocal Square Root Estimate", "heading": "FRSQRTE", "para": "Floating-point reciprocal square root estimate (unpredicated). \n\nFind the approximate reciprocal square root of each active floating-point  element of the source vector, and place the results in the corresponding  elements of the destination vector. This instruction is unpredicated.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FRSQRTE <Zd>.<T>, <Zn>.<T>"]}, {"id": 203, "asmtemplate": "LDAPRB  <Wt>, [<Xn|SP> {,#0}]", "brief": "Load-Acquire RCpc Register Byte", "heading": "LDAPRB", "para": "Load-Acquire RCpc Register Byte derives an address from a base register value,  loads a byte from the derived address in memory, zero-extends it and writes it  to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDAPRB  <Wt>, [<Xn|SP> {,#0}]"]}, {"id": 854, "asmtemplate": "LD3W    {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load three-word structures to three vectors (immediate index)", "heading": "LD3W (scalar plus immediate)", "para": "Contiguous load three-word structures to three vectors (immediate index). \n\nContiguous load three-word structures, each to the same element number in  three vector registers from the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 3 in the range -24 to 21  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive words in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 293, "asmtemplate": "CLASTA  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>", "brief": "Conditionally extract element after last to general-purpose register", "heading": "CLASTA (scalar)", "para": "Conditionally extract element after last to general-purpose register. \n\nFrom the source vector register extract the element after the last active  element, or if the last active element is the final element extract element  zero, and then zero-extend that element to destructively place in the  destination and first source general-purpose register. If there are no active  elements then destructively zero-extend the least significant element-size  bits of the destination and first source general-purpose register.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<R><dn>": "Is the number [0-30] of the source and destination general-purpose register or the name ZR (31), encoded in the \"Rdn\" field.", "<Zm>": "Is the name of the source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["CLASTA  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>"]}, {"id": 17, "asmtemplate": "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load Register Halfword (immediate)", "heading": "LDRH (immediate)", "para": "Load Register Halfword (immediate) loads a halfword from memory, zero-extends  it, and writes the result to a register. The address that is used for the load  is calculated from a base register and an immediate offset. For information  about memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/2.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as "}, "encodings": ["LDRH  <Wt>, [<Xn|SP>], #<simm>", "LDRH  <Wt>, [<Xn|SP>, #<simm>]!", "LDRH  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 644, "asmtemplate": "FCVTPS  <Xd>, <Dn>", "brief": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar)", "heading": "FCVTPS (scalar)", "para": "Floating-point Convert to Signed integer, rounding toward Plus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP  source register to a 32-bit or 64-bit signed integer using the Round towards  Plus Infinity rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "": "FP source register, encoded in the \"Rn\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FCVTPS  <Wd>, <Hn>"]}, {"id": 1049, "asmtemplate": "LD1  {<Vt>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Load one single-element structure to one lane of one register", "heading": "LD1 (single structure)", "para": "Load one single-element structure to one lane of one register. This  instruction loads a single-element structure from memory and writes the result  to the specified lane of the SIMD&FP register without affecting the other bits  of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "": "\".", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["LD1  { <Vt>.B }[<index>], [<Xn|SP>]", "LD1  { <Vt>.B }[<index>], [<Xn|SP>], #1"]}, {"id": 472, "asmtemplate": "STR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Store predicate register", "heading": "STR (predicate)", "para": "Store predicate register. \n\nStore a predicate register to a memory address generated by a 64-bit scalar  base, plus an immediate offset in the range -256 to 255 which is multiplied by  the current predicate register size in bytes. This instruction is  unpredicated. \n\nThe store is performed as a stream of bytes containing 8 consecutive predicate  bits in ascending element order, without any endian conversion.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pt>": "Is the name of the scalable predicate transfer register, encoded in the \"Pt\" field.", "<imm>": "Is the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."}, "encodings": ["STR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 912, "asmtemplate": "LD1ROD  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate four doublewords (immediate index)", "heading": "LD1ROD (scalar plus immediate)", "para": "Contiguous load and replicate four doublewords (immediate index). \n\nLoad four contiguous doublewords to elements of a 256-bit (octaword) vector  from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 32 in the range -256 to +224 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first four predicate elements are used and higher numbered predicate  elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 706, "asmtemplate": "AXFLAG", "brief": "Convert floating-point condition flags from Arm to external format", "heading": "AXFLAG", "para": "Convert floating-point condition flags from Arm to external format. This  instruction converts the state of the PSTATE.{N,Z,C,V} flags from a form  representing the result of an Arm floating-point scalar compare instruction to  an alternative representation required by some software.", "explanations": {}, "encodings": ["AXFLAG"]}, {"id": 481, "asmtemplate": "STNT1B  {<Zt>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store non-temporal bytes from vector (immediate index)", "heading": "STNT1B (scalar plus immediate)", "para": "Contiguous store non-temporal bytes from vector (immediate index). \n\nContiguous store non-temporal of bytes from elements of a vector register to  the memory address generated by a 64-bit scalar base and immediate index in  the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STNT1B  { <Zt>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 938, "asmtemplate": "BFM<Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)", "brief": "Bitfield Insert", "heading": "BFI", "para": "Bitfield Insert copies a bitfield of <width> bits from the least significant  bits of the source register to bit position <lsb> of the destination register,  leaving the other destination bits unchanged. \n\nThis is an alias of BFM. This means:  \n* The encodings in this description are named to match the encodings of BFM. \n* The description of BFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-"}, "encodings": ["BFI  <Wd>, <Wn>, #<lsb>, #<width>"]}, {"id": 670, "asmtemplate": "UMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Unsigned maximum vectors (predicated)", "heading": "UMAX (vectors)", "para": "Unsigned maximum vectors (predicated). \n\nDetermine the unsigned maximum of active elements of the second source vector  and corresponding elements of the first source vector and destructively place  the results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 493, "asmtemplate": "FEXPA   <Zd>.<T>, <Zn>.<T>", "brief": "Floating-point exponential accelerator", "heading": "FEXPA", "para": "Floating-point exponential accelerator. \n\nThe FEXPA instruction accelerates the polynomial series calculation of the  exp(x) function. \n\nThe double-precision variant copies the low 52 bits of an entry from a  hard-wired table of 64-bit coefficients, indexed by the low 6 bits of each  element of the source vector, and prepends to that the next 11 bits of the  source element (src<16:6>), setting the sign bit to zero. \n\nThe single-precision variant copies the low 23 bits of an entry from  hard-wired table of 32-bit coefficients, indexed by the low 6 bits of each  element of the source vector, and prepends to that the next 8 bits of the  source element (src<13:6>), setting the sign bit to zero. \n\nThe half-precision variant copies the low 10 bits of an entry from hard-wired  table of 16-bit coefficients, indexed by the low 5 bits of each element of the  source vector, and prepends to that the next 5 bits of the source element \n(src<9:5>), setting the sign bit to zero. \n\nA coefficient table entry with index m holds the floating-point value 2(m/64),  or for the half-precision variant 2(m/32). This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FEXPA   <Zd>.<T>, <Zn>.<T>"]}, {"id": 948, "asmtemplate": "INS  <Vd>.<Ts>[<index>], <R><n>", "brief": "Insert vector element from general-purpose register", "heading": "INS (general)", "para": "Insert vector element from general-purpose register. This instruction copies  the contents of the source general-purpose register to the specified vector  element in the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP  register without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias MOV (from general).", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD", "<Ts><index><R><n>": "Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."}, "encodings": ["INS  <Vd>.<Ts>[<index>], <R><n>"]}, {"id": 127, "asmtemplate": "SETF16  <Wn>", "brief": "Evaluation of 8 or 16 bit flag values", "heading": "SETF8, SETF16", "para": "Set the PSTATE.NZV flags based on the value in the specified general-purpose  register. SETF8 treats the value as an 8 bit value, and SETF16 treats the  value as an 16 bit value. \n\nThe PSTATE.C flag is not affected by these instructions.", "explanations": {"<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field."}, "encodings": ["SETF8  <Wn>"]}, {"id": 928, "asmtemplate": "LDURH  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Halfword (unscaled)", "heading": "LDURH", "para": "Load Register Halfword (unscaled) calculates an address from a base register  and an immediate offset, loads a halfword from memory, zero-extends it, and  writes it to a register. For information about memory accesses, see Load/Store  addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDURH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 454, "asmtemplate": "LD4W    {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load four-word structures to four vectors (immediate index)", "heading": "LD4W (scalar plus immediate)", "para": "Contiguous load four-word structures to four vectors (immediate index). \n\nContiguous load four-word structures, each to the same element number in four  vector registers from the memory address generated by a 64-bit scalar base and  an immediate index which is a multiple of 4 in the range -32 to 28 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive words in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 763, "asmtemplate": "BFDOT   <Zda>.S, <Zn>.H, <Zm>.H[<imm>]", "brief": "BFloat16 floating-point indexed dot product", "heading": "BFDOT (indexed)", "para": "BFloat16 floating-point indexed dot product. \n\nThe BFloat16 floating-point (BF16) indexed dot product instruction computes  the dot product of a pair of BF16 values held in each 32-bit element of the  first source vector multiplied by a pair of BF16 values in an indexed 32-bit  element of the second source vector, and then destructively adds the  single-precision dot product to the corresponding single-precision element of  the destination vector. \n\nThe BF16 pairs within the second source vector are specified using an  immediate index which selects the same BF16 pair position within each 128-bit  vector segment. The index range is from 0 to 3. This instruction is  unpredicated. \n\nAll floating-point calculations performed by this instruction are performed  with the following behaviors, irrespective of the value in FPCR:  \n* Uses the non-IEEE 754 Round-to-Odd mode, which forces bit 0 of an inexact  result to 1, and rounds an overflow to an appropriately signed Infinity.  \n* The cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC and IOC) are not  modified.  \n* Trapped floating-point exceptions are disabled, as if the FPCR trap enable  bits (IDE, IXE, UFE, OFE, DZE and IOE) are all zero.  \n* Denormalized inputs and results are flushed to zero, as if FPCR.FZ == 1.  \n* Only the Default NaN is generated, as if FPCR.DN == 1. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the immediate index, in the range 0 to 3, encoded in the \"i2\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["BFDOT   <Zda>.S, <Zn>.H, <Zm>.H[<imm>]"]}, {"id": 791, "asmtemplate": "BFCVTNT <Zd>.H, <Pg>/M, <Zn>.S", "brief": "Floating-point down convert and narrow to BFloat16 (top, predicated)", "heading": "BFCVTNT", "para": "Floating-point down convert and narrow to BFloat16 (top, predicated). \n\nConvert active 32-bit single-precision elements from the source vector to  BFloat16 format, and place the results in the odd-numbered 16-bit elements of  the destination vector, leaving the even-numbered elements unchanged. Inactive  elements in the destination vector register remain unmodified. \n\nUnlike the BFloat16 matrix multiplication and dot product instructions, this  instruction honors all of the FPCR bits that apply to single-precision  arithmetic. It can also generate a floating-point exception that causes  cumulative exception bits in the FPSR to be set, or a synchronous exception to  be taken, depending on the enable bits in the FPCR. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["BFCVTNT <Zd>.H, <Pg>/M, <Zn>.S"]}, {"id": 408, "asmtemplate": "SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D", "brief": "SHA512 Schedule Update 1", "heading": "SHA512SU1", "para": "SHA512 Schedule Update 1 takes the values from the three source SIMD&FP  registers and produces a 128-bit output value that combines the gamma1  functions of two iterations of the SHA512 schedule update that are performed  after the first 16 iterations within a block. It returns this value to the  destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA512 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SHA512SU1  <Vd>.2D, <Vn>.2D, <Vm>.2D"]}, {"id": 301, "asmtemplate": "ST2B    {<Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store two-byte structures from two vectors (immediate index)", "heading": "ST2B (scalar plus immediate)", "para": "Contiguous store two-byte structures from two vectors (immediate index). \n\nContiguous store two-byte structures, each from the same element number in two  vector registers to the memory address generated by a 64-bit scalar base and  an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive bytes in memory which  make up each structure. Inactive structures are not written to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST2B    { <Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1203, "asmtemplate": "LSLR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Reversed logical shift left by vector (predicated)", "heading": "LSLR", "para": "Reversed logical shift left by vector (predicated). \n\nReversed shift left active elements of the second source vector by  corresponding elements of the first source vector and destructively place the  results in the corresponding elements of the first source vector. The shift  amount operand is a vector of unsigned elements in which all bits are  significant, and not used modulo the element size. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSLR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1204, "asmtemplate": "INCW    <Zdn>.S{, <pattern>{, MUL #<imm>}}", "brief": "Increment vector by multiple of predicate constraint element count", "heading": "INCD, INCH, INCW (vector)", "para": "Increment vector by multiple of predicate constraint element count. \n\nDetermines the number of active elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 3 classes: Doubleword , Halfword and Word", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["INCD    <Zdn>.D{, <pattern>{, MUL #<imm>}}", "INCH    <Zdn>.H{, <pattern>{, MUL #<imm>}}", "INCW    <Zdn>.S{, <pattern>{, MUL #<imm>}}"]}, {"id": 836, "asmtemplate": "XTN{2}<Vd>.<Tb>, <Vn>.<Ta>", "brief": "Extract Narrow", "heading": "XTN, XTN2", "para": "Extract Narrow. This instruction reads each vector element from the source  SIMD&FP register, narrows each value to half the original width, places the  result into a vector, and writes the vector to the lower or upper half of the  destination SIMD&FP register. The destination vector elements are half as long  as the source vector elements. \n\nThe XTN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the XTN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["XTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"]}, {"id": 992, "asmtemplate": "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Rounding Shift Left (register)", "heading": "URSHL", "para": "Unsigned Rounding Shift Left (register). This instruction takes each element  in the vector of the first source SIMD&FP register, shifts the vector element  by a value from the least significant byte of the corresponding element of the  second source SIMD&FP register, places the results in a vector, and writes the  vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift  value is negative, it is a rounding right shift. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["URSHL  <V><d>, <V><n>, <V><m>", "URSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 448, "asmtemplate": "FMAXNMV  <V><d>, <Vn>.<T>", "brief": "Floating-point Maximum Number across Vector", "heading": "FMAXNMV", "para": "Floating-point Maximum Number across Vector. This instruction compares all the  vector elements in the source SIMD&FP register, and writes the largest of the  values as a scalar to the destination SIMD&FP register. All the values in this  instruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result of the comparison  is the numerical value, otherwise the result is identical to FMAX (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V>": "For the half-precision variant: is the destination width specifier, H.", "<V><d>": "Is the number of the SIMD", "<Vn>": "Is the name of the SIMD"}, "encodings": ["FMAXNMV  <V><d>, <Vn>.<T>", "FMAXNMV  <V><d>, <Vn>.<T>"]}, {"id": 984, "asmtemplate": "STNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", "brief": "Store Pair of SIMD&FP registers, with Non-temporal hint", "heading": "STNP (SIMD&FP)", "para": "Store Pair of SIMD&FP registers, with Non-temporal hint. This instruction  stores a pair of SIMD&FP registers to memory, issuing a hint to the memory  system that the access is non-temporal. The address used for the store is  calculated from an address from a base register value and an immediate offset.  For information about non-temporal pair instructions, see Load/Store SIMD and  Floating-point Non-temporal pair. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "/16.", "<St1>": "Is the 32-bit name of the first SIMD", "<Dt1>": "Is the 64-bit name of the first SIMD", "<Qt1>": "Is the 128-bit name of the first SIMD", "<imm>": "For the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as ", "<St2>": "Is the 32-bit name of the second SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Dt2>": "Is the 64-bit name of the second SIMD", "<Qt2>": "Is the 128-bit name of the second SIMD"}, "encodings": ["STNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 169, "asmtemplate": "XAFLAG", "brief": "Convert floating-point condition flags from external format to Arm format", "heading": "XAFLAG", "para": "Convert floating-point condition flags from external format to Arm format.  This instruction converts the state of the PSTATE.{N,Z,C,V} flags from an  alternative representation required by some software to a form representing  the result of an Arm floating-point scalar compare instruction.", "explanations": {}, "encodings": ["XAFLAG"]}, {"id": 305, "asmtemplate": "SQDECP  <Xdn>, <Pm>.<T>", "brief": "Signed saturating decrement scalar by count of true predicate elements", "heading": "SQDECP (scalar)", "para": "Signed saturating decrement scalar by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to decrement the scalar destination. The result is saturated to the  source general-purpose register's signed integer range. A 32-bit saturated  result is then sign-extended to 64 bits. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<T><Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["SQDECP  <Xdn>, <Pm>.<T>, <Wdn>", "SQDECP  <Xdn>, <Pm>.<T>"]}, {"id": 698, "asmtemplate": "RSHRN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Rounding Shift Right Narrow (immediate)", "heading": "RSHRN, RSHRN2", "para": "Rounding Shift Right Narrow (immediate). This instruction reads each unsigned  integer value from the vector in the source SIMD&FP register, right shifts  each result by an immediate value, writes the final result to a vector, and  writes the vector to the lower or upper half of the destination SIMD&FP  register. The destination vector elements are half as long as the source  vector elements. The results are rounded. For truncated results, see SHRN. \n\nThe RSHRN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the RSHRN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Tb><Vn>": "Is the name of the SIMD", "2<Vd>": "Is the name of the SIMD"}, "encodings": ["RSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 1017, "asmtemplate": "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed saturating Subtract", "heading": "SQSUB", "para": "Signed saturating Subtract. This instruction subtracts the element values of  the second source SIMD&FP register from the corresponding element values of  the first source SIMD&FP register, places the results into a vector, and  writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQSUB  <V><d>, <V><n>, <V><m>", "SQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1201, "asmtemplate": "SHA1C  <Qd>, <Sn>, <Vm>.4S", "brief": "SHA1 hash update (choose)", "heading": "SHA1C", "para": "SHA1 hash update (choose).", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the third SIMD", "<Sn>": "Is the 32-bit name of the second SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA1C  <Qd>, <Sn>, <Vm>.4S"]}, {"id": 523, "asmtemplate": "LDCLRLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic bit clear on byte in memory", "heading": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB", "para": "Atomic bit clear on byte in memory atomically loads an 8-bit byte from memory,  performs a bitwise AND with the complement of the value held in a register on  it, and stores the result back to memory. The value initially loaded from  memory is returned in the destination register.  \n* If the destination register is not WZR, LDCLRAB and LDCLRALB load from \n  memory with acquire semantics. \n* LDCLRLB and LDCLRALB store to memory with release semantics. \n* LDCLRB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STCLRB, STCLRLB.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDCLRAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 519, "asmtemplate": "RBIT    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Reverse bits (predicated)", "heading": "RBIT", "para": "Reverse Bits reverses the bit order in a register.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["RBIT  <Wd>, <Wn>"]}, {"id": 914, "asmtemplate": "SMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Signed Multiply Long (vector, by element)", "heading": "SMULL, SMULL2 (by element)", "para": "Signed Multiply Long (vector, by element). This instruction multiplies each  vector element in the lower or upper half of the first source SIMD&FP register  by the specified vector element of the second source SIMD&FP register, places  the result in a vector, and writes the vector to the destination SIMD&FP  register. The destination vector elements are twice as long as the elements  that are multiplied. \n\nThe SMULL instruction extracts vector elements from the lower half of the  first source register, while the SMULL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 603, "asmtemplate": "LDEORLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic exclusive OR on byte in memory", "heading": "LDEORB, LDEORAB, LDEORALB, LDEORLB", "para": "Atomic exclusive OR on byte in memory atomically loads an 8-bit byte from  memory, performs an exclusive OR with the value held in a register on it, and  stores the result back to memory. The value initially loaded from memory is  returned in the destination register.  \n* If the destination register is not WZR, LDEORAB and LDEORALB load from \n  memory with acquire semantics. \n* LDEORLB and LDEORALB store to memory with release semantics. \n* LDEORB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STEORB, STEORLB.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDEORAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 668, "asmtemplate": "SQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment vector by multiple of 32-bit predicate constraint element count", "heading": "SQINCW (vector)", "para": "Signed saturating increment vector by multiple of 32-bit predicate constraint  element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. The  results are saturated to the 32-bit signed integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}"]}, {"id": 265, "asmtemplate": "CMGT  <Vd>.<T>, <Vn>.<T>, #0", "brief": "Compare signed Greater than zero (vector)", "heading": "CMGT (zero)", "para": "Compare signed Greater than zero (vector). This instruction reads each vector  element in the source SIMD&FP register and if the signed integer value is  greater than zero sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["CMGT  <V><d>, <V><n>, #0", "CMGT  <Vd>.<T>, <Vn>.<T>, #0"]}, {"id": 680, "asmtemplate": "ERETAB", "brief": "Exception Return, with pointer authentication", "heading": "ERETAA, ERETAB", "para": "Exception Return, with pointer authentication. This instruction authenticates  the address in ELR, using SP as the modifier and the specified key, the PE  restores PSTATE from the SPSR for the current Exception level, and branches to  the authenticated address. \n\nKey A is used for ERETAA, and key B is used for ERETAB. \n\nIf the authentication passes, the PE continues execution at the target of the  branch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to ELR. \n\nThe PE checks the SPSR for the current Exception level for an illegal return  event. See Illegal return events from AArch64 state. \n\nERETAA and ERETAB are undefined at EL0.", "explanations": {}, "encodings": ["ERETAA"]}, {"id": 82, "asmtemplate": "LD2D    {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load two-doubleword structures to two vectors (immediate index)", "heading": "LD2D (scalar plus immediate)", "para": "Contiguous load two-doubleword structures to two vectors (immediate index). \n\nContiguous load two-doubleword structures, each to the same element number in  two vector registers from the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive doublewords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD2D    { <Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1002, "asmtemplate": "EOR  <Xd|SP>, <Xn>, #<imm>", "brief": "Bitwise Exclusive OR (immediate)", "heading": "EOR (immediate)", "para": "Bitwise exclusive OR with immediate (unpredicated). \n\nBitwise exclusive OR an immediate with each 64-bit element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate is a 64-bit value consisting of a single run  of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction  is unpredicated. \n\nThis instruction is used by the pseudo-instruction EON.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>": "For the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\".", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field."}, "encodings": ["EOR     <Zdn>.<T>, <Zdn>.<T>, #<const>"]}, {"id": 275, "asmtemplate": "BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise bit Clear (vector, register)", "heading": "BIC (vector, register)", "para": "Bitwise bit Clear (vector, register). This instruction performs a bitwise AND  between the first source SIMD&FP register and the complement of the second  source SIMD&FP register, and writes the result to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["BIC  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 993, "asmtemplate": "BICS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise Bit Clear (shifted register), setting flags", "heading": "BICS (shifted register)", "para": "Bitwise Bit Clear (shifted register), setting flags, performs a bitwise AND of  a register value and the complement of an optionally-shifted register value,  and writes the result to the destination register. It updates the condition  flags based on the result.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["BICS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 849, "asmtemplate": "UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unzip vectors (secondary)", "heading": "UZP2", "para": "Unzip vectors (secondary). This instruction reads corresponding odd-numbered  vector elements from the two source SIMD&FP registers, places the result from  the first source register into consecutive elements in the lower half of a  vector, and the result from the second source register into consecutive  elements in the upper half of a vector, and writes the vector to the  destination SIMD&FP register. \n\nThis instruction can be used with UZP1 to de-interleave two vectors. \n\nThe following figure shows an example of the operation of UZP1 and UZP2 with  the arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UZP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1107, "asmtemplate": "LDUMINLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic unsigned minimum on halfword in memory", "heading": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH", "para": "Atomic unsigned minimum on halfword in memory atomically loads a 16-bit  halfword from memory, compares it against the value held in a register, and  stores the smaller value back to memory, treating the values as unsigned  numbers. The value initially loaded from memory is returned in the destination  register.  \n* If the destination register is not WZR, LDUMINAH and LDUMINALH load from \n  memory with acquire semantics. \n* LDUMINLH and LDUMINALH store to memory with release semantics. \n* LDUMINH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMINH, STUMINLH.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDUMINAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 129, "asmtemplate": "LD1RB   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast unsigned byte to vector", "heading": "LD1RB", "para": "Load and broadcast unsigned byte to vector. \n\nLoad a single unsigned byte from a memory address generated by a 64-bit scalar  base address plus an immediate offset which is in the range 0 to 63. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort. \n\nIt has encodings from 4 classes: 8-bit element , 16-bit element , 32-bit  element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 63, defaulting to 0, encoded in the \"imm6\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1RB   { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 581, "asmtemplate": "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Unsigned Rounding Shift Right (immediate)", "heading": "URSHR", "para": "Unsigned Rounding Shift Right (immediate). This instruction reads each vector  element in the source SIMD&FP register, right shifts each result by an  immediate value, writes the final result to a vector, and writes the vector to  the destination SIMD&FP register. All the values in this instruction are  unsigned integer values. The results are rounded. For truncated results, see  USHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["URSHR  <V><d>, <V><n>, #<shift>", "URSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 1079, "asmtemplate": "LDNT1B  {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load non-temporal bytes to vector (scalar index)", "heading": "LDNT1B (scalar plus scalar)", "para": "Contiguous load non-temporal bytes to vector (scalar index). \n\nContiguous load non-temporal of bytes to elements of a vector register from  the memory address generated by a 64-bit scalar base and scalar index which is  added to the base address. After each element access the index value is  incremented, but the index register is not updated. Inactive elements will not  not cause a read from Device memory or signal a fault, and are set to zero in  the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LDNT1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 760, "asmtemplate": "FNMADD  <Dd>, <Dn>, <Dm>, <Da>", "brief": "Floating-point Negated fused Multiply-Add (scalar)", "heading": "FNMADD", "para": "Floating-point Negated fused Multiply-Add (scalar). This instruction  multiplies the values of the first two SIMD&FP source registers, negates the  product, subtracts the value of the third SIMD&FP source register, and writes  the result to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register holding the addend, encoded in the \"Ra\" field.", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Da>": "Is the 64-bit name of the third SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Ha>": "Is the 16-bit name of the third SIMD", "<Sa>": "Is the 32-bit name of the third SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FNMADD  <Hd>, <Hn>, <Hm>, <Ha>"]}, {"id": 724, "asmtemplate": "ADDS XZR, <Xn|SP>, <R><m>{, <extend>{#<amount>}}", "brief": "Compare Negative (extended register)", "heading": "CMN (extended register)", "para": "Compare Negative (extended register) adds a register value and a sign or  zero-extended register value, followed by an optional left shift amount. The  argument that is extended from the <Rm> register can be a byte, halfword,  word, or doubleword. It updates the condition flags based on the result, and  discards the result. \n\nThis is an alias of ADDS (extended register). This means:  \n* The encodings in this description are named to match the encodings of ADDS \n  (extended register). \n* The description of ADDS (extended register) gives the operational pseudocode \n  for this instruction.", "explanations": {"": " is present but not LSL.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn|WSP>": "Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R><m>": "Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<extend><extend><amount>": "Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when "}, "encodings": ["CMN  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"]}, {"id": 628, "asmtemplate": "LD3  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load multiple 3-element structures to three registers", "heading": "LD3 (multiple structures)", "para": "Load multiple 3-element structures to three registers. This instruction loads  multiple 3-element structures from memory and writes the result to the three  SIMD&FP registers, with de-interleaving. \n\nThe following figure shows an example of the operation of de-interleaving of a  LD3.16 (multiple 3-element structures) instruction:. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<T><Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", "LD3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 443, "asmtemplate": "FRECPS  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point reciprocal step (unpredicated)", "heading": "FRECPS", "para": "Floating-point Reciprocal Step. This instruction multiplies the corresponding  floating-point values in the vectors of the two source SIMD&FP registers,  subtracts each of the products from 2.0, places the resulting floating-point  values in a vector, and writes the vector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FRECPS  <Hd>, <Hn>, <Hm>", "FRECPS  <V><d>, <V><n>, <V><m>", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FRECPS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1053, "asmtemplate": "ORR<Pd>.B, <Pn>/Z, <Pn>.B, <Pn>.B", "brief": "Move predicate (unpredicated)", "heading": "MOV (predicate, unpredicated)", "para": "Move predicate (unpredicated). \n\nRead all elements from the source predicate and place in the destination  predicate. This instruction is unpredicated. Does not set the condition flags. \n\nThis is an alias of ORR, ORRS (predicates). This means:  \n* The encodings in this description are named to match the encodings of ORR, \n  ORRS (predicates). \n* The description of ORR, ORRS (predicates) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["MOV     <Pd>.B, <Pn>.B"]}, {"id": 69, "asmtemplate": "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Absolute Compare Greater than or Equal (vector)", "heading": "FACGE", "para": "Floating-point Absolute Compare Greater than or Equal (vector). This  instruction compares the absolute value of each floating-point value in the  first source SIMD&FP register with the absolute value of the corresponding  floating-point value in the second source SIMD&FP register and if the first  value is greater than or equal to the second value sets every bit of the  corresponding vector element in the destination SIMD&FP register to one,  otherwise sets every bit of the corresponding vector element in the  destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["FACGE  <Hd>, <Hn>, <Hm>", "FACGE  <V><d>, <V><n>, <V><m>", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FACGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1200, "asmtemplate": "AUTDZA  <Xd>", "brief": "Authenticate Data address, using key A", "heading": "AUTDA, AUTDZA", "para": "Authenticate Data address, using key A. This instruction authenticates a data  address, using a modifier and key A. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTDA. \n* The value zero, for AUTDZA.  If the authentication passes, the upper bits of the address are restored to  enable subsequent use of the address. If the authentication fails, the upper  bits are corrupted and any subsequent use of the address results in a  Translation fault.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["AUTDA  <Xd>, <Xn|SP>"]}, {"id": 897, "asmtemplate": "ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Arithmetic shift right by vector (predicated)", "heading": "ASR (vectors)", "para": "Arithmetic shift right by vector (predicated). \n\nShift right, preserving the sign bit, active elements of the first source  vector by corresponding elements of the second source vector and destructively  place the results in the corresponding elements of the first source vector.  The shift amount operand is a vector of unsigned elements in which all bits  are significant, and not used modulo the element size. Inactive elements in  the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 54, "asmtemplate": "LD1RQD  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate two doublewords (immediate index)", "heading": "LD1RQD (scalar plus immediate)", "para": "Contiguous load and replicate two doublewords (immediate index). \n\nLoad two contiguous doublewords to elements of a short, 128-bit (quadword)  vector from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 16 in the range -128 to +112 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first two predicate elements are used and  higher numbered predicate elements are ignored.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 997, "asmtemplate": "CASLH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", "brief": "Compare and Swap halfword in memory", "heading": "CASH, CASAH, CASALH, CASLH", "para": "Compare and Swap halfword in memory reads a 16-bit halfword from memory, and  compares it against the value held in a first register. If the comparison is  equal, the value in a second register is written to memory. If the write is  performed, the read and write occur atomically such that no other modification  of the memory location can take place between the read and write.  \n* CASAH and CASALH load from memory with acquire semantics. \n* CASLH and CASALH store to memory with release semantics. \n* CAS has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors  associated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the register which is  compared and loaded, that is <Ws>, is restored to the values held in the  register before the instruction was executed.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field."}, "encodings": ["CASAH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 677, "asmtemplate": "LDNF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault signed halfwords to vector (immediate index)", "heading": "LDNF1SH", "para": "Contiguous load non-fault signed halfwords to vector (immediate index). \n\nContiguous load with non-faulting behavior of signed halfwords to elements of  a vector register from the memory address generated by a 64-bit scalar base  and immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDNF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 661, "asmtemplate": "SQDMLSL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed saturating Doubling Multiply-Subtract Long", "heading": "SQDMLSL, SQDMLSL2 (vector)", "para": "Signed saturating Doubling Multiply-Subtract Long. This instruction multiplies  corresponding signed integer values in the lower or upper half of the vectors  of the two source SIMD&FP registers, doubles the results, and subtracts the  final results from the vector elements of the destination SIMD&FP register.  The destination vector elements are twice as long as the elements that are  multiplied. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLSL instruction extracts each source vector from the lower half of  each source register, while the SQDMLSL2 instruction extracts each source  vector from the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<m>": "Is the number of the second SIMD", "2<Vd>": "Is the name of the SIMD", "<Va><d>": "Is the number of the SIMD", "<Vb><n>": "Is the number of the first SIMD"}, "encodings": ["SQDMLSL  <Va><d>, <Vb><n>, <Vb><m>", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 1024, "asmtemplate": "SHA512H2  <Qd>, <Qn>, <Vm>.2D", "brief": "SHA512 Hash update part 2", "heading": "SHA512H2", "para": "SHA512 Hash update part 2 takes the values from the three 128-bit source  SIMD&FP registers and produces a 128-bit output value that combines the sigma0  and majority functions of two iterations of the SHA512 computation. It returns  this value to the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA512 is implemented.", "explanations": {"<Qn>": "Is the 128-bit name of the second SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the third SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA512H2  <Qd>, <Qn>, <Vm>.2D"]}, {"id": 501, "asmtemplate": "UMAXV   <V><d>, <Pg>, <Zn>.<T>", "brief": "Unsigned maximum reduction to scalar", "heading": "UMAXV", "para": "Unsigned Maximum across Vector. This instruction compares all the vector  elements in the source SIMD&FP register, and writes the largest of the values  as a scalar to the destination SIMD&FP register. All the values in this  instruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD"}, "encodings": ["UMAXV  <V><d>, <Vn>.<T>"]}, {"id": 906, "asmtemplate": "STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", "brief": "Store-Release Exclusive Register Byte", "heading": "STLXRB", "para": "Store-Release Exclusive Register Byte stores a byte from a 32-bit register to  memory if the PE has exclusive access to the memory address, and returns a  status value of 0 if the store was successful, or of 1 if no store was  performed. See Synchronization and semaphores. The memory access is atomic.  The instruction also has memory ordering semantics as described in  Load-Acquire, Store-Release. For information about memory accesses see  Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:"}, "encodings": ["STLXRB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 569, "asmtemplate": "LDSETL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic bit set on word or doubleword in memory, without return", "heading": "STSET, STSETL", "para": "Atomic bit set on word or doubleword in memory, without return, atomically  loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise OR  with the value held in a register on it, and stores the result back to memory.  \n* STSET does not have release semantics. \n* STSETL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSET, LDSETA, LDSETAL, LDSETL. This means:  \n* The encodings in this description are named to match the encodings of LDSET, \n  LDSETA, LDSETAL, LDSETL. \n* The description of LDSET, LDSETA, LDSETAL, LDSETL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSET  <Ws>, [<Xn|SP>]"]}, {"id": 789, "asmtemplate": "UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Minimum Pairwise", "heading": "UMINP", "para": "Unsigned Minimum Pairwise. This instruction creates a vector by concatenating  the vector elements of the first source SIMD&FP register after the vector  elements of the second source SIMD&FP register, reads each pair of adjacent  vector elements in the two source SIMD&FP registers, writes the smallest of  each pair of unsigned integer values into a vector, and writes the vector to  the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 254, "asmtemplate": "ORR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise OR (shifted register)", "heading": "ORR (shifted register)", "para": "Bitwise OR (shifted register) performs a bitwise (inclusive) OR of a register  value and an optionally-shifted register value, and writes the result to the  destination register. \n\nThis instruction is used by the alias MOV (register).", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ORR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 599, "asmtemplate": "MOVPRFX <Zd>, <Zn>", "brief": "Move prefix (unpredicated)", "heading": "MOVPRFX (unpredicated)", "para": "Move prefix (unpredicated). \n\nThe unpredicated MOVPRFX instruction is a hint to hardware that the  instruction may be combined with the destructive instruction which follows it  in program order to create a single constructive operation. Since it is a hint  it is also permitted to be implemented as a discrete vector copy, and the  result of executing the pair of instructions with or without combining is  identical. The choice of combined versus discrete operation may vary  dynamically. \n\n \n\nAlthough the operation of the instruction is defined as a simple unpredicated  vector copy, it is required that the prefixed instruction at PC+4 must be an  SVE destructive binary or ternary instruction encoding, or a unary operation  with merging predication, but excluding other MOVPRFX instructions. The  prefixed instruction must specify the same destination vector as the MOVPRFX  instruction. The prefixed instruction must not use the destination register in  any other operand position, even if they have different names but refer to the  same architectural register state. Any other use is UNPREDICTABLE.", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOVPRFX <Zd>, <Zn>"]}, {"id": 248, "asmtemplate": "LD1H    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load unsigned halfwords to vector (scalar index)", "heading": "LD1H (scalar plus scalar)", "para": "Contiguous load unsigned halfwords to vector (scalar index). \n\nContiguous load of unsigned halfwords to elements of a vector register from  the memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 2 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1H    { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 171, "asmtemplate": "LSL     <Zd>.<T>, <Zn>.<T>, <Zm>.D", "brief": "Logical shift left by 64-bit wide elements (unpredicated)", "heading": "LSL (wide elements, unpredicated)", "para": "Logical shift left by 64-bit wide elements (unpredicated). \n\nShift left all elements of the first source vector by corresponding  overlapping 64-bit elements of the second source vector and place the first in  the corresponding elements of the destination vector. The shift amount is a  vector of unsigned 64-bit doubleword elements in which all bits are  significant, and not used modulo the destination element size. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSL     <Zd>.<T>, <Zn>.<T>, <Zm>.D"]}, {"id": 235, "asmtemplate": "ADC  <Xd>, <Xn>, <Xm>", "brief": "Add with Carry", "heading": "ADC", "para": "Add with Carry adds two register values and the Carry flag value, and writes  the result to the destination register.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["ADC  <Wd>, <Wn>, <Wm>"]}, {"id": 132, "asmtemplate": "LDFF1SB {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault signed bytes to vector (immediate index)", "heading": "LDFF1SB (vector plus immediate)", "para": "Gather load first-fault signed bytes to vector (immediate index). \n\nGather load with first-faulting behavior of signed bytes to active elements of  a vector register from memory addresses generated by a vector base plus  immediate index. The index is in the range 0 to 31. Inactive elements will not  cause a read from Device memory or signal faults, and are set to zero in the  destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LDFF1SB { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 1206, "asmtemplate": "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Signed Shift Right and Accumulate (immediate)", "heading": "SSRA", "para": "Signed Shift Right and Accumulate (immediate). This instruction reads each  vector element in the source SIMD&FP register, right shifts each result by an  immediate value, and accumulates the final results with the vector elements of  the destination SIMD&FP register. All the values in this instruction are  signed integer values. The results are truncated. For rounded results, see  SRSRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SSRA  <V><d>, <V><n>, #<shift>", "SSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 343, "asmtemplate": "LSRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Reversed logical shift right by vector (predicated)", "heading": "LSRR", "para": "Reversed logical shift right by vector (predicated). \n\nReversed shift right, inserting zeroes, active elements of the second source  vector by corresponding elements of the first source vector and destructively  place the results in the corresponding elements of the first source vector.  The shift amount operand is a vector of unsigned elements in which all bits  are significant, and not used modulo the element size. Inactive elements in  the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 9, "asmtemplate": "MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)", "brief": "Move System Register", "heading": "MRS", "para": "Move System Register allows the PE to read an AArch64 System register into a  general-purpose register.", "explanations": {"": "The System register names are defined in ", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<Cn>": "Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<systemreg>": "Is a System register name, encoded in the \"o0:op1:CRn:CRm:op2\".", "<Xt>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rt\" field.", "<op0><op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field."}, "encodings": ["MRS  <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)"]}, {"id": 27, "asmtemplate": "SQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement scalar by multiple of 16-bit predicate constraint element count", "heading": "SQDECH (scalar)", "para": "Signed saturating decrement scalar by multiple of 16-bit predicate constraint  element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECH  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQDECH  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 446, "asmtemplate": "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed saturating Rounding Shift Left (register)", "heading": "SQRSHL", "para": "Signed saturating Rounding Shift Left (register). This instruction takes each  vector element in the first source SIMD&FP register, shifts it by a value from  the least significant byte of the corresponding vector element of the second  source SIMD&FP register, places the results into a vector, and writes the  vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it  is a right shift. The results are rounded. For truncated results, see SQSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQRSHL  <V><d>, <V><n>, <V><m>", "SQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 590, "asmtemplate": "SQINCP  <Zdn>.<T>, <Pm>.<T>", "brief": "Signed saturating increment vector by count of true predicate elements", "heading": "SQINCP (vector)", "para": "Signed saturating increment vector by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to increment all destination vector elements. The results are saturated  to the element signed integer range. \n\nThe predicate size specifier may be omitted in assembler source code, but this  is deprecated and will be prohibited in a future release of the architecture.", "explanations": {"<T><Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["SQINCP  <Zdn>.<T>, <Pm>.<T>"]}, {"id": 283, "asmtemplate": "CLASTB  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>", "brief": "Conditionally extract last element to SIMD&FP scalar register", "heading": "CLASTB (SIMD&FP scalar)", "para": "Conditionally extract last element to SIMD&FP scalar register. \n\nFrom the source vector register extract the last active element, and then  zero-extend that element to destructively place in the destination and first  source SIMD & floating-point scalar register. If there are no active elements  then destructively zero-extend the least significant element-size bits of the  destination and first source SIMD & floating-point scalar register.", "explanations": {"": "FP register, encoded in the \"Vdn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<V><dn>": "Is the number [0-31] of the source and destination SIMD", "<Zm>": "Is the name of the source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["CLASTB  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>"]}, {"id": 111, "asmtemplate": "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]", "brief": "Gather prefetch halfwords (scalar plus vector)", "heading": "PRFH (scalar plus vector)", "para": "Gather prefetch halfwords (scalar plus vector). \n\nGather prefetch of halfwords from the active memory addresses generated by a  64-bit scalar base plus vector index. The index values are optionally first  sign or zero-extended from 32 to 64 bits and then multiplied by 2. Inactive  addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 3 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset and 64-bit scaled offset", "explanations": {"<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]", "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]", "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]"]}, {"id": 868, "asmtemplate": "LDAXR  <Xt>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Exclusive Register", "heading": "LDAXR", "para": "Load-Acquire Exclusive Register derives an address from a base register value,  loads a 32-bit word or 64-bit doubleword from memory, and writes it to a  register. The memory access is atomic. The PE marks the physical address being  accessed as an exclusive access. This exclusive access mark is checked by  Store Exclusive instructions. See Synchronization and semaphores. The  instruction also has memory ordering semantics as described in Load-Acquire,  Store-Release. For information about memory accesses see Load/Store addressing  modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAXR  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 260, "asmtemplate": "SABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Signed absolute difference (predicated)", "heading": "SABD", "para": "Signed Absolute Difference. This instruction subtracts the elements of the  vector of the second source SIMD&FP register from the corresponding elements  of the first source SIMD&FP register, places the the absolute values of the  results into a vector, and writes the vector to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SABD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1067, "asmtemplate": "RORV<Xd>, <Xn>, <Xm>", "brief": "Rotate Right (register)", "heading": "ROR (register)", "para": "Rotate Right (register) provides the value of the contents of a register  rotated by a variable number of bits. The bits that are rotated off the right  end are inserted into the vacated bit positions on the left. The remainder  obtained by dividing the second source register by the data size defines the  number of bits by which the first source register is right-shifted. \n\nThis is an alias of RORV. This means:  \n* The encodings in this description are named to match the encodings of RORV. \n* The description of RORV gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."}, "encodings": ["ROR  <Wd>, <Wn>, <Wm>"]}, {"id": 769, "asmtemplate": "LD1SW   {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load signed words to vector (immediate index)", "heading": "LD1SW (vector plus immediate)", "para": "Gather load signed words to vector (immediate index). \n\nGather load of signed words to active elements of a vector register from  memory addresses generated by a vector base plus immediate index. The index is  a multiple of 4 in the range 0 to 124. Inactive elements will not cause a read  from Device memory or signal faults, and are set to zero in the destination  vector.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 465, "asmtemplate": "SADDW{2}<Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", "brief": "Signed Add Wide", "heading": "SADDW, SADDW2", "para": "Signed Add Wide. This instruction adds vector elements of the first source  SIMD&FP register to the corresponding vector elements in the lower or upper  half of the second source SIMD&FP register, places the results in a vector,  and writes the vector to the SIMD&FP destination register. \n\nThe SADDW instruction extracts the second source vector from the lower half of  the second source register, while the SADDW2 instruction extracts the second  source vector from the upper half of the second source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"]}, {"id": 447, "asmtemplate": "CMPGE<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Compare signed less than or equal to vector, setting the condition flags", "heading": "CMPLE (vectors)", "para": "Compare signed less than or equal to vector, setting the condition flags. \n\nCompare active signed integer elements in the first source vector being less  than or equal to corresponding signed elements in the second source vector,  and place the boolean results of the comparison in the corresponding elements  of the destination predicate. Inactive elements in the destination predicate  register are set to zero. Sets the First (N), None (Z), !Last (C) condition  flags based on the predicate result, and the V flag to zero. \n\nThis is a pseudo-instruction of CMP<cc> (vectors). This means:  \n* The encodings in this description are named to match the encodings of \n  CMP<cc> (vectors). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of CMP<cc> (vectors) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 1239, "asmtemplate": "CSINC<Xd>, <Xn>, <Xn>, invert(<cond>)", "brief": "Conditional Increment", "heading": "CINC", "para": "Conditional Increment returns, in the destination register, the value of the  source register incremented by 1 if the condition is TRUE, and otherwise  returns the value of the source register. \n\nThis is an alias of CSINC. This means:  \n* The encodings in this description are named to match the encodings of CSINC. \n* The description of CSINC gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<cond>": "Is one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."}, "encodings": ["CINC  <Wd>, <Wn>, <cond>"]}, {"id": 924, "asmtemplate": "LDG  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Allocation Tag", "heading": "LDG", "para": "Load Allocation Tag loads an Allocation Tag from a memory address, generates a  Logical Address Tag from the Allocation Tag and merges it into the destination  register. The address used for the load is calculated from the base register  and an immediate signed offset scaled by the Tag granule.", "explanations": {"<simm>": "Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field."}, "encodings": ["LDG  <Xt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 153, "asmtemplate": "LDRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", "brief": "Load Register Byte (register)", "heading": "LDRB (register)", "para": "Load Register Byte (register) calculates an address from a base register value  and an offset register value, loads a byte from memory, zero-extends it, and  writes it to a register. For information about memory accesses, see Load/Store  addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<extend><amount>": "Is the index shift amount, it must be ", "<Xm>": "When "}, "encodings": ["LDRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"]}, {"id": 1266, "asmtemplate": "INDEX   <Zd>.<T>, #<imm>, <R><m>", "brief": "Create index starting from immediate and incremented by general-purpose register", "heading": "INDEX (immediate, scalar)", "para": "Create index starting from immediate and incremented by general-purpose  register. \n\nPopulates the destination vector by setting the first element to the first  signed immediate integer operand and monotonically incrementing the value by  the second signed scalar integer operand for each subsequent element. The  scalar source operand is a general-purpose register in which only the least  significant bits corresponding to the vector element size are used and any  remaining bits are ignored. This instruction is unpredicated.", "explanations": {"<T><imm>": "Is the signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field.", "<R><m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["INDEX   <Zd>.<T>, #<imm>, <R><m>"]}, {"id": 514, "asmtemplate": "SUBP  <Xd>, <Xn|SP>, <Xm|SP>", "brief": "Subtract Pointer", "heading": "SUBP", "para": "Subtract Pointer subtracts the 56-bit address held in the second source  register from the 56-bit address held in the first source register,  sign-extends the result to 64-bits, and writes the result to the destination  register.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Xd\" field.", "<Xm|SP>": "Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Xm\" field."}, "encodings": ["SUBP  <Xd>, <Xn|SP>, <Xm|SP>"]}, {"id": 676, "asmtemplate": "CBZ  <Xt>, <label>", "brief": "Compare and Branch on Zero", "heading": "CBZ", "para": "Compare and Branch on Zero compares the value in a register with zero, and  conditionally branches to a label at a PC-relative offset if the comparison is  equal. It provides a hint that this is not a subroutine call or return. This  instruction does not affect condition flags.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<label>": "Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4.", "<Xt>": "Is the 64-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field."}, "encodings": ["CBZ  <Wt>, <label>"]}, {"id": 929, "asmtemplate": "SBCS  <Xd>, <Xn>, <Xm>", "brief": "Subtract with Carry, setting flags", "heading": "SBCS", "para": "Subtract with Carry, setting flags, subtracts a register value and the value  of NOT (Carry flag) from a register value, and writes the result to the  destination register. It updates the condition flags based on the result. \n\nThis instruction is used by the alias NGCS.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["SBCS  <Wd>, <Wn>, <Wm>"]}, {"id": 378, "asmtemplate": "FADDV   <V><d>, <Pg>, <Zn>.<T>", "brief": "Floating-point add recursive reduction to scalar", "heading": "FADDV", "para": "Floating-point add recursive reduction to scalar. \n\nFloating-point add horizontally over all lanes of a vector using a recursive  pairwise reduction, and place the result in the SIMD&FP scalar destination  register. Inactive elements in the source vector are treated as +0.0.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["FADDV   <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 1023, "asmtemplate": "STXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]", "brief": "Store Exclusive Register", "heading": "STXR", "para": "Store Exclusive Register stores a 32-bit word or a 64-bit doubleword from a  register to memory if the PE has exclusive access to the memory address, and  returns a status value of 0 if the store was successful, or of 1 if no store  was performed. See Synchronization and semaphores. For information about  memory accesses see Load/Store addressing modes.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1163, "asmtemplate": "DUP<Zd>.<T>, #<imm>{, <shift>}", "brief": "Move signed immediate to vector elements (unpredicated)", "heading": "MOV (immediate, unpredicated)", "para": "Move signed immediate to vector elements (unpredicated). \n\nUnconditionally broadcast the signed integer immediate into each element of  the destination vector. This instruction is unpredicated. \n\nThe immediate operand is a signed value in the range -128 to +127, and for  element widths of 16 bits or higher it may also be a signed multiple of 256 in  the range -32768 to +32512 (excluding 0). \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<simm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\". \n\nThis is an alias of DUP (immediate). This means:  \n* The encodings in this description are named to match the encodings of DUP \n  (immediate). \n* The description of DUP (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<T><imm>": "Is a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOV     <Zd>.<T>, #<imm>{, <shift>}"]}, {"id": 1156, "asmtemplate": "FMLA    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point fused multiply-add vectors (predicated), writing addend [Zda = Zda + Zn * Zm]", "heading": "FMLA (vectors)", "para": "Floating-point fused multiply-add vectors (predicated), writing addend [Zda =  Zda + Zn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and add to elements of the third source (addend) vector  without intermediate rounding. Destructively place the results in the  destination and third source (addend) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FMLA    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>"]}, {"id": 740, "asmtemplate": "LDUMAXLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic unsigned maximum on halfword in memory, without return", "heading": "STUMAXH, STUMAXLH", "para": "Atomic unsigned maximum on halfword in memory, without return, atomically  loads a 16-bit halfword from memory, compares it against the value held in a  register, and stores the larger value back to memory, treating the values as  unsigned numbers.  \n* STUMAXH does not have release semantics. \n* STUMAXLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH. \n* The description of LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STUMAXH  <Ws>, [<Xn|SP>]"]}, {"id": 944, "asmtemplate": "SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S", "brief": "SHA1 schedule update 0", "heading": "SHA1SU0", "para": "SHA1 schedule update 0.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SHA1SU0  <Vd>.4S, <Vn>.4S, <Vm>.4S"]}, {"id": 803, "asmtemplate": "CCMN  <Xn>, #<imm>, #<nzcv>, <cond>", "brief": "Conditional Compare Negative (immediate)", "heading": "CCMN (immediate)", "para": "Conditional Compare Negative (immediate) sets the value of the condition flags  to the result of the comparison of a register value and a negated immediate  value if the condition is TRUE, and an immediate value otherwise.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<nzcv>": "Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<imm>": "Is a five bit unsigned (positive) immediate encoded in the \"imm5\" field.", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way."}, "encodings": ["CCMN  <Wn>, #<imm>, #<nzcv>, <cond>"]}, {"id": 1249, "asmtemplate": "FCVTAU  <Xd>, <Dn>", "brief": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar)", "heading": "FCVTAU (scalar)", "para": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to  Away (scalar). This instruction converts the floating-point value in the  SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round  to Nearest with Ties to Away rounding mode, and writes the result to the  general-purpose destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "": "FP source register, encoded in the \"Rn\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTAU  <Wd>, <Hn>"]}, {"id": 441, "asmtemplate": "SB", "brief": "Speculation Barrier", "heading": "SB", "para": "Speculation Barrier is a barrier that controls speculation. \n\nThe semantics of the Speculation Barrier are that the execution, until the  barrier completes, of any instruction that appears later in the program order  than the barrier:  \n* Cannot be performed speculatively to the extent that such speculation can be \n  observed through side-channels as a result of control flow speculation or \n  data value speculation. \n* Can be speculatively executed as a result of predicting that a potentially \n  exception generating instruction has not generated an exception.  In particular, any instruction that appears later in the program order than  the barrier cannot cause a speculative allocation into any caching structure  where the allocation of that entry could be indicative of any data value  present in memory or in the registers. \n\nThe SB instruction:  \n* Cannot be speculatively executed as a result of control flow speculation or \n  data value speculation. \n* Can be speculatively executed as a result of predicting that a potentially \n  exception generating instruction has not generated an exception. The \n  potentially exception generating instruction can complete once it is known \n  not to be speculative, and all data values generated by instructions \n  appearing in program order before the SB instruction have their predicted \n  values confirmed.  When the prediction of the instruction stream is not informed by data taken  from the register outputs of the speculative execution of instructions  appearing in program order after an uncompleted SB instruction, the SB  instruction has no effect on the use of prediction resources to predict the  instruction stream that is being fetched.", "explanations": {}, "encodings": ["SB"]}, {"id": 229, "asmtemplate": "INDEX   <Zd>.<T>, <R><n>, <R><m>", "brief": "Create index starting from and incremented by general-purpose register", "heading": "INDEX (scalars)", "para": "Create index starting from and incremented by general-purpose register. \n\nPopulates the destination vector by setting the first element to the first  signed scalar integer operand and monotonically incrementing the value by the  second signed scalar integer operand for each subsequent element. The scalar  source operands are general-purpose registers in which only the least  significant bits corresponding to the vector element size are used and any  remaining bits are ignored. This instruction is unpredicated.", "explanations": {"<T><R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["INDEX   <Zd>.<T>, <R><n>, <R><m>"]}, {"id": 1047, "asmtemplate": "ANDS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise AND predicates", "heading": "AND, ANDS (predicates)", "para": "Bitwise AND predicates. \n\nBitwise AND active elements of the second source predicate with corresponding  elements of the first source predicate and place the results in the  corresponding elements of the destination predicate. Inactive elements in the  destination predicate register are set to zero. Optionally sets the First (N),  None (Z), !Last (C) condition flags based on the predicate result, and the V  flag to zero. \n\nThis instruction is used by the aliases MOVS (predicated), and MOV (predicate,  predicated, zeroing). \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["AND     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "ANDS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 861, "asmtemplate": "DUP     <Zd>.<T>, #<imm>{, <shift>}", "brief": "Broadcast signed immediate to vector elements (unpredicated)", "heading": "DUP (immediate)", "para": "Broadcast signed immediate to vector elements (unpredicated). \n\nUnconditionally broadcast the signed integer immediate into each element of  the destination vector. This instruction is unpredicated. \n\nThe immediate operand is a signed value in the range -128 to +127, and for  element widths of 16 bits or higher it may also be a signed multiple of 256 in  the range -32768 to +32512 (excluding 0). \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<simm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\". \n\nThis instruction is used by the aliases FMOV (zero, unpredicated), and MOV \n(immediate, unpredicated).", "explanations": {"<T><imm>": "Is a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["DUP     <Zd>.<T>, #<imm>{, <shift>}"]}, {"id": 435, "asmtemplate": "USUBL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Subtract Long", "heading": "USUBL, USUBL2", "para": "Unsigned Subtract Long. This instruction subtracts each vector element in the  lower or upper half of the second source SIMD&FP register from the  corresponding vector element of the first source SIMD&FP register, places the  result into a vector, and writes the vector to the destination SIMD&FP  register. All the values in this instruction are unsigned integer values. The  destination vector elements are twice as long as the source vector elements. \n\nThe USUBL instruction extracts each source vector from the lower half of each  source register, while the USUBL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "2<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["USUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 172, "asmtemplate": "BL  <label>", "brief": "Branch with Link", "heading": "BL", "para": "Branch with Link branches to a PC-relative offset, setting the register X30 to  PC+4. It provides a hint that this is a subroutine call.", "explanations": {"<label>": "Is the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as \"imm26\" times 4."}, "encodings": ["BL  <label>"]}, {"id": 737, "asmtemplate": "LD1W    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load unsigned words to vector (scalar index)", "heading": "LD1W (scalar plus scalar)", "para": "Contiguous load unsigned words to vector (scalar index). \n\nContiguous load of unsigned words to elements of a vector register from the  memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 4 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 520, "asmtemplate": "UDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Unsigned divide (predicated)", "heading": "UDIV", "para": "Unsigned Divide divides an unsigned integer register value by another unsigned  integer register value, and writes the result to the destination register. The  condition flags are not affected.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UDIV  <Wd>, <Wn>, <Wm>"]}, {"id": 1052, "asmtemplate": "USDOT   <Zda>.S, <Zn>.B, <Zm>.B", "brief": "Unsigned by signed integer dot product", "heading": "USDOT (vectors)", "para": "Unsigned by signed integer dot product. \n\nThe unsigned by signed integer dot product instruction computes the dot  product of a group of four unsigned 8-bit integer values held in each 32-bit  element of the first source vector multiplied by a group of four signed 8-bit  integer values in the corresponding 32-bit element of the second source  vector, and then destructively adds the widened dot product to the  corresponding 32-bit element of the destination vector. \n\nThis instruction is unpredicated. \n\nID_AA64ZFR0_EL1.I8MM indicates whether this instruction is implemented.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["USDOT   <Zda>.S, <Zn>.B, <Zm>.B"]}, {"id": 80, "asmtemplate": "ADR  <Xd>, <label>", "brief": "Form PC-relative address", "heading": "ADR", "para": "Form PC-relative address adds an immediate value to the PC value to form a  PC-relative address, and writes the result to the destination register.", "explanations": {"<label>": "Is the program label whose address is to be calculated. Its offset from the address of this instruction, in the range +/-1MB, is encoded in \"immhi:immlo\".", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ADR  <Xd>, <label>"]}, {"id": 182, "asmtemplate": "LDNF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault signed words to vector (immediate index)", "heading": "LDNF1SW", "para": "Contiguous load non-fault signed words to vector (immediate index). \n\nContiguous load with non-faulting behavior of signed words to elements of a  vector register from the memory address generated by a 64-bit scalar base and  immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDNF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 269, "asmtemplate": "LD1SH   {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load signed halfwords to vector (immediate index)", "heading": "LD1SH (vector plus immediate)", "para": "Gather load signed halfwords to vector (immediate index). \n\nGather load of signed halfwords to active elements of a vector register from  memory addresses generated by a vector base plus immediate index. The index is  a multiple of 2 in the range 0 to 62. Inactive elements will not cause a read  from Device memory or signal faults, and are set to zero in the destination  vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 368, "asmtemplate": "FRINTA  <Dd>, <Dn>", "brief": "Floating-point Round to Integral, to nearest with ties to Away (scalar)", "heading": "FRINTA (scalar)", "para": "Floating-point Round to Integral, to nearest with ties to Away (scalar). This  instruction rounds a floating-point value in the SIMD&FP source register to an  integral floating-point value of the same size using the Round to Nearest with  Ties to Away rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Dn>": "Is the 64-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTA  <Hd>, <Hn>"]}, {"id": 271, "asmtemplate": "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Multiply-Subtract from accumulator (vector)", "heading": "MLS (vector)", "para": "Multiply-Subtract from accumulator (vector). This instruction multiplies  corresponding elements in the vectors of the two source SIMD&FP registers, and  subtracts the results from the vector elements of the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 386, "asmtemplate": "FNMLS   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point negated fused multiply-subtract vectors (predicated), writing addend [Zda = -Zda + Zn * Zm]", "heading": "FNMLS", "para": "Floating-point negated fused multiply-subtract vectors (predicated), writing  addend [Zda = -Zda + Zn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and subtract from elements of the third source (addend)  vector without intermediate rounding. Destructively place the negated results  in the destination and third source (addend) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FNMLS   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>"]}, {"id": 18, "asmtemplate": "STLLRB  <Wt>, [<Xn|SP>{,#0}]", "brief": "Store LORelease Register Byte", "heading": "STLLRB", "para": "Store LORelease Register Byte stores a byte from a 32-bit register to a memory  location. The instruction also has memory ordering semantics as described in  Load LOAcquire, Store LORelease. For information about memory accesses, see  Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STLLRB  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 753, "asmtemplate": "SEV", "brief": "Send Event", "heading": "SEV", "para": "Send Event is a hint instruction. It causes an event to be signaled to all PEs  in the multiprocessor system. For more information, see Wait for Event  mechanism and Send event.", "explanations": {}, "encodings": ["SEV"]}, {"id": 926, "asmtemplate": "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]", "brief": "Gather prefetch words (scalar plus vector)", "heading": "PRFW (scalar plus vector)", "para": "Gather prefetch words (scalar plus vector). \n\nGather prefetch of words from the active memory addresses generated by a  64-bit scalar base plus vector index. The index values are optionally first  sign or zero-extended from 32 to 64 bits and then multiplied by 4. Inactive  addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 3 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset and 64-bit scaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]", "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]", "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]"]}, {"id": 393, "asmtemplate": "LD1SW   {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load signed words to vector (vector index)", "heading": "LD1SW (scalar plus vector)", "para": "Gather load signed words to vector (vector index). \n\nGather load of signed words to active elements of a vector register from  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 4. Inactive elements will not cause a read from  Device memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 4 classes: 32-bit unpacked scaled offset , 32-bit  unpacked unscaled offset , 64-bit scaled offset and 64-bit unscaled offset", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]", "LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 764, "asmtemplate": "SADDV   <Dd>, <Pg>, <Zn>.<T>", "brief": "Signed add reduction to scalar", "heading": "SADDV", "para": "Signed add reduction to scalar. \n\nSigned add horizontally across all lanes of a vector, and place the result in  the SIMD&FP scalar destination register. Narrow elements are first  sign-extended to 64 bits. Inactive elements in the source vector are treated  as zero.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Dd>": "Is the 64-bit name of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["SADDV   <Dd>, <Pg>, <Zn>.<T>"]}, {"id": 394, "asmtemplate": "SHA256H  <Qd>, <Qn>, <Vm>.4S", "brief": "SHA256 hash update (part 1)", "heading": "SHA256H", "para": "SHA256 hash update (part 1).", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Qn>": "Is the 128-bit name of the second SIMD", "<Vm>": "Is the name of the third SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA256H  <Qd>, <Qn>, <Vm>.4S"]}, {"id": 653, "asmtemplate": "ST3B    {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store three-byte structures from three vectors (immediate index)", "heading": "ST3B (scalar plus immediate)", "para": "Contiguous store three-byte structures from three vectors (immediate index). \n\nContiguous store three-byte structures, each from the same element number in  three vector registers to the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 3 in the range -24 to 21 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive bytes in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 122, "asmtemplate": "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "brief": "Compare vector to immediate", "heading": "CMP<cc> (immediate)", "para": "Compare vector to immediate. \n\nCompare active integer elements in the source vector with an immediate, and  place the boolean results of the specified comparison in the corresponding  elements of the destination predicate. Inactive elements in the destination  predicate register are set to zero. Sets the First (N), None (Z), !Last (C)  condition flags based on the predicate result, and the V flag to zero. \n\n \n\nThe <cc> symbol specifies one of the standard ARM condition codes: EQ, GE, GT,  HI, HS, LE, LO, LS, LT or NE. \n\nIt has encodings from 10 classes: Equal , Greater than , Greater than or equal \n, Higher , Higher or same , Less than , Less than or equal , Lower , Lower or  same and Not equal", "explanations": {"<imm>": "For the higher, higher or same, lower and lower or same variant: is the unsigned immediate operand, in the range 0 to 127, encoded in the \"imm7\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPLO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPLS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #<imm>"]}, {"id": 1177, "asmtemplate": "SHA512SU0  <Vd>.2D, <Vn>.2D", "brief": "SHA512 Schedule Update 0", "heading": "SHA512SU0", "para": "SHA512 Schedule Update 0 takes the values from the two 128-bit source SIMD&FP  registers and produces a 128-bit output value that combines the gamma0  functions of two iterations of the SHA512 schedule update that are performed  after the first 16 iterations within a block. It returns this value to the  destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA512 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SHA512SU0  <Vd>.2D, <Vn>.2D"]}, {"id": 1099, "asmtemplate": "PRFH    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Gather prefetch halfwords (vector plus immediate)", "heading": "PRFH (vector plus immediate)", "para": "Gather prefetch halfwords (vector plus immediate). \n\nGather prefetch of halfwords from the active memory addresses generated by a  vector base plus immediate index. The index is a multiple of 2 in the range 0  to 62. Inactive addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFH    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]", "PRFH    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 1015, "asmtemplate": "CPY<Zd>.<T>, <Pg>/M, <V><n>", "brief": "Move SIMD&FP scalar register to vector elements (predicated)", "heading": "MOV (SIMD&FP scalar, predicated)", "para": "Move SIMD&FP scalar register to vector elements (predicated). \n\nMove the SIMD & floating-point scalar source register to each active element  in the destination vector. Inactive elements in the destination vector  register remain unmodified. \n\nThis is an alias of CPY (SIMD&FP scalar). This means:  \n* The encodings in this description are named to match the encodings of CPY \n  (SIMD&FP scalar). \n* The description of CPY (SIMD&FP scalar) gives the operational pseudocode for \n  this instruction.", "explanations": {"": "FP register, encoded in the \"Vn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<V><n>": "Is the number [0-31] of the source SIMD", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["MOV     <Zd>.<T>, <Pg>/M, <V><n>"]}, {"id": 307, "asmtemplate": "LDAXRH  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Exclusive Register Halfword", "heading": "LDAXRH", "para": "Load-Acquire Exclusive Register Halfword derives an address from a base  register value, loads a halfword from memory, zero-extends it and writes it to  a register. The memory access is atomic. The PE marks the physical address  being accessed as an exclusive access. This exclusive access mark is checked  by Store Exclusive instructions. See Synchronization and semaphores. The  instruction also has memory ordering semantics as described in Load-Acquire,  Store-Release. For information about memory accesses see Load/Store addressing  modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAXRH  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1068, "asmtemplate": "SABAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Absolute difference and Accumulate Long", "heading": "SABAL, SABAL2", "para": "Signed Absolute difference and Accumulate Long. This instruction subtracts the  vector elements in the lower or upper half of the second source SIMD&FP  register from the corresponding vector elements of the first source SIMD&FP  register, and accumulates the absolute values of the results into the vector  elements of the destination SIMD&FP register. The destination vector elements  are twice as long as the source vector elements. \n\nThe SABAL instruction extracts each source vector from the lower half of each  source register, while the SABAL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "2<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 118, "asmtemplate": "LD2W    {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load two-word structures to two vectors (immediate index)", "heading": "LD2W (scalar plus immediate)", "para": "Contiguous load two-word structures to two vectors (immediate index). \n\nContiguous load two-word structures, each to the same element number in two  vector registers from the memory address generated by a 64-bit scalar base and  an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive words in memory which  make up each structure. Inactive elements will not cause a read from Device  memory or signal a fault, and the corresponding element is set to zero in each  of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD2W    { <Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 593, "asmtemplate": "FRINT32Z  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to 32-bit Integer toward Zero (vector)", "heading": "FRINT32Z (vector)", "para": "Floating-point Round to 32-bit Integer toward Zero (vector). This instruction  rounds a vector of floating-point values in the SIMD&FP source register to  integral floating-point values that fit into a 32-bit integer size using the  Round towards Zero rounding mode, and writes the result to the SIMD&FP  destination register. \n\nA zero input returns a zero result with the same sign. When one of the result  values is not numerically equal to the corresponding input value, an Inexact  exception is raised. When an input is infinite, NaN or out-of-range, the  instruction returns for the corresponding result value the most negative  integer representable in the destination size, and an Invalid Operation  floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FRINT32Z  <Vd>.<T>, <Vn>.<T>"]}, {"id": 458, "asmtemplate": "SMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Signed maximum vectors (predicated)", "heading": "SMAX (vectors)", "para": "Signed maximum vectors (predicated). \n\nDetermine the signed maximum of active elements of the second source vector  and corresponding elements of the first source vector and destructively place  the results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1069, "asmtemplate": "LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault signed bytes to vector (vector index)", "heading": "LDFF1SB (scalar plus vector)", "para": "Gather load first-fault signed bytes to vector (vector index). \n\nGather load with first-faulting behavior of signed bytes to active elements of  a vector register from memory addresses generated by a 64-bit scalar base plus  vector index. The index values are optionally sign or zero-extended from 32 to  64 bits. Inactive elements will not cause a read from Device memory or signal  faults, and are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 32-bit unpacked unscaled offset , 32-bit  unscaled offset and 64-bit unscaled offset", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 577, "asmtemplate": "ST4B    {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store four-byte structures from four vectors (immediate index)", "heading": "ST4B (scalar plus immediate)", "para": "Contiguous store four-byte structures from four vectors (immediate index). \n\nContiguous store four-byte structures, each from the same element number in  four vector registers to the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 4 in the range -32 to 28 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive bytes in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32."}, "encodings": ["ST4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 51, "asmtemplate": "SM3TT2B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", "brief": "SM3TT2B", "heading": "SM3TT2B", "para": "SM3TT2B takes three 128-bit vectors from three source SIMD&FP registers, and a  2-bit immediate index value, and returns a 128-bit result in the destination  SIMD&FP register. It performs a 32-bit majority function between the three  32-bit fields held in the upper three elements of the first source vector, and  adds the resulting 32-bit value and the following three other 32-bit values:  \n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the 32-bit majority function. \n* The 32-bit element held in the top 32 bits of the second source vector, Vn. \n* A 32-bit element indexed out of the third source vector, Vm.  A three-way exclusive OR is performed of the result of this addition, the  result of the addition rotated left by 9, and the result of the addition  rotated left by 17. The result of this exclusive OR is returned as the top  element of the returned result. The other elements of this result are taken  from elements of the first source vector, with the element returned in  bits<63:32> being rotated left by 19. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": ", encoded in \"imm2\".", "<Vd>": "Is the name of the SIMD", "<imm2>": "Is a 32-bit element indexed out of ", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SM3TT2B  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"]}, {"id": 714, "asmtemplate": "UMADDL<Xd>, <Wn>, <Wm>, XZR", "brief": "Unsigned Multiply Long", "heading": "UMULL", "para": "Unsigned Multiply Long multiplies two 32-bit register values, and writes the  result to the 64-bit destination register. \n\nThis is an alias of UMADDL. This means:  \n* The encodings in this description are named to match the encodings of \n  UMADDL. \n* The description of UMADDL gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."}, "encodings": ["UMULL  <Xd>, <Wn>, <Wm>"]}, {"id": 1170, "asmtemplate": "LDSMINLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic signed minimum on byte in memory, without return", "heading": "STSMINB, STSMINLB", "para": "Atomic signed minimum on byte in memory, without return, atomically loads an  8-bit byte from memory, compares it against the value held in a register, and  stores the smaller value back to memory, treating the values as signed  numbers.  \n* STSMINB does not have release semantics. \n* STSMINLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB. \n* The description of LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSMINB  <Ws>, [<Xn|SP>]"]}, {"id": 13, "asmtemplate": "FDIV  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Divide (scalar)", "heading": "FDIV (scalar)", "para": "Floating-point Divide (scalar). This instruction divides the floating-point  value of the first source SIMD&FP register by the floating-point value of the  second source SIMD&FP register, and writes the result to the destination  SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FDIV  <Hd>, <Hn>, <Hm>"]}, {"id": 1039, "asmtemplate": "UCVTF  <Dd>, <Xn>", "brief": "Unsigned integer Convert to Floating-point (scalar)", "heading": "UCVTF (scalar, integer)", "para": "Unsigned integer Convert to Floating-point (scalar). This instruction converts  the unsigned integer value in the general-purpose source register to a  floating-point value using the rounding mode that is specified by the FPCR,  and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Sd>": "Is the 32-bit name of the SIMD", "": "FP destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD"}, "encodings": ["UCVTF  <Hd>, <Wn>"]}, {"id": 795, "asmtemplate": "LD1ROW  {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate eight words (immediate index)", "heading": "LD1ROW (scalar plus immediate)", "para": "Contiguous load and replicate eight words (immediate index). \n\nLoad eight contiguous words to elements of a 256-bit (octaword) vector from  the memory address generated by a 64-bit scalar base address and immediate  index that is a multiple of 32 in the range -256 to +224 added to the base  address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first eight predicate elements are used and higher numbered predicate  elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 893, "asmtemplate": "LD3D    {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load three-doubleword structures to three vectors (immediate index)", "heading": "LD3D (scalar plus immediate)", "para": "Contiguous load three-doubleword structures to three vectors (immediate  index). \n\nContiguous load three-doubleword structures, each to the same element number  in three vector registers from the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 3 in the range -24 to 21  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive doublewords in  memory which make up each structure. Inactive elements will not cause a read  from Device memory or signal a fault, and the corresponding element is set to  zero in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 284, "asmtemplate": "FCMGT<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point compare less than vector", "heading": "FCMLT (vectors)", "para": "Floating-point compare less than vector. \n\nCompare active floating-point elements in the first source vector being less  than corresponding elements in the second source vector, and place the boolean  results of the comparison in the corresponding elements of the destination  predicate. Inactive elements in the destination predicate register are set to  zero. Does not set the condition flags. \n\nThis is a pseudo-instruction of FCM<cc> (vectors). This means:  \n* The encodings in this description are named to match the encodings of \n  FCM<cc> (vectors). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of FCM<cc> (vectors) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["FCMLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 694, "asmtemplate": "ASRV  <Xd>, <Xn>, <Xm>", "brief": "Arithmetic Shift Right Variable", "heading": "ASRV", "para": "Arithmetic Shift Right Variable shifts a register value right by a variable  number of bits, shifting in copies of its sign bit, and writes the result to  the destination register. The remainder obtained by dividing the second source  register by the data size defines the number of bits by which the first source  register is right-shifted. \n\nThis instruction is used by the alias ASR (register).", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field."}, "encodings": ["ASRV  <Wd>, <Wn>, <Wm>"]}, {"id": 648, "asmtemplate": "BFCVTN{2}<Vd>.<Ta>, <Vn>.4S", "brief": "Floating-point convert from single-precision to BFloat16 format (vector)", "heading": "BFCVTN, BFCVTN2", "para": "Floating-point convert from single-precision to BFloat16 format (vector) reads  each single-precision element in the SIMD&FP source vector, converts each  value to BFloat16 format, and writes the results in the lower or upper half of  the SIMD&FP destination vector. The result elements are half the width of the  source elements. \n\nThe BFCVTN instruction writes the half-width results to the lower half of the  destination vector and clears the upper half to zero, while the BFCVTN2  instruction writes the results to the upper half of the destination vector  without affecting the other bits in the register. \n\nUnlike the BFloat16 multiplication instructions, this instruction honors all  of the control bits in the FPCR that apply to single-precision arithmetic,  including the rounding mode. It can also generate a floating-point exception  that causes cumulative exception bits in the FPSR to be set, or a synchronous  exception to be taken, depending on the enable bits in the FPCR.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the SIMD"}, "encodings": ["BFCVTN{2}  <Vd>.<Ta>, <Vn>.4S"]}, {"id": 682, "asmtemplate": "CCMP  <Xn>, <Xm>, #<nzcv>, <cond>", "brief": "Conditional Compare (register)", "heading": "CCMP (register)", "para": "Conditional Compare (register) sets the value of the condition flags to the  result of the comparison of two registers if the condition is TRUE, and an  immediate value otherwise.", "explanations": {"<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<nzcv>": "Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way."}, "encodings": ["CCMP  <Wn>, <Wm>, #<nzcv>, <cond>"]}, {"id": 1065, "asmtemplate": "SQDECP  <Zdn>.<T>, <Pm>.<T>", "brief": "Signed saturating decrement vector by count of true predicate elements", "heading": "SQDECP (vector)", "para": "Signed saturating decrement vector by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to decrement all destination vector elements. The results are saturated  to the element signed integer range. \n\nThe predicate size specifier may be omitted in assembler source code, but this  is deprecated and will be prohibited in a future release of the architecture.", "explanations": {"<T><Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["SQDECP  <Zdn>.<T>, <Pm>.<T>"]}, {"id": 536, "asmtemplate": "MUL     <Zdn>.<T>, <Zdn>.<T>, #<imm>", "brief": "Multiply by immediate (unpredicated)", "heading": "MUL (immediate)", "para": "Multiply by immediate (unpredicated). \n\nMultiply by an immediate each element of the source vector, and destructively  place the results in the corresponding elements of the source vector. The  immediate is a signed 8-bit value in the range -128 to +127, inclusive. This  instruction is unpredicated.", "explanations": {"<T><imm>": "Is the signed immediate operand, in the range -128 to 127, encoded in the \"imm8\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["MUL     <Zdn>.<T>, <Zdn>.<T>, #<imm>"]}, {"id": 141, "asmtemplate": "SQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Signed saturating subtract vectors (unpredicated)", "heading": "SQSUB (vectors)", "para": "Signed saturating subtract vectors (unpredicated). \n\nSigned saturating subtract all elements of the second source vector from  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. Each result element is  saturated to the N-bit element's signed integer range -2(N-1) to (2(N-1) )-1.  This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 154, "asmtemplate": "FABS  <Dd>, <Dn>", "brief": "Floating-point Absolute value (scalar)", "heading": "FABS (scalar)", "para": "Floating-point Absolute value (scalar). This instruction calculates the  absolute value in the SIMD&FP source register and writes the result to the  SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Dn>": "Is the 64-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FABS  <Hd>, <Hn>"]}, {"id": 328, "asmtemplate": "LD4D    {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load four-doubleword structures to four vectors (immediate index)", "heading": "LD4D (scalar plus immediate)", "para": "Contiguous load four-doubleword structures to four vectors (immediate index). \n\nContiguous load four-doubleword structures, each to the same element number in  four vector registers from the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 4 in the range -32 to 28  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive doublewords in  memory which make up each structure. Inactive elements will not cause a read  from Device memory or signal a fault, and the corresponding element is set to  zero in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 574, "asmtemplate": "UXTW    <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Unsigned byte / halfword / word extend (predicated)", "heading": "UXTB, UXTH, UXTW", "para": "Unsigned byte / halfword / word extend (predicated). \n\nZero-extend the least-significant sub-element of each active element of the  source vector, and place the results in the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nIt has encodings from 3 classes: Byte , Halfword and Word", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["UXTB    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "UXTH    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "UXTW    <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 977, "asmtemplate": "SQDMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed saturating Doubling Multiply Long", "heading": "SQDMULL, SQDMULL2 (vector)", "para": "Signed saturating Doubling Multiply Long. This instruction multiplies  corresponding vector elements in the lower or upper half of the two source  SIMD&FP registers, doubles the results, places the final results in a vector,  and writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMULL instruction extracts each source vector from the lower half of  each source register, while the SQDMULL2 instruction extracts each source  vector from the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<m>": "Is the number of the second SIMD", "2<Vd>": "Is the name of the SIMD", "<Va><d>": "Is the number of the SIMD", "<Vb><n>": "Is the number of the first SIMD"}, "encodings": ["SQDMULL  <Va><d>, <Vb><n>, <Vb><m>", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 456, "asmtemplate": "UQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment vector by multiple of 32-bit predicate constraint element count", "heading": "UQINCW (vector)", "para": "Unsigned saturating increment vector by multiple of 32-bit predicate  constraint element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. The  results are saturated to the 32-bit unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCW  <Zdn>.S{, <pattern>{, MUL #<imm>}}"]}, {"id": 259, "asmtemplate": "CLS     <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Count leading sign bits (predicated)", "heading": "CLS", "para": "Count leading sign bits (predicated). \n\nCount leading sign bits in each active element of the source vector, and place  the results in the corresponding elements of the destination vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["CLS     <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 994, "asmtemplate": "LDSETLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic bit set on byte in memory", "heading": "LDSETB, LDSETAB, LDSETALB, LDSETLB", "para": "Atomic bit set on byte in memory atomically loads an 8-bit byte from memory,  performs a bitwise OR with the value held in a register on it, and stores the  result back to memory. The value initially loaded from memory is returned in  the destination register.  \n* If the destination register is not WZR, LDSETAB and LDSETALB load from \n  memory with acquire semantics. \n* LDSETLB and LDSETALB store to memory with release semantics. \n* LDSETB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSETB, STSETLB.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDSETAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 835, "asmtemplate": "FCVTZS  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Signed integer, rounding toward Zero (vector)", "heading": "FCVTZS (vector, integer)", "para": "Floating-point Convert to Signed integer, rounding toward Zero (vector). This  instruction converts a scalar or each element in a vector from a  floating-point value to a signed integer value using the Round towards Zero  rounding mode, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTZS  <Hd>, <Hn>", "FCVTZS  <V><d>, <V><n>", "FCVTZS  <Vd>.<T>, <Vn>.<T>", "FCVTZS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 604, "asmtemplate": "UMOV<Xd>, <Vn>.D[<index>]", "brief": "Move vector element to general-purpose register", "heading": "MOV (to general)", "para": "Move vector element to general-purpose register. This instruction reads the  unsigned integer from the source SIMD&FP register, zero-extends it to form a  32-bit or 64-bit value, and writes the result to the destination  general-purpose register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of UMOV. This means:  \n* The encodings in this description are named to match the encodings of UMOV. \n* The description of UMOV gives the operational pseudocode for this \n  instruction.", "explanations": {"<index>": "For the 64-reg,UMOV-64-reg variant: is the element index encoded in \"imm5", "": "\".", "<Vn>": "Is the name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MOV  <Wd>, <Vn>.S[<index>]"]}, {"id": 1090, "asmtemplate": "SBFM  <Xd>, <Xn>, #<immr>, #<imms>", "brief": "Signed Bitfield Move", "heading": "SBFM", "para": "Signed Bitfield Move is usually accessed via one of its aliases, which are  always preferred for disassembly. \n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of \n(<imms>-<immr>+1) bits starting from bit position <immr> in the source  register to the least significant bits of the destination register. \n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from  the least significant bits of the source register to bit position \n(regsize-<immr>) of the destination register, where regsize is the destination  register size of 32 or 64 bits. \n\nIn both cases the destination bits below the bitfield are set to zero, and the  bits above the bitfield are set to a copy of the most significant bit of the  bitfield. \n\nThis instruction is used by the aliases ASR (immediate), SBFIZ, SBFX, SXTB,  SXTH, and SXTW.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imms>": "For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<immr>": "For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SBFM  <Wd>, <Wn>, #<immr>, #<imms>"]}, {"id": 97, "asmtemplate": "STZGM  <Xt>, [<Xn|SP>]", "brief": "Store Tag and Zero Multiple", "heading": "STZGM", "para": "Store Tag and Zero Multiple writes a naturally aligned block of N Allocation  Tags and stores zero to the associated data locations, where the size of N is  identified in DCZID_EL0.BS, and the Allocation Tag written to address A is  taken from the source register bits<3:0>. \n\nThis instruction is undefined at EL0. \n\nThis instruction generates an Unchecked access. \n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field."}, "encodings": ["STZGM  <Xt>, [<Xn|SP>]"]}, {"id": 831, "asmtemplate": "FMINNMV <V><d>, <Pg>, <Zn>.<T>", "brief": "Floating-point minimum number recursive reduction to scalar", "heading": "FMINNMV", "para": "Floating-point Minimum Number across Vector. This instruction compares all the  vector elements in the source SIMD&FP register, and writes the smallest of the  values as a scalar to the destination SIMD&FP register. All the values in this  instruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result of the comparison  is the numerical value, otherwise the result is identical to FMIN (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD"}, "encodings": ["FMINNMV  <V><d>, <Vn>.<T>", "FMINNMV  <V><d>, <Vn>.<T>"]}, {"id": 167, "asmtemplate": "STZG  <Xt|SP>, [<Xn|SP>{, #<simm>}]", "brief": "Store Allocation Tag, Zeroing", "heading": "STZG", "para": "Store Allocation Tag, Zeroing stores an Allocation Tag to memory, zeroing the  associated data location. The address used for the store is calculated from  the base register and an immediate signed offset scaled by the Tag granule.  The Allocation Tag is calculated from the Logical Address Tag in the source  register. \n\nThis instruction generates an Unchecked access. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"<simm>": "Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt|SP>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field."}, "encodings": ["STZG  <Xt|SP>, [<Xn|SP>], #<simm>", "STZG  <Xt|SP>, [<Xn|SP>, #<simm>]!", "STZG  <Xt|SP>, [<Xn|SP>{, #<simm>}]"]}, {"id": 562, "asmtemplate": "PRFW    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Gather prefetch words (vector plus immediate)", "heading": "PRFW (vector plus immediate)", "para": "Gather prefetch words (vector plus immediate). \n\nGather prefetch of words from the active memory addresses generated by a  vector base plus immediate index. The index is a multiple of 4 in the range 0  to 124. Inactive addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFW    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]", "PRFW    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 72, "asmtemplate": "SSHLL{2}<Vd>.<Ta>, <Vn>.<Tb>, #<shift>", "brief": "Signed Shift Left Long (immediate)", "heading": "SSHLL, SSHLL2", "para": "Signed Shift Left Long (immediate). This instruction reads each vector element  from the source SIMD&FP register, left shifts each vector element by the  specified shift amount, places the result into a vector, and writes the vector  to the destination SIMD&FP register. The destination vector elements are twice  as long as the source vector elements. All the values in this instruction are  signed integer values. \n\nThe SSHLL instruction extracts vector elements from the lower half of the  source register, while the SSHLL2 instruction extracts vector elements from  the upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias SXTL, SXTL2.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the SIMD"}, "encodings": ["SSHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"]}, {"id": 1221, "asmtemplate": "LD1SH   {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load signed halfwords to vector (vector index)", "heading": "LD1SH (scalar plus vector)", "para": "Gather load signed halfwords to vector (vector index). \n\nGather load of signed halfwords to active elements of a vector register from  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 2. Inactive elements will not cause a read from  Device memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 251, "asmtemplate": "FRECPX  <V><d>, <V><n>", "brief": "Floating-point Reciprocal exponent (scalar)", "heading": "FRECPX", "para": "Floating-point reciprocal exponent (predicated). \n\nInvert the exponent and zero the fractional part of each active floating-point  element of the source vector, and place the results in the corresponding  elements of the destination vector. Inactive elements in the destination  vector register remain unmodified. \n\nThe result of this instruction can be used with FMULX to convert arbitrary  elements in mathematical vector space to \"unit vectors\" or \"direction vectors\"  of length 1.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hd>": "Is the 16-bit name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD"}, "encodings": ["FRECPX  <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 106, "asmtemplate": "SPLICE  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>", "brief": "Splice two vectors under predicate control", "heading": "SPLICE", "para": "Splice two vectors under predicate control. \n\nCopy the first active to last active elements (inclusive) from the first  source vector to the lowest-numbered elements of the result. Then set any  remaining elements of the result to a copy of the lowest-numbered elements  from the second source vector. The result is placed destructively in the first  source vector.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SPLICE  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 521, "asmtemplate": "LDLARB  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load LOAcquire Register Byte", "heading": "LDLARB", "para": "Load LOAcquire Register Byte loads a byte from memory, zero-extends it and  writes it to a register. The instruction also has memory ordering semantics as  described in Load LOAcquire, Store LORelease. For information about memory  accesses, see Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/XZR, it is impossible for  software to observe the presence of the acquire semantic other than its effect  on the arrival at endpoints.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDLARB  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 298, "asmtemplate": "STP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", "brief": "Store Pair of Registers", "heading": "STP", "para": "Store Pair of Registers calculates an address from a base register value and  an immediate offset, and stores two 32-bit words or two 64-bit doublewords to  the calculated address, from two registers. For information about memory  accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"": "/8.", "<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<imm>": "For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>", "STP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!", "STP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 294, "asmtemplate": "UMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Unsigned multiply returning high half (predicated)", "heading": "UMULH", "para": "Unsigned multiply returning high half (predicated). \n\nWidening multiply unsigned integer values in active elements of the first  source vector by corresponding elements of the second source vector and  destructively place the high half of the result in the corresponding elements  of the first source vector. Inactive elements in the destination vector  register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 485, "asmtemplate": "BRKAS   <Pd>.B, <Pg>/Z, <Pn>.B", "brief": "Break after first true condition", "heading": "BRKA, BRKAS", "para": "Break after first true condition. \n\nSets destination predicate elements up to and including the first active and  true source element to true, then sets subsequent elements to false. Inactive  elements in the destination predicate register remain unmodified or are set to  zero, depending on whether merging or zeroing predication is selected.  Optionally sets the First (N), None (Z), !Last (C) condition flags based on  the predicate result, and the V flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<ZM><Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["BRKA    <Pd>.B, <Pg>/<ZM>, <Pn>.B", "BRKAS   <Pd>.B, <Pg>/Z, <Pn>.B"]}, {"id": 937, "asmtemplate": "LD2H    {<Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load two-halfword structures to two vectors (immediate index)", "heading": "LD2H (scalar plus immediate)", "para": "Contiguous load two-halfword structures to two vectors (immediate index). \n\nContiguous load two-halfword structures, each to the same element number in  two vector registers from the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive halfwords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD2H    { <Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1199, "asmtemplate": "LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>", "brief": "Logical shift right by immediate (predicated)", "heading": "LSR (immediate, predicated)", "para": "Logical shift right by immediate (predicated). \n\nShift right by immediate, inserting zeroes, each active element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate shift amount is an unsigned value in the  range 1 to number of bits per element. Inactive elements in the destination  vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>": "Is the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."}, "encodings": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>"]}, {"id": 1138, "asmtemplate": "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Floating-point Multiply (by element)", "heading": "FMUL (by element)", "para": "Floating-point Multiply (by element). This instruction multiplies the vector  elements in the first source SIMD&FP register by the specified value in the  second source SIMD&FP register, places the results in a vector, and writes the  vector to the destination SIMD&FP register. All the values in this instruction  are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar,  single-precision and double-precision , Vector, half-precision and Vector,  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<n>": "Is the number of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<Ts><index>": "For the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<Vm>": "For the single-precision and double-precision variant: is the name of the second SIMD"}, "encodings": ["FMUL  <Hd>, <Hn>, <Vm>.H[<index>]", "FMUL  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 636, "asmtemplate": "WFIT  <Xt>", "brief": "Wait For Interrupt with Timeout", "heading": "WFIT", "para": "Wait For Interrupt with Timeout is a hint instruction that indicates that the  PE can enter a low-power state and remain there until either a local timeout  event or a wakeup event occurs. For more information, see Wait For Interrupt. \n\nAs described in Wait For Interrupt, the execution of a WFIT instruction that  would otherwise cause entry to a low-power state can be trapped to a higher  Exception level. See:  \n* Traps to EL1 of EL0 execution of WFE and WFI instructions. \n* Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI \n  instructions. \n* Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rd\" field."}, "encodings": ["WFIT  <Xt>"]}, {"id": 492, "asmtemplate": "ADD<Xd|SP>, <Xn|SP>, #0", "brief": "Move between register and stack pointer", "heading": "MOV (to/from SP)", "para": "Move between register and stack pointer \n\n: Rd = Rn. \n\nThis is an alias of ADD (immediate). This means:  \n* The encodings in this description are named to match the encodings of ADD \n  (immediate). \n* The description of ADD (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field."}, "encodings": ["MOV  <Wd|WSP>, <Wn|WSP>"]}, {"id": 370, "asmtemplate": "LDTRSH  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Signed Halfword (unprivileged)", "heading": "LDTRSH", "para": "Load Register Signed Halfword (unprivileged) loads a halfword from memory,  sign-extends it to 32 bits or 64 bits, and writes the result to a register.  The address that is used for the load is calculated from a base register and  an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDTRSH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 112, "asmtemplate": "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Reciprocal Square Root Step", "heading": "FRSQRTS", "para": "Floating-point Reciprocal Square Root Step. This instruction multiplies  corresponding floating-point values in the vectors of the two source SIMD&FP  registers, subtracts each of the products from 3.0, divides these results by  2.0, places the results into a vector, and writes the vector to the  destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["FRSQRTS  <Hd>, <Hn>, <Hm>", "FRSQRTS  <V><d>, <V><n>, <V><m>", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FRSQRTS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 57, "asmtemplate": "LD1ROH  {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate sixteen halfwords (immediate index)", "heading": "LD1ROH (scalar plus immediate)", "para": "Contiguous load and replicate sixteen halfwords (immediate index). \n\nLoad sixteen contiguous halfwords to elements of a 256-bit (octaword) vector  from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 32 in the range -256 to +224 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first sixteen predicate elements are used and higher numbered  predicate elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1ROH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 810, "asmtemplate": "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0", "brief": "Floating-point Compare Greater than zero (vector)", "heading": "FCMGT (zero)", "para": "Floating-point Compare Greater than zero (vector). This instruction reads each  floating-point value in the source SIMD&FP register and if the value is  greater than zero sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCMGT  <Hd>, <Hn>, #0.0", "FCMGT  <V><d>, <V><n>, #0.0", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0", "FCMGT  <Vd>.<T>, <Vn>.<T>, #0.0"]}, {"id": 309, "asmtemplate": "SHLL{2}<Vd>.<Ta>, <Vn>.<Tb>, #<shift>", "brief": "Shift Left Long (by element size)", "heading": "SHLL, SHLL2", "para": "Shift Left Long (by element size). This instruction reads each vector element  in the lower or upper half of the source SIMD&FP register, left shifts each  result by the element size, writes the final result to a vector, and writes  the vector to the destination SIMD&FP register. The destination vector  elements are twice as long as the source vector elements. \n\nThe SHLL instruction extracts vector elements from the lower half of the  source register, while the SHLL2 instruction extracts vector elements from the  upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Ta><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD"}, "encodings": ["SHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"]}, {"id": 663, "asmtemplate": "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Add (vector)", "heading": "FADD (vector)", "para": "Floating-point Add (vector). This instruction adds corresponding vector  elements in the two source SIMD&FP registers, writes the result into a vector,  and writes the vector to the destination SIMD&FP register. All the values in  this instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 721, "asmtemplate": "REVW    <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Reverse bytes / halfwords / words within elements (predicated)", "heading": "REVB, REVH, REVW", "para": "Reverse bytes / halfwords / words within elements (predicated). \n\nReverse the order of 8-bit bytes, 16-bit halfwords or 32-bit words within each  active element of the source vector, and place the results in the  corresponding elements of the destination vector. Inactive elements in the  destination vector register remain unmodified. \n\nIt has encodings from 3 classes: Byte , Halfword and Word", "explanations": {"<T><T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["REVB    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "REVH    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "REVW    <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 29, "asmtemplate": "FACGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point absolute compare vectors", "heading": "FAC<cc>", "para": "Floating-point absolute compare vectors. \n\nCompare active absolute values of floating-point elements in the first source  vector with corresponding absolute values of elements in the second source  vector, and place the boolean results of the specified comparison in the  corresponding elements of the destination predicate. Inactive elements in the  destination predicate register are set to zero. Does not set the condition  flags. \n\n \n\nThe <cc> symbol specifies one of the standard ARM condition codes: GE, GT, LE,  or LT. \n\nThis instruction is used by the pseudo-instructions FACLE, and FACLT. \n\nIt has encodings from 2 classes: Greater than and Greater than or equal", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["FACGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "FACGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>"]}, {"id": 266, "asmtemplate": "MADD<Xd>, <Xn>, <Xm>, XZR", "brief": "Multiply", "heading": "MUL", "para": "Multiply \n\n: Rd = Rn * Rm. \n\nThis is an alias of MADD. This means:  \n* The encodings in this description are named to match the encodings of MADD. \n* The description of MADD gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xm>": "Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MUL  <Wd>, <Wn>, <Wm>"]}, {"id": 573, "asmtemplate": "FNEG  <Dd>, <Dn>", "brief": "Floating-point Negate (scalar)", "heading": "FNEG (scalar)", "para": "Floating-point Negate (scalar). This instruction negates the value in the  SIMD&FP source register and writes the result to the SIMD&FP destination  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FNEG  <Hd>, <Hn>"]}, {"id": 969, "asmtemplate": "SQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment vector by multiple of 64-bit predicate constraint element count", "heading": "SQINCD (vector)", "para": "Signed saturating increment vector by multiple of 64-bit predicate constraint  element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. The  results are saturated to the 64-bit signed integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCD  <Zdn>.D{, <pattern>{, MUL #<imm>}}"]}, {"id": 1101, "asmtemplate": "LDAPURH  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Load-Acquire RCpc Register Halfword (unscaled)", "heading": "LDAPURH", "para": "Load-Acquire RCpc Register Halfword (unscaled) calculates an address from a  base register and an immediate offset, loads a halfword from memory,  zero-extends it, and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDAPURH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 452, "asmtemplate": "LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Load Register Halfword (register)", "heading": "LDRH (register)", "para": "Load Register Halfword (register) calculates an address from a base register  value and an offset register value, loads a halfword from memory, zero-extends  it, and writes it to a register. For information about memory accesses, see  Load/Store addressing modes.", "explanations": {"<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xm>": "When "}, "encodings": ["LDRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 625, "asmtemplate": "REV16  <Xd>, <Xn>", "brief": "Reverse bytes in 16-bit halfwords", "heading": "REV16", "para": "Reverse bytes in 16-bit halfwords reverses the byte order in each 16-bit  halfword of a register.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["REV16  <Wd>, <Wn>"]}, {"id": 758, "asmtemplate": "BFMLALT <Zda>.S, <Zn>.H, <Zm>.H", "brief": "BFloat16 floating-point multiply-add long to single-precision (top)", "heading": "BFMLALT (vectors)", "para": "BFloat16 floating-point multiply-add long to single-precision (top). \n\nThis BFloat16 floating-point multiply-add long instruction widens the  odd-numbered 16-bit BFloat16 elements in the first source vector and the  corresponding elements in the second source vector to single-precision format  and then destructively multiplies and adds these values without intermediate  rounding to the overlapping 32-bit single-precision elements of the addend and  destination vector. This instruction is unpredicated. \n\nUnlike the BFloat16 matrix multiplication and dot product instructions, this  instruction performs a fused multiply-add that honors all of the FPCR bits  that apply to single-precision arithmetic. It can also generate a  floating-point exception that causes cumulative exception bits in the FPSR to  be set, or a synchronous exception to be taken, depending on the enable bits  in the FPCR. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["BFMLALT <Zda>.S, <Zn>.H, <Zm>.H"]}, {"id": 1139, "asmtemplate": "LASTB   <R><d>, <Pg>, <Zn>.<T>", "brief": "Extract last element to general-purpose register", "heading": "LASTB (scalar)", "para": "Extract last element to general-purpose register. \n\nIf there is an active element then extract the last active element from the  final source vector register. If there are no active elements, extract the  highest-numbered element. Then zero-extend and place the extracted element in  the destination general-purpose register.", "explanations": {"<R><d>": "Is the number [0-30] of the destination general-purpose register or the name ZR (31), encoded in the \"Rd\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LASTB   <R><d>, <Pg>, <Zn>.<T>"]}, {"id": 726, "asmtemplate": "PUNPKLO <Pd>.H, <Pn>.B", "brief": "Unpack and widen half of predicate", "heading": "PUNPKHI, PUNPKLO", "para": "Unpack and widen half of predicate. \n\nUnpack elements from the lowest or highest half of the source predicate and  place in elements of twice their size within the destination predicate. This  instruction is unpredicated. \n\nIt has encodings from 2 classes: High half and Low half", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["PUNPKHI <Pd>.H, <Pn>.B", "PUNPKLO <Pd>.H, <Pn>.B"]}, {"id": 245, "asmtemplate": "NEG  <Vd>.<T>, <Vn>.<T>", "brief": "Negate (vector)", "heading": "NEG (vector)", "para": "Negate (vector). This instruction reads each vector element from the source  SIMD&FP register, negates each value, puts the result into a vector, and  writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["NEG  <V><d>, <V><n>", "NEG  <Vd>.<T>, <Vn>.<T>"]}, {"id": 896, "asmtemplate": "UBFM<Wd>, <Wn>, #0, #15", "brief": "Unsigned Extend Halfword", "heading": "UXTH", "para": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends  it to the size of the register, and writes the result to the destination  register. \n\nThis is an alias of UBFM. This means:  \n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["UXTH  <Wd>, <Wn>"]}, {"id": 1019, "asmtemplate": "FMAXNMP  <V><d>, <Vn>.<T>", "brief": "Floating-point Maximum Number of Pair of elements (scalar)", "heading": "FMAXNMP (scalar)", "para": "Floating-point Maximum Number of Pair of elements (scalar). This instruction  compares two vector elements in the source SIMD&FP register and writes the  largest of the floating-point values as a scalar to the destination SIMD&FP  register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><V><d>": "Is the number of the SIMD"}, "encodings": ["FMAXNMP  <V><d>, <Vn>.<T>", "FMAXNMP  <V><d>, <Vn>.<T>"]}, {"id": 434, "asmtemplate": "LD1SB   {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load signed bytes to vector (immediate index)", "heading": "LD1SB (vector plus immediate)", "para": "Gather load signed bytes to vector (immediate index). \n\nGather load of signed bytes to active elements of a vector register from  memory addresses generated by a vector base plus immediate index. The index is  in the range 0 to 31. Inactive elements will not cause a read from Device  memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD1SB   { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 793, "asmtemplate": "UBFM<Wd>, <Wn>, #0, #7", "brief": "Unsigned Extend Byte", "heading": "UXTB", "para": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it  to the size of the register, and writes the result to the destination  register. \n\nThis is an alias of UBFM. This means:  \n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["UXTB  <Wd>, <Wn>"]}, {"id": 176, "asmtemplate": "LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Load Register Signed Word (register)", "heading": "LDRSW (register)", "para": "Load Register Signed Word (register) calculates an address from a base  register value and an offset register value, loads a word from memory,  sign-extends it to form a 64-bit value, and writes it to a register. The  offset register value can be shifted left by 0 or 2 bits. For information  about memory accesses, see Load/Store addressing modes.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "When "}, "encodings": ["LDRSW  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 1190, "asmtemplate": "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed saturating Shift Left (register)", "heading": "SQSHL (register)", "para": "Signed saturating Shift Left (register). This instruction takes each element  in the vector of the first source SIMD&FP register, shifts each element by a  value from the least significant byte of the corresponding element of the  second source SIMD&FP register, places the results in a vector, and writes the  vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it  is a right shift. The results are truncated. For rounded results, see SQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQSHL  <V><d>, <V><n>, <V><m>", "SQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 827, "asmtemplate": "PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Polynomial Multiply", "heading": "PMUL", "para": "Polynomial Multiply. This instruction multiplies corresponding elements in the  vectors of the two source SIMD&FP registers, places the results in a vector,  and writes the vector to the destination SIMD&FP register. \n\nFor information about multiplying polynomials see Polynomial arithmetic over \n{0, 1}. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["PMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 749, "asmtemplate": "BRKNS   <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B", "brief": "Propagate break to next partition", "heading": "BRKN, BRKNS", "para": "Propagate break to next partition. \n\nIf the last active element of the first source predicate is false then set the  destination predicate to all-false. Otherwise leaves the destination and  second source predicate unchanged. Optionally sets the First (N), None (Z), \n!Last (C) condition flags based on the predicate result, and the V flag to  zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pdm>": "Is the name of the second source and destination scalable predicate register, encoded in the \"Pdm\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["BRKN    <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B", "BRKNS   <Pdm>.B, <Pg>/Z, <Pn>.B, <Pdm>.B"]}, {"id": 1080, "asmtemplate": "FNMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point negated fused multiply-add vectors (predicated), writing addend [Zda = -Zda + -Zn * Zm]", "heading": "FNMLA", "para": "Floating-point negated fused multiply-add vectors (predicated), writing addend \n[Zda = -Zda + -Zn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and add to elements of the third source (addend) vector  without intermediate rounding. Destructively place the negated results in the  destination and third source (addend) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FNMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>"]}, {"id": 1056, "asmtemplate": "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>", "brief": "Unsigned fixed-point Convert to Floating-point (vector)", "heading": "UCVTF (vector, fixed-point)", "para": "Unsigned fixed-point Convert to Floating-point (vector). This instruction  converts each element in a vector from fixed-point to floating-point using the  rounding mode that is specified by the FPCR, and writes the result to the  SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["UCVTF  <V><d>, <V><n>, #<fbits>", "UCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"]}, {"id": 342, "asmtemplate": "FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point maximum number with immediate (predicated)", "heading": "FMAXNM (immediate)", "para": "Floating-point maximum number with immediate (predicated). \n\nDetermine the maximum number value of an immediate and each active  floating-point element of the source vector, and destructively place the  results in the corresponding elements of the source vector. The immediate may  take the value +0.0 or +1.0 only. If the element value is NaN then the result  is the immediate. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 1055, "asmtemplate": "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "brief": "Compare vector to 64-bit wide elements", "heading": "CMP<cc> (wide elements)", "para": "Compare vector to 64-bit wide elements. \n\nCompare active integer elements in the first source vector with overlapping  64-bit doubleword elements in the second source vector, and place the boolean  results of the specified comparison in the corresponding elements of the  destination predicate. Inactive elements in the destination predicate register  are set to zero. Sets the First (N), None (Z), !Last (C) condition flags based  on the predicate result, and the V flag to zero. \n\n \n\nThe <cc> symbol specifies one of the standard ARM condition codes: EQ, GE, GT,  HI, HS, LE, LO, LS, LT or NE. \n\nIt has encodings from 10 classes: Equal , Greater than , Greater than or equal \n, Higher , Higher or same , Less than , Less than or equal , Lower , Lower or  same and Not equal", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPLO   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPLS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.D"]}, {"id": 92, "asmtemplate": "FSQRT   <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Floating-point square root (predicated)", "heading": "FSQRT", "para": "Floating-point square root (predicated). \n\nCalculate the square root of each active floating-point element of the source  vector, and place the results in the corresponding elements of the destination  vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FSQRT   <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 987, "asmtemplate": "MADD  <Xd>, <Xn>, <Xm>, <Xa>", "brief": "Multiply-Add", "heading": "MADD", "para": "Multiply-Add multiplies two register values, adds a third register value, and  writes the result to the destination register. \n\nThis instruction is used by the alias MUL.", "explanations": {"<Xm>": "Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xa>": "Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wa>": "Is the 32-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MADD  <Wd>, <Wn>, <Wm>, <Wa>"]}, {"id": 542, "asmtemplate": "LDSMINLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic signed minimum on halfword in memory", "heading": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH", "para": "Atomic signed minimum on halfword in memory atomically loads a 16-bit halfword  from memory, compares it against the value held in a register, and stores the  smaller value back to memory, treating the values as signed numbers. The value  initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDSMINAH and LDSMINALH load from \n  memory with acquire semantics. \n* LDSMINLH and LDSMINALH store to memory with release semantics. \n* LDSMINH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMINH, STSMINLH.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDSMINAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 1088, "asmtemplate": "LDFF1SW {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault signed words to vector (immediate index)", "heading": "LDFF1SW (vector plus immediate)", "para": "Gather load first-fault signed words to vector (immediate index). \n\nGather load with first-faulting behavior of signed words to active elements of  a vector register from memory addresses generated by a vector base plus  immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 1236, "asmtemplate": "UMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>", "brief": "Unsigned minimum with immediate (unpredicated)", "heading": "UMIN (immediate)", "para": "Unsigned minimum with immediate (unpredicated). \n\nDetermine the unsigned minimum of an immediate and each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate is an unsigned 8-bit value in the range 0 to  255, inclusive. This instruction is unpredicated.", "explanations": {"<T><imm>": "Is the unsigned immediate operand, in the range 0 to 255, encoded in the \"imm8\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["UMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>"]}, {"id": 1109, "asmtemplate": "SMADDL<Xd>, <Wn>, <Wm>, XZR", "brief": "Signed Multiply Long", "heading": "SMULL", "para": "Signed Multiply Long multiplies two 32-bit register values, and writes the  result to the 64-bit destination register. \n\nThis is an alias of SMADDL. This means:  \n* The encodings in this description are named to match the encodings of \n  SMADDL. \n* The description of SMADDL gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."}, "encodings": ["SMULL  <Xd>, <Wn>, <Wm>"]}, {"id": 747, "asmtemplate": "CSEL  <Xd>, <Xn>, <Xm>, <cond>", "brief": "Conditional Select", "heading": "CSEL", "para": "If the condition is true, Conditional Select writes the value of the first  source register to the destination register. If the condition is false, it  writes the value of the second source register to the destination register.", "explanations": {"<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CSEL  <Wd>, <Wn>, <Wm>, <cond>"]}, {"id": 50, "asmtemplate": "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]", "brief": "Dot Product unsigned arithmetic (vector, by element)", "heading": "UDOT (by element)", "para": "Dot Product unsigned arithmetic (vector, by element). This instruction  performs the dot product of the four 8-bit elements in each 32-bit element of  the first source register with the four 8-bit elements of an indexed 32-bit  element in the second source register, accumulating the result into the  corresponding 32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<index>": "Is the element index, encoded in the \"H:L\" fields.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"]}, {"id": 246, "asmtemplate": "STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", "brief": "Store Exclusive Register Halfword", "heading": "STXRH", "para": "Store Exclusive Register Halfword stores a halfword from a register to memory  if the PE has exclusive access to the memory address, and returns a status  value of 0 if the store was successful, or of 1 if no store was performed. See  Synchronization and semaphores. The memory access is atomic. \n\nFor information about memory accesses see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:"}, "encodings": ["STXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 487, "asmtemplate": "UQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment vector by multiple of 16-bit predicate constraint element count", "heading": "UQINCH (vector)", "para": "Unsigned saturating increment vector by multiple of 16-bit predicate  constraint element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. The  results are saturated to the 16-bit unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}"]}, {"id": 158, "asmtemplate": "LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Signed Word (unscaled)", "heading": "LDURSW", "para": "Load Register Signed Word (unscaled) calculates an address from a base  register and an immediate offset, loads a signed word from memory,  sign-extends it, and writes it to a register. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDURSW  <Xt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 524, "asmtemplate": "FCVTZS  <Xd>, <Dn>, #<fbits>", "brief": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar)", "heading": "FCVTZS (scalar, fixed-point)", "para": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar).  This instruction converts the floating-point value in the SIMD&FP source  register to a 32-bit or 64-bit fixed-point signed integer using the Round  towards Zero rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<fbits>": "For the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus \"scale\".", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTZS  <Wd>, <Hn>, #<fbits>"]}, {"id": 89, "asmtemplate": "UQXTN{2}<Vd>.<Tb>, <Vn>.<Ta>", "brief": "Unsigned saturating extract Narrow", "heading": "UQXTN, UQXTN2", "para": "Unsigned saturating extract Narrow. This instruction reads each vector element  from the source SIMD&FP register, saturates each value to half the original  width, places the result into a vector, and writes the vector to the  destination SIMD&FP register. All the values in this instruction are unsigned  integer values. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe UQXTN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the UQXTN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"<Va><n>": "Is the number of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["UQXTN  <Vb><d>, <Va><n>", "UQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"]}, {"id": 1245, "asmtemplate": "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Signed Rounding Shift Right and Accumulate (immediate)", "heading": "SRSRA", "para": "Signed Rounding Shift Right and Accumulate (immediate). This instruction reads  each vector element in the source SIMD&FP register, right shifts each result  by an immediate value, and accumulates the final results with the vector  elements of the destination SIMD&FP register. All the values in this  instruction are signed integer values. The results are rounded. For truncated  results, see SSRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SRSRA  <V><d>, <V><n>, #<shift>", "SRSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 379, "asmtemplate": "ADD  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}", "brief": "Add (immediate)", "heading": "ADD (immediate)", "para": "Add immediate (unpredicated). \n\nAdd an unsigned immediate to each element of the source vector, and  destructively place the results in the corresponding elements of the source  vector. This instruction is unpredicated. \n\nThe immediate is an unsigned value in the range 0 to 255, and for element  widths of 16 bits or higher it may also be a positive multiple of 256 in the  range 256 to 65280. \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<uimm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\".", "explanations": {"<imm>": "Is an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field."}, "encodings": ["ADD     <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}"]}, {"id": 734, "asmtemplate": "WFI", "brief": "Wait For Interrupt", "heading": "WFI", "para": "Wait For Interrupt is a hint instruction that indicates that the PE can enter  a low-power state and remain there until a wakeup event occurs. For more  information, see Wait For Interrupt. \n\nAs described in Wait For Interrupt, the execution of a WFI instruction that  would otherwise cause entry to a low-power state can be trapped to a higher  Exception level. See:  \n* Traps to EL1 of EL0 execution of WFE and WFI instructions. \n* Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI \n  instructions. \n* Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.", "explanations": {}, "encodings": ["WFI"]}, {"id": 598, "asmtemplate": "FMLS    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point fused multiply-subtract vectors (predicated), writing addend [Zda = Zda + -Zn * Zm]", "heading": "FMLS (vectors)", "para": "Floating-point fused multiply-subtract vectors (predicated), writing addend \n[Zda = Zda + -Zn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and subtract from elements of the third source (addend)  vector without intermediate rounding. Destructively place the results in the  destination and third source (addend) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FMLS    <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>"]}, {"id": 1010, "asmtemplate": "STTRH  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Store Register Halfword (unprivileged)", "heading": "STTRH", "para": "Store Register Halfword (unprivileged) stores a halfword from a 32-bit  register to memory. The address that is used for the store is calculated from  a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STTRH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 985, "asmtemplate": "LDFF1D  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]", "brief": "Contiguous load first-fault doublewords to vector (scalar index)", "heading": "LDFF1D (scalar plus scalar)", "para": "Contiguous load first-fault doublewords to vector (scalar index). \n\nContiguous load with first-faulting behavior of doublewords to elements of a  vector register from the memory address generated by a 64-bit scalar base and  scalar index which is multiplied by 8 and added to the base address. After  each element access the index value is incremented, but the index register is  not updated. Inactive elements will not not cause a read from Device memory or  signal a fault, and are set to zero in the destination vector.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #3}]"]}, {"id": 128, "asmtemplate": "UQDECP  <Xdn>, <Pm>.<T>", "brief": "Unsigned saturating decrement scalar by count of true predicate elements", "heading": "UQDECP (scalar)", "para": "Unsigned saturating decrement scalar by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to decrement the scalar destination. The result is saturated to the  general-purpose register's unsigned integer range. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["UQDECP  <Wdn>, <Pm>.<T>", "UQDECP  <Xdn>, <Pm>.<T>"]}, {"id": 950, "asmtemplate": "CPY     <Zd>.<T>, <Pg>/M, <R><n|SP>", "brief": "Copy general-purpose register to vector elements (predicated)", "heading": "CPY (scalar)", "para": "Copy general-purpose register to vector elements (predicated). \n\nCopy the general-purpose scalar source register to each active element in the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nThis instruction is used by the alias MOV (scalar, predicated).", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<R><n|SP>": "Is the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."}, "encodings": ["CPY     <Zd>.<T>, <Pg>/M, <R><n|SP>"]}, {"id": 779, "asmtemplate": "SCVTF  <Dd>, <Xn>", "brief": "Signed integer Convert to Floating-point (scalar)", "heading": "SCVTF (scalar, integer)", "para": "Signed integer Convert to Floating-point (scalar). This instruction converts  the signed integer value in the general-purpose source register to a  floating-point value using the rounding mode that is specified by the FPCR,  and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Sd>": "Is the 32-bit name of the SIMD", "": "FP destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Hd>": "Is the 16-bit name of the SIMD", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Dd>": "Is the 64-bit name of the SIMD"}, "encodings": ["SCVTF  <Hd>, <Wn>"]}, {"id": 137, "asmtemplate": "BTI  {<targets>}", "brief": "Branch Target Identification", "heading": "BTI", "para": "Branch Target Identification. A BTI instruction is used to guard against the  execution of instructions which are not the intended target of a branch. \n\nOutside of a guarded memory region, a BTI instruction executes as a NOP.  Within a guarded memory region while PSTATE.BTYPE != 0b00, a BTI instruction  compatible with the current value of PSTATE.BTYPE will not generate a Branch  Target Exception and will allow execution of subsequent instructions within  the memory region. \n\nThe operand <targets> passed to a BTI instruction determines the values of  PSTATE.BTYPE which the BTI instruction is compatible with. \n\nWithin a guarded memory region, while PSTATE.BTYPE \n\n!= 0b00, all instructions will generate a Branch Target \n\nException, other than BRK, BTI, HLT, PACIASP, \n\nand PACIBSP, which may not. See the individual instructions for details.", "explanations": {}, "encodings": ["BTI  {<targets>}"]}, {"id": 138, "asmtemplate": "LDNT1W  {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load non-temporal words to vector (scalar index)", "heading": "LDNT1W (scalar plus scalar)", "para": "Contiguous load non-temporal words to vector (scalar index). \n\nContiguous load non-temporal of words to elements of a vector register from  the memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 4 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LDNT1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 799, "asmtemplate": "RETAB", "brief": "Return from subroutine, with pointer authentication", "heading": "RETAA, RETAB", "para": "Return from subroutine, with pointer authentication. This instruction  authenticates the address that is held in LR, using SP as the modifier and the  specified key, branches to the authenticated address, with a hint that this  instruction is a subroutine return. \n\nKey A is used for RETAA, and key B is used for RETAB. \n\nIf the authentication passes, the PE continues execution at the target of the  branch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to LR.", "explanations": {}, "encodings": ["RETAA"]}, {"id": 1166, "asmtemplate": "FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point reversed subtract from immediate (predicated)", "heading": "FSUBR (immediate)", "para": "Floating-point reversed subtract from immediate (predicated). \n\nReversed subtract from an immediate each active floating-point element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. The immediate may take the value +0.5 or +1.0  only. Inactive elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 751, "asmtemplate": "SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Halving Add", "heading": "SHADD", "para": "Signed Halving Add. This instruction adds corresponding signed integer values  from the two source SIMD&FP registers, shifts each result right one bit,  places the results into a vector, and writes the vector to the destination  SIMD&FP register. \n\nThe results are truncated. For rounded results, see SRHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 583, "asmtemplate": "UUNPKLO <Zd>.<T>, <Zn>.<Tb>", "brief": "Unsigned unpack and extend half of vector", "heading": "UUNPKHI, UUNPKLO", "para": "Unsigned unpack and extend half of vector. \n\nUnpack elements from the lowest or highest half of the source vector and then  zero-extend them to place in elements of twice their size within the  destination vector. This instruction is unpredicated. \n\nIt has encodings from 2 classes: High half and Low half", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["UUNPKHI <Zd>.<T>, <Zn>.<Tb>", "UUNPKLO <Zd>.<T>, <Zn>.<Tb>"]}, {"id": 1100, "asmtemplate": "HVC  #<imm>", "brief": "Hypervisor Call", "heading": "HVC", "para": "Hypervisor Call causes an exception to EL2. Non-secure software executing at  EL1 can use this instruction to call the hypervisor to request a service. \n\nThe HVC instruction is undefined:  \n* At EL0. \n* At EL1 if EL2 is not enabled in the current Security state. \n* When SCR_EL3.HCE is set to 0.  On executing an HVC instruction, the PE records the exception as a Hypervisor  Call exception in ESR_ELx, using the EC value 0x16, and the value of the  immediate argument.", "explanations": {"<imm>": "Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."}, "encodings": ["HVC  #<imm>"]}, {"id": 1051, "asmtemplate": "LD1RW   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast unsigned word to vector", "heading": "LD1RW", "para": "Load and broadcast unsigned word to vector. \n\nLoad a single unsigned word from a memory address generated by a 64-bit scalar  base address plus an immediate offset which is a multiple of 4 in the range 0  to 252. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 252, defaulting to 0, encoded in the \"imm6\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1RW   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 45, "asmtemplate": "SEVL", "brief": "Send Event Local", "heading": "SEVL", "para": "Send Event Local is a hint instruction that causes an event to be signaled  locally without requiring the event to be signaled to other PEs in the  multiprocessor system. It can prime a wait-loop which starts with a WFE  instruction.", "explanations": {}, "encodings": ["SEVL"]}, {"id": 917, "asmtemplate": "ADDP  <V><d>, <Vn>.<T>", "brief": "Add Pair of elements (scalar)", "heading": "ADDP (scalar)", "para": "Add Pair of elements (scalar). This instruction adds two vector elements in  the source SIMD&FP register and writes the scalar result into the destination  SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["ADDP  <V><d>, <Vn>.<T>"]}, {"id": 642, "asmtemplate": "STLRH  <Wt>, [<Xn|SP>{,#0}]", "brief": "Store-Release Register Halfword", "heading": "STLRH", "para": "Store-Release Register Halfword stores a halfword from a 32-bit register to a  memory location. The instruction also has memory ordering semantics as  described in Load-Acquire, Store-Release. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STLRH  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 494, "asmtemplate": "ADDS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Add (shifted register), setting flags", "heading": "ADDS (shifted register)", "para": "Add (shifted register), setting flags, adds a register value and an  optionally-shifted register value, and writes the result to the destination  register. It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMN (shifted register).", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ADDS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 589, "asmtemplate": "LDRSB  <Xt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load Register Signed Byte (immediate)", "heading": "LDRSB (immediate)", "para": "Load Register Signed Byte (immediate) loads a byte from memory, sign-extends  it to either 32 bits or 64 bits, and writes the result to a register. The  address that is used for the load is calculated from a base register and an  immediate offset. For information about memory accesses, see Load/Store  addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDRSB  <Wt>, [<Xn|SP>], #<simm>", "LDRSB  <Wt>, [<Xn|SP>, #<simm>]!", "LDRSB  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 579, "asmtemplate": "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]", "brief": "Gather prefetch bytes (scalar plus vector)", "heading": "PRFB (scalar plus vector)", "para": "Gather prefetch bytes (scalar plus vector). \n\nGather prefetch of bytes from the active memory addresses generated by a  64-bit scalar base plus vector index. The index values are optionally sign or  zero-extended from 32 to 64 bits. Inactive addresses are not prefetched from  memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 3 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset and 64-bit scaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]", "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]", "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Zm>.D]"]}, {"id": 1226, "asmtemplate": "FCMPE  <Dn>, #0.0", "brief": "Floating-point signaling Compare (scalar)", "heading": "FCMPE", "para": "Floating-point signaling Compare (scalar). This instruction compares the two  SIMD&FP source register values, or the first SIMD&FP source register value and  zero. It writes the result to the PSTATE.{N, Z, C, V} flags. \n\nThis instruction raises an Invalid Operation floating-point exception if  either or both of the operands is any type of NaN. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "For the half-precision, zero variant: is the 16-bit name of the SIMD", "<Dn>": "For the double-precision, zero variant: is the 64-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "For the single-precision, zero variant: is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FCMPE  <Hn>, <Hm>"]}, {"id": 652, "asmtemplate": "FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point maximum with immediate (predicated)", "heading": "FMAX (immediate)", "para": "Floating-point maximum with immediate (predicated). \n\nDetermine the maximum of an immediate and each active floating-point element  of the source vector, and destructively place the results in the corresponding  elements of the source vector. The immediate may take the value +0.0 or +1.0  only. If the element value is NaN then the result is NaN. Inactive elements in  the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 1120, "asmtemplate": "CTERMNE <R><n>, <R><m>", "brief": "Compare and terminate loop", "heading": "CTERMEQ, CTERMNE", "para": "Compare and terminate loop. \n\nDetect termination conditions in serialized vector loops. Tests whether the  comparison between the scalar source operands holds true and if not tests the  state of the !Last condition flag (C) which indicates whether the previous  flag-setting predicate instruction selected the last element of the vector  partition. \n\nThe Z and C condition flags are preserved by this instruction. The N and V  condition flags are set as a pair to generate one of the following conditions  for a subsequent conditional instruction: \n\n  \n* GE (N=0 & V=0): continue loop (compare failed and last element not  selected);  \n* LT (N=0 & V=1): terminate loop (last element selected);  \n* LT (N=1 & V=0): terminate loop (compare succeeded); \n\nThe scalar source operands are 32-bit or 64-bit general-purpose registers of  the same size. \n\nIt has encodings from 2 classes: Equal and Not equal", "explanations": {"<m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field."}, "encodings": ["CTERMEQ <R><n>, <R><m>", "CTERMNE <R><n>, <R><m>"]}, {"id": 257, "asmtemplate": "LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D", "brief": "Logical shift right by 64-bit wide elements (predicated)", "heading": "LSR (wide elements, predicated)", "para": "Logical shift right by 64-bit wide elements (predicated). \n\nShift right, inserting zeroes, active elements of the first source vector by  corresponding overlapping 64-bit elements of the second source vector and  destructively place the results in the corresponding elements of the first  source vector. The shift amount is a vector of unsigned 64-bit doubleword  elements in which all bits are significant, and not used modulo the  destination element size. Inactive elements in the destination vector register  remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D"]}, {"id": 361, "asmtemplate": "CNTW    <Xd>{, <pattern>{, MUL #<imm>}}", "brief": "Set scalar to multiple of predicate constraint element count", "heading": "CNTB, CNTD, CNTH, CNTW", "para": "Set scalar to multiple of predicate constraint element count. \n\nDetermines the number of active elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then places the result in the scalar destination. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 4 classes: Byte , Doubleword , Halfword and Word", "explanations": {"<Xd>": "Is the 64-bit name of the destination general-purpose register, encoded in the \"Rd\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["CNTB    <Xd>{, <pattern>{, MUL #<imm>}}", "CNTD    <Xd>{, <pattern>{, MUL #<imm>}}", "CNTH    <Xd>{, <pattern>{, MUL #<imm>}}", "CNTW    <Xd>{, <pattern>{, MUL #<imm>}}"]}, {"id": 462, "asmtemplate": "LDADDLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic add on byte in memory, without return", "heading": "STADDB, STADDLB", "para": "Atomic add on byte in memory, without return, atomically loads an 8-bit byte  from memory, adds the value held in a register to it, and stores the result  back to memory.  \n* STADDB does not have release semantics. \n* STADDLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDADDB, LDADDAB, LDADDALB, LDADDLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDADDB, LDADDAB, LDADDALB, LDADDLB. \n* The description of LDADDB, LDADDAB, LDADDALB, LDADDLB gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STADDB  <Ws>, [<Xn|SP>]"]}, {"id": 1095, "asmtemplate": "SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>", "brief": "System instruction with result", "heading": "SYSL", "para": "System instruction with result. For more information, see Op0 equals 0b01,  cache maintenance, TLB maintenance, and address translation instructions for  the encodings of System instructions.", "explanations": {"<op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Xt>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rt\" field.", "<Cn>": "Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field."}, "encodings": ["SYSL  <Xt>, #<op1>, <Cn>, <Cm>, #<op2>"]}, {"id": 1043, "asmtemplate": "FMMLA   <Zda>.D, <Zn>.D, <Zm>.D", "brief": "Floating-point matrix multiply-accumulate", "heading": "FMMLA", "para": "Floating-point matrix multiply-accumulate. \n\nThe floating-point matrix multiply-accumulate instruction supports  single-precision and double-precision data types in a 2\u00d72 matrix contained in  segments of 128 or 256 bits, respectively. It multiplies the 2\u00d72 matrix in  each segment of the first source vector by the 2\u00d72 matrix in the corresponding  segment of the second source vector. The resulting 2\u00d72 matrix product is then  destructively added to the matrix accumulator held in the corresponding  segment of the addend and destination vector. This is equivalent to performing  a 2-way dot product per destination element. This instruction is unpredicated.  The single-precision variant is vector length agnostic. The double-precision  variant requires that the current vector length is at least 256 bits, and if  the current vector length is not an integer multiple of 256 bits then the  trailing bits are set to zero. \n\nID_AA64ZFR0_EL1.F32MM indicates whether the single-precision variant is  implemented. \n\nID_AA64ZFR0_EL1.F64MM indicates whether the double-precision variant is  implemented. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMMLA   <Zda>.S, <Zn>.S, <Zm>.S", "FMMLA   <Zda>.D, <Zn>.D, <Zm>.D"]}, {"id": 777, "asmtemplate": "SUB<Xd>, XZR, <Xm>{, <shift> #<amount>}", "brief": "Negate (shifted register)", "heading": "NEG (shifted register)", "para": "Negate (shifted register) negates an optionally-shifted register value, and  writes the result to the destination register. \n\nThis is an alias of SUB (shifted register). This means:  \n* The encodings in this description are named to match the encodings of SUB \n  (shifted register). \n* The description of SUB (shifted register) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["NEG  <Wd>, <Wm>{, <shift> #<amount>}"]}, {"id": 794, "asmtemplate": "SEL<Pd>.B, <Pg>, <Pn>.B, <Pd>.B", "brief": "Move predicates (merging)", "heading": "MOV (predicate, predicated, merging)", "para": "Move predicates (merging). \n\nRead active elements from the source predicate and place in the corresponding  elements of the destination predicate. Inactive elements in the destination  predicate register remain unmodified. Does not set the condition flags. \n\nThis is an alias of SEL (predicates). This means:  \n* The encodings in this description are named to match the encodings of SEL \n  (predicates). \n* The description of SEL (predicates) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["MOV     <Pd>.B, <Pg>/M, <Pn>.B"]}, {"id": 1146, "asmtemplate": "LDNF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault signed bytes to vector (immediate index)", "heading": "LDNF1SB", "para": "Contiguous load non-fault signed bytes to vector (immediate index). \n\nContiguous load with non-faulting behavior of signed bytes to elements of a  vector register from the memory address generated by a 64-bit scalar base and  immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDNF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 428, "asmtemplate": "LD1B    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load unsigned bytes to vector (scalar index)", "heading": "LD1B (scalar plus scalar)", "para": "Contiguous load unsigned bytes to vector (scalar index). \n\nContiguous load of unsigned bytes to elements of a vector register from the  memory address generated by a 64-bit scalar base and scalar index which is  added to the base address. After each element access the index value is  incremented, but the index register is not updated. Inactive elements will not  not cause a read from Device memory or signal a fault, and are set to zero in  the destination vector. \n\nIt has encodings from 4 classes: 8-bit element , 16-bit element , 32-bit  element and 64-bit element", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>]", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 329, "asmtemplate": "BFM  <Xd>, <Xn>, #<immr>, #<imms>", "brief": "Bitfield Move", "heading": "BFM", "para": "Bitfield Move is usually accessed via one of its aliases, which are always  preferred for disassembly. \n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of \n(<imms>-<immr>+1) bits starting from bit position <immr> in the source  register to the least significant bits of the destination register. \n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from  the least significant bits of the source register to bit position \n(regsize-<immr>) of the destination register, where regsize is the destination  register size of 32 or 64 bits. \n\nIn both cases the other bits of the destination register remain unchanged. \n\nThis instruction is used by the aliases BFC, BFI, and BFXIL.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imms>": "For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<immr>": "For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["BFM  <Wd>, <Wn>, #<immr>, #<imms>"]}, {"id": 558, "asmtemplate": "LDFF1SH {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault signed halfwords to vector (immediate index)", "heading": "LDFF1SH (vector plus immediate)", "para": "Gather load first-fault signed halfwords to vector (immediate index). \n\nGather load with first-faulting behavior of signed halfwords to active  elements of a vector register from memory addresses generated by a vector base  plus immediate index. The index is a multiple of 2 in the range 0 to 62.  Inactive elements will not cause a read from Device memory or signal faults,  and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 22, "asmtemplate": "FRINTI  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral, using current rounding mode (vector)", "heading": "FRINTI (vector)", "para": "Floating-point Round to Integral, using current rounding mode (vector). This  instruction rounds a vector of floating-point values in the SIMD&FP source  register to integral floating-point values of the same size using the rounding  mode that is determined by the FPCR, and writes the result to the SIMD&FP  destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FRINTI  <Vd>.<T>, <Vn>.<T>", "FRINTI  <Vd>.<T>, <Vn>.<T>"]}, {"id": 306, "asmtemplate": "BFM<Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)", "brief": "Bitfield extract and insert at low end", "heading": "BFXIL", "para": "Bitfield Extract and Insert Low copies a bitfield of <width> bits starting  from bit position <lsb> in the source register to the least significant bits  of the destination register, leaving the other destination bits unchanged. \n\nThis is an alias of BFM. This means:  \n* The encodings in this description are named to match the encodings of BFM. \n* The description of BFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-"}, "encodings": ["BFXIL  <Wd>, <Wn>, #<lsb>, #<width>"]}, {"id": 610, "asmtemplate": "SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S", "brief": "SM3PARTW1", "heading": "SM3PARTW1", "para": "SM3PARTW1 takes three 128-bit vectors from the three source SIMD&FP registers  and returns a 128-bit result in the destination SIMD&FP register. The result  is obtained by a three-way exclusive OR of the elements within the input  vectors with some fixed rotations, see the Operation pseudocode for more  information. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SM3PARTW1  <Vd>.4S, <Vn>.4S, <Vm>.4S"]}, {"id": 195, "asmtemplate": "SHA1H  <Sd>, <Sn>", "brief": "SHA1 fixed rotate", "heading": "SHA1H", "para": "SHA1 fixed rotate.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["SHA1H  <Sd>, <Sn>"]}, {"id": 24, "asmtemplate": "ASRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Reversed arithmetic shift right by vector (predicated)", "heading": "ASRR", "para": "Reversed arithmetic shift right by vector (predicated). \n\nReversed shift right, preserving the sign bit, active elements of the second  source vector by corresponding elements of the first source vector and  destructively place the results in the corresponding elements of the first  source vector. The shift amount operand is a vector of unsigned elements in  which all bits are significant, and not used modulo the element size. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ASRR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1173, "asmtemplate": "LDUR  <Qt>, [<Xn|SP>{, #<simm>}]", "brief": "Load SIMD&FP Register (unscaled offset)", "heading": "LDUR (SIMD&FP)", "para": "Load SIMD&FP Register (unscaled offset). This instruction loads a SIMD&FP  register from memory. The address that is used for the load is calculated from  a base register value and an optional immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register to be transferred, encoded in the \"Rt\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<St>": "Is the 32-bit name of the SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Dt>": "Is the 64-bit name of the SIMD", "<Qt>": "Is the 128-bit name of the SIMD", "<Ht>": "Is the 16-bit name of the SIMD", "<Bt>": "Is the 8-bit name of the SIMD"}, "encodings": ["LDUR  <Bt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 692, "asmtemplate": "LD1R  {<Vt>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load one single-element structure and Replicate to all lanes (of one register)", "heading": "LD1R", "para": "Load one single-element structure and Replicate to all lanes (of one  register). This instruction loads a single-element structure from memory and  replicates the structure to all the lanes of the SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded in the \"Rt\" field.", "<T><Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["LD1R  { <Vt>.<T> }, [<Xn|SP>]", "LD1R  { <Vt>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 360, "asmtemplate": "ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise inclusive OR (vector, register)", "heading": "ORR (vector, register)", "para": "Bitwise inclusive OR (vector, register). This instruction performs a bitwise  OR between the two source SIMD&FP registers, and writes the result to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias MOV (vector).", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["ORR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 843, "asmtemplate": "FACGE<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point absolute compare less than or equal", "heading": "FACLE", "para": "Floating-point absolute compare less than or equal. \n\nCompare active absolute values of floating-point elements in the first source  vector being less than or equal to corresponding absolute values of elements  in the second source vector, and place the boolean results of the comparison  in the corresponding elements of the destination predicate. Inactive elements  in the destination predicate register are set to zero. Does not set the  condition flags. \n\nThis is a pseudo-instruction of FAC<cc>. This means:  \n* The encodings in this description are named to match the encodings of \n  FAC<cc>. \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of FAC<cc> gives the operational pseudocode for this \n  instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["FACLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 1210, "asmtemplate": "FRINTN  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral, to nearest with ties to even (vector)", "heading": "FRINTN (vector)", "para": "Floating-point Round to Integral, to nearest with ties to even (vector). This  instruction rounds a vector of floating-point values in the SIMD&FP source  register to integral floating-point values of the same size using the Round to  Nearest rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FRINTN  <Vd>.<T>, <Vn>.<T>", "FRINTN  <Vd>.<T>, <Vn>.<T>"]}, {"id": 838, "asmtemplate": "FCVTMS  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector)", "heading": "FCVTMS (vector)", "para": "Floating-point Convert to Signed integer, rounding toward Minus infinity \n(vector). This instruction converts a scalar or each element in a vector from  a floating-point value to a signed integer value using the Round towards Minus  Infinity rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTMS  <Hd>, <Hn>", "FCVTMS  <V><d>, <V><n>", "FCVTMS  <Vd>.<T>, <Vn>.<T>", "FCVTMS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 1208, "asmtemplate": "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point fused Multiply-Add to accumulator (vector)", "heading": "FMLA (vector)", "para": "Floating-point fused Multiply-Add to accumulator (vector). This instruction  multiplies corresponding floating-point values in the vectors in the two  source SIMD&FP registers, adds the product to the corresponding vector element  of the destination SIMD&FP register, and writes the result to the destination  SIMD&FP register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 597, "asmtemplate": "LD1RH   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast unsigned halfword to vector", "heading": "LD1RH", "para": "Load and broadcast unsigned halfword to vector. \n\nLoad a single unsigned halfword from a memory address generated by a 64-bit  scalar base address plus an immediate offset which is a multiple of 2 in the  range 0 to 126. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 126, defaulting to 0, encoded in the \"imm6\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD1RH   { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 504, "asmtemplate": "ST1D    {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous store doublewords from vector (scalar index)", "heading": "ST1D (scalar plus scalar)", "para": "Contiguous store doublewords from vector (scalar index). \n\nContiguous store of doublewords from elements of a vector register to the  memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 8 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements are not written to memory.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 811, "asmtemplate": "FMSUB  <Dd>, <Dn>, <Dm>, <Da>", "brief": "Floating-point Fused Multiply-Subtract (scalar)", "heading": "FMSUB", "para": "Floating-point Fused Multiply-Subtract (scalar). This instruction multiplies  the values of the first two SIMD&FP source registers, negates the product,  adds that to the value of the third SIMD&FP source register, and writes the  result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register holding the minuend, encoded in the \"Ra\" field.", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Da>": "Is the 64-bit name of the third SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Ha>": "Is the 16-bit name of the third SIMD", "<Sa>": "Is the 32-bit name of the third SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMSUB  <Hd>, <Hn>, <Hm>, <Ha>"]}, {"id": 679, "asmtemplate": "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Compare unsigned Higher (vector)", "heading": "CMHI (register)", "para": "Compare unsigned Higher (vector). This instruction compares each vector  element in the first source SIMD&FP register with the corresponding vector  element in the second source SIMD&FP register and if the first unsigned  integer value is greater than the second unsigned integer value sets every bit  of the corresponding vector element in the destination SIMD&FP register to  one, otherwise sets every bit of the corresponding vector element in the  destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["CMHI  <V><d>, <V><n>, <V><m>", "CMHI  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 983, "asmtemplate": "PACDZA  <Xd>", "brief": "Pointer Authentication Code for Data address, using key A", "heading": "PACDA, PACDZA", "para": "Pointer Authentication Code for Data address, using key A. This instruction  computes and inserts a pointer authentication code for a data address, using a  modifier and key A. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACDA. \n* The value zero, for PACDZA.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["PACDA  <Xd>, <Xn|SP>"]}, {"id": 525, "asmtemplate": "PTEST   <Pg>, <Pn>.B", "brief": "Set condition flags for predicate", "heading": "PTEST", "para": "Set condition flags for predicate. \n\nSets the First (N), None (Z), !Last (C) condition flags based on the predicate  source register, and the V flag to zero.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["PTEST   <Pg>, <Pn>.B"]}, {"id": 6, "asmtemplate": "LDURSB  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Signed Byte (unscaled)", "heading": "LDURSB", "para": "Load Register Signed Byte (unscaled) calculates an address from a base  register and an immediate offset, loads a signed byte from memory,  sign-extends it, and writes it to a register. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDURSB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 1178, "asmtemplate": "DCPS1  {#<imm>}", "brief": "Debug Change PE State to EL1.", "heading": "DCPS1", "para": "Debug Change PE State to EL1, when executed in Debug state:  \n* If executed at EL0 changes the current Exception level and SP to EL1 using \n  SP_EL1. \n* Otherwise, if executed at ELx, selects SP_ELx.  The target exception level of a DCPS1 instruction is:  \n* EL1 if the instruction is executed at EL0. \n* Otherwise, the Exception level at which the instruction is executed.  When the target Exception level of a DCPS1 instruction is ELx, on executing  this instruction:  \n* ELR_ELx becomes unknown. \n* SPSR_ELx becomes unknown. \n* ESR_ELx becomes unknown. \n* DLR_EL0 and DSPSR_EL0 become unknown. \n* The endianness is set according to SCTLR_ELx.EE.  This instruction is undefined at EL0 in Non-secure state if EL2 is implemented  and HCR_EL2.TGE == 1. \n\nThis instruction is always undefined in Non-debug state. \n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "explanations": {"<imm>": "Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."}, "encodings": ["DCPS1  {#<imm>}"]}, {"id": 880, "asmtemplate": "LDNT1H  {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load non-temporal halfwords to vector (scalar index)", "heading": "LDNT1H (scalar plus scalar)", "para": "Contiguous load non-temporal halfwords to vector (scalar index). \n\nContiguous load non-temporal of halfwords to elements of a vector register  from the memory address generated by a 64-bit scalar base and scalar index  which is multiplied by 2 and added to the base address. After each element  access the index value is incremented, but the index register is not updated.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LDNT1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 455, "asmtemplate": "FRINT32X  <Dd>, <Dn>", "brief": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar)", "heading": "FRINT32X (scalar)", "para": "Floating-point Round to 32-bit Integer, using current rounding mode (scalar).  This instruction rounds a floating-point value in the SIMD&FP source register  to an integral floating-point value that fits into a 32-bit integer size using  the rounding mode that is determined by the FPCR, and writes the result to the  SIMD&FP destination register. \n\nA zero input returns a zero result with the same sign. When the result value  is not numerically equal to the input value, an Inexact exception is raised.  When the input is infinite, NaN or out-of-range, the instruction returns {for  the corresponding result value} the most negative integer representable in the  destination size, and an Invalid Operation floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Sd>": "Is the 32-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FRINT32X  <Sd>, <Sn>"]}, {"id": 647, "asmtemplate": "CLZ     <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Count leading zero bits (predicated)", "heading": "CLZ", "para": "Count Leading Zeros counts the number of binary zero bits before the first  binary one bit in the value of the source register, and writes the result to  the destination register.", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["CLZ  <Wd>, <Wn>"]}, {"id": 943, "asmtemplate": "STNT1D  {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store non-temporal doublewords from vector (immediate index)", "heading": "STNT1D (scalar plus immediate)", "para": "Contiguous store non-temporal doublewords from vector (immediate index). \n\nContiguous store non-temporal of doublewords from elements of a vector  register to the memory address generated by a 64-bit scalar base and immediate  index in the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["STNT1D  { <Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1169, "asmtemplate": "INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]", "brief": "Insert vector element from another vector element", "heading": "INS (element)", "para": "Insert vector element from another vector element. This instruction copies the  vector element of the source SIMD&FP register to the specified vector element  of the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP  register without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias MOV (element).", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Ts><index1><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["INS  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"]}, {"id": 1026, "asmtemplate": "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Compare bitwise Equal (vector)", "heading": "CMEQ (register)", "para": "Compare bitwise Equal (vector). This instruction compares each vector element  from the first source SIMD&FP register with the corresponding vector element  from the second source SIMD&FP register, and if the comparison is equal sets  every bit of the corresponding vector element in the destination SIMD&FP  register to one, otherwise sets every bit of the corresponding vector element  in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["CMEQ  <V><d>, <V><n>, <V><m>", "CMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 875, "asmtemplate": "DUPM<Zd>.<T>, #<const>", "brief": "Move logical bitmask immediate to vector (unpredicated)", "heading": "MOV (bitmask immediate)", "para": "Move (bitmask immediate) writes a bitmask immediate value to a register. \n\nThis is an alias of ORR (immediate). This means:  \n* The encodings in this description are named to match the encodings of ORR \n  (immediate). \n* The description of ORR (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<T><const>": "Is a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOV  <Wd|WSP>, #<imm>"]}, {"id": 1113, "asmtemplate": "LDARB  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Register Byte", "heading": "LDARB", "para": "Load-Acquire Register Byte derives an address from a base register value,  loads a byte from memory, zero-extends it and writes it to a register. The  instruction also has memory ordering semantics as described in Load-Acquire,  Store-Release. For information about memory accesses, see Load/Store  addressing modes. \n\nFor this instruction, if the destination is WZR/XZR, it is impossible for  software to observe the presence of the acquire semantic other than its effect  on the arrival at endpoints.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDARB  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1133, "asmtemplate": "ST2D    {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store two-doubleword structures from two vectors (immediate index)", "heading": "ST2D (scalar plus immediate)", "para": "Contiguous store two-doubleword structures from two vectors (immediate index). \n\nContiguous store two-doubleword structures, each from the same element number  in two vector registers to the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 2 in the range -16 to 14  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive doublewords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 56, "asmtemplate": "FMIN  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Minimum (scalar)", "heading": "FMIN (scalar)", "para": "Floating-point Minimum (scalar). This instruction compares the first and  second source SIMD&FP register values, and writes the smaller of the two  floating-point values to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Hm>": "Is the 16-bit name of the second SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Hd>": "Is the 16-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMIN  <Hd>, <Hn>, <Hm>"]}, {"id": 587, "asmtemplate": "UQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}", "brief": "Unsigned saturating add immediate (unpredicated)", "heading": "UQADD (immediate)", "para": "Unsigned saturating add immediate (unpredicated). \n\nUnsigned saturating add of an unsigned immediate to each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. Each result element is saturated to the N-bit element's  unsigned integer range 0 to (2N)-1. This instruction is unpredicated. \n\nThe immediate is an unsigned value in the range 0 to 255, and for element  widths of 16 bits or higher it may also be a positive multiple of 256 in the  range 256 to 65280. \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<uimm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\".", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><imm>": "Is an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field."}, "encodings": ["UQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}"]}, {"id": 873, "asmtemplate": "UBFM<Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)", "brief": "Unsigned Bitfield Extract", "heading": "UBFX", "para": "Unsigned Bitfield Extract copies a bitfield of <width> bits starting from bit  position <lsb> in the source register to the least significant bits of the  destination register, and sets destination bits above the bitfield to zero. \n\nThis is an alias of UBFM. This means:  \n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-"}, "encodings": ["UBFX  <Wd>, <Wn>, #<lsb>, #<width>"]}, {"id": 11, "asmtemplate": "RDFFRS  <Pd>.B, <Pg>/Z", "brief": "Return predicate of succesfully loaded elements", "heading": "RDFFR, RDFFRS (predicated)", "para": "Return predicate of succesfully loaded elements. \n\nRead the first-fault register (FFR) and place active elements in the  corresponding elements of the destination predicate. Inactive elements in the  destination predicate register are set to zero. Optionally sets the First (N),  None (Z), !Last (C) condition flags based on the predicate result, and the V  flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["RDFFR   <Pd>.B, <Pg>/Z", "RDFFRS  <Pd>.B, <Pg>/Z"]}, {"id": 899, "asmtemplate": "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Maximum (vector)", "heading": "FMAX (vector)", "para": "Floating-point Maximum (vector). This instruction compares corresponding  vector elements in the two source SIMD&FP registers, places the larger of each  of the two floating-point values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 191, "asmtemplate": "SDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Signed reversed divide (predicated)", "heading": "SDIVR", "para": "Signed reversed divide (predicated). \n\nSigned reversed divide active elements of the second source vector by  corresponding elements of the first source vector and destructively place the  quotient in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 330, "asmtemplate": "SYS #3, C7, C3, #4, <Xt>", "brief": "Control Flow Prediction Restriction by Context", "heading": "CFP", "para": "Control Flow Prediction Restriction by Context prevents control flow  predictions that predict execution addresses, based on information gathered  from earlier execution within a particular execution context, from allowing  later speculative execution within that context to be observable through  side-channels. \n\nFor more information, see CFP RCTX, Control Flow Prediction Restriction by  Context. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."}, "encodings": ["CFP  RCTX, <Xt>"]}, {"id": 1258, "asmtemplate": "LDSMAXL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic signed maximum on word or doubleword in memory", "heading": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL", "para": "Atomic signed maximum on word or doubleword in memory atomically loads a  32-bit word or 64-bit doubleword from memory, compares it against the value  held in a register, and stores the larger value back to memory, treating the  values as signed numbers. The value initially loaded from memory is returned  in the destination register.  \n* If the destination register is not one of WZR or XZR, LDSMAXA and LDSMAXAL \n  load from memory with acquire semantics. \n* LDSMAXL and LDSMAXAL store to memory with release semantics. \n* LDSMAX has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMAX, STSMAXL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDSMAX  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 471, "asmtemplate": "LD1ROB  {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate thirty-two bytes (immediate index)", "heading": "LD1ROB (scalar plus immediate)", "para": "Contiguous load and replicate thirty-two bytes (immediate index). \n\nLoad thirty-two contiguous bytes to elements of a 256-bit (octaword) vector  from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 32 in the range -256 to +224 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first thirty-two predicate elements are used and higher numbered  predicate elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 32 in the range -256 to 224, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1ROB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 1165, "asmtemplate": "SBC  <Xd>, <Xn>, <Xm>", "brief": "Subtract with Carry", "heading": "SBC", "para": "Subtract with Carry subtracts a register value and the value of NOT (Carry  flag) from a register value, and writes the result to the destination  register. \n\nThis instruction is used by the alias NGC.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SBC  <Wd>, <Wn>, <Wm>"]}, {"id": 297, "asmtemplate": "SQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement scalar by multiple of 32-bit predicate constraint element count", "heading": "SQDECW (scalar)", "para": "Signed saturating decrement scalar by multiple of 32-bit predicate constraint  element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECW  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 178, "asmtemplate": "LDNP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", "brief": "Load Pair of SIMD&FP registers, with Non-temporal hint", "heading": "LDNP (SIMD&FP)", "para": "Load Pair of SIMD&FP registers, with Non-temporal hint. This instruction loads  a pair of SIMD&FP registers from memory, issuing a hint to the memory system  that the access is non-temporal. The address that is used for the load is  calculated from a base register value and an optional immediate offset. \n\nFor information about non-temporal pair instructions, see Load/Store SIMD and  Floating-point Non-temporal pair. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "/16.", "<St1>": "Is the 32-bit name of the first SIMD", "<Dt1>": "Is the 64-bit name of the first SIMD", "<Qt1>": "Is the 128-bit name of the first SIMD", "<imm>": "For the 128-bit variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as ", "<St2>": "Is the 32-bit name of the second SIMD", "<Qt2>": "Is the 128-bit name of the second SIMD", "<Dt2>": "Is the 64-bit name of the second SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDNP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 1124, "asmtemplate": "SSHLL{2}<Vd>.<Ta>, <Vn>.<Tb>, #0", "brief": "Signed extend Long", "heading": "SXTL, SXTL2", "para": "Signed extend Long. This instruction duplicates each vector element in the  lower or upper half of the source SIMD&FP register into a vector, and writes  the vector to the destination SIMD&FP register. The destination vector  elements are twice as long as the source vector elements. All the values in  this instruction are signed integer values. \n\nThe SXTL instruction extracts the source vector from the lower half of the  source register, while the SXTL2 instruction extracts the source vector from  the upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of SSHLL, SSHLL2. This means:  \n* The encodings in this description are named to match the encodings of SSHLL, \n  SSHLL2. \n* The description of SSHLL, SSHLL2 gives the operational pseudocode for this \n  instruction.", "explanations": {"<Ta><Vn>": "Is the name of the SIMD", "2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["SXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 220, "asmtemplate": "LDSETLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic bit set on halfword in memory, without return", "heading": "STSETH, STSETLH", "para": "Atomic bit set on halfword in memory, without return, atomically loads a  16-bit halfword from memory, performs a bitwise OR with the value held in a  register on it, and stores the result back to memory.  \n* STSETH does not have release semantics. \n* STSETLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSETH, LDSETAH, LDSETALH, LDSETLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSETH, LDSETAH, LDSETALH, LDSETLH. \n* The description of LDSETH, LDSETAH, LDSETALH, LDSETLH gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSETH  <Ws>, [<Xn|SP>]"]}, {"id": 218, "asmtemplate": "FCVTNU  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector)", "heading": "FCVTNU (vector)", "para": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to  even (vector). This instruction converts a scalar or each element in a vector  from a floating-point value to an unsigned integer value using the Round to  Nearest rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTNU  <Hd>, <Hn>", "FCVTNU  <V><d>, <V><n>", "FCVTNU  <Vd>.<T>, <Vn>.<T>", "FCVTNU  <Vd>.<T>, <Vn>.<T>"]}, {"id": 204, "asmtemplate": "NANDS   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise NAND predicates", "heading": "NAND, NANDS", "para": "Bitwise NAND predicates. \n\nBitwise NAND active elements of the second source predicate with corresponding  elements of the first source predicate and place the results in the  corresponding elements of the destination predicate. Inactive elements in the  destination predicate register are set to zero. Optionally sets the First (N),  None (Z), !Last (C) condition flags based on the predicate result, and the V  flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["NAND    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "NANDS   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 572, "asmtemplate": "ERET", "brief": "Exception Return", "heading": "ERET", "para": "Exception Return using the ELR and SPSR for the current Exception level. When  executed, the PE restores PSTATE from the SPSR, and branches to the address  held in the ELR. \n\nThe PE checks the SPSR for the current Exception level for an illegal return  event. See Illegal return events from AArch64 state. \n\nERET is undefined at EL0.", "explanations": {}, "encodings": ["ERET"]}, {"id": 905, "asmtemplate": "CSINV<Xd>, XZR, XZR, invert(<cond>)", "brief": "Conditional Set Mask", "heading": "CSETM", "para": "Conditional Set Mask sets all bits of the destination register to 1 if the  condition is TRUE, and otherwise sets all bits to 0. \n\nThis is an alias of CSINV. This means:  \n* The encodings in this description are named to match the encodings of CSINV. \n* The description of CSINV gives the operational pseudocode for this \n  instruction.", "explanations": {"<cond>": "Is one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CSETM  <Wd>, <cond>"]}, {"id": 925, "asmtemplate": "UQINCP  <Xdn>, <Pm>.<T>", "brief": "Unsigned saturating increment scalar by count of true predicate elements", "heading": "UQINCP (scalar)", "para": "Unsigned saturating increment scalar by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to increment the scalar destination. The result is saturated to the  general-purpose register's unsigned integer range. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["UQINCP  <Wdn>, <Pm>.<T>", "UQINCP  <Xdn>, <Pm>.<T>"]}, {"id": 258, "asmtemplate": "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point minimum (vector)", "heading": "FMIN (vector)", "para": "Floating-point minimum (vector). This instruction compares corresponding  elements in the vectors in the two source SIMD&FP registers, places the  smaller of each of the two floating-point values into a vector, and writes the  vector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1072, "asmtemplate": "LD2B    {<Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load two-byte structures to two vectors (immediate index)", "heading": "LD2B (scalar plus immediate)", "para": "Contiguous load two-byte structures to two vectors (immediate index). \n\nContiguous load two-byte structures, each to the same element number in two  vector registers from the memory address generated by a 64-bit scalar base and  an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive bytes in memory which  make up each structure. Inactive elements will not cause a read from Device  memory or signal a fault, and the corresponding element is set to zero in each  of the two destination vector registers.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD2B    { <Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1235, "asmtemplate": "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned saturating Rounding Shift Left (register)", "heading": "UQRSHL", "para": "Unsigned saturating Rounding Shift Left (register). This instruction takes  each vector element of the first source SIMD&FP register, shifts the vector  element by a value from the least significant byte of the corresponding vector  element of the second source SIMD&FP register, places the results into a  vector, and writes the vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it  is a right shift. The results are rounded. For truncated results, see UQSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["UQRSHL  <V><d>, <V><n>, <V><m>", "UQRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 629, "asmtemplate": "SSUBW{2}<Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", "brief": "Signed Subtract Wide", "heading": "SSUBW, SSUBW2", "para": "Signed Subtract Wide. This instruction subtracts each vector element in the  lower or upper half of the second source SIMD&FP register from the  corresponding vector element in the first source SIMD&FP register, places the  result in a vector, and writes the vector to the SIMD&FP destination register.  All the values in this instruction are signed integer values. \n\nThe SSUBW instruction extracts the second source vector from the lower half of  the second source register, while the SSUBW2 instruction extracts the second  source vector from the upper half of the second source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SSUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"]}, {"id": 113, "asmtemplate": "LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault signed words to vector (vector index)", "heading": "LDFF1SW (scalar plus vector)", "para": "Gather load first-fault signed words to vector (vector index). \n\nGather load with first-faulting behavior of signed words to active elements of  a vector register from memory addresses generated by a 64-bit scalar base plus  vector index. The index values are optionally first sign or zero-extended from  32 to 64 bits and then optionally multiplied by 4. Inactive elements will not  cause a read from Device memory or signal faults, and are set to zero in the  destination vector. \n\nIt has encodings from 4 classes: 32-bit unpacked scaled offset , 32-bit  unpacked unscaled offset , 64-bit scaled offset and 64-bit unscaled offset", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]", "LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 500, "asmtemplate": "WFE", "brief": "Wait For Event", "heading": "WFE", "para": "Wait For Event is a hint instruction that indicates that the PE can enter a  low-power state and remain there until a wakeup event occurs. Wakeup events  include the event signaled as a result of executing the SEV instruction on any  PE in the multiprocessor system. For more information, see Wait For Event  mechanism and Send event. \n\nAs described in Wait For Event mechanism and Send event, the execution of a  WFE instruction that would otherwise cause entry to a low-power state can be  trapped to a higher Exception level. See:  \n* Traps to EL1 of EL0 execution of WFE and WFI instructions. \n* Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI \n  instructions. \n* Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.", "explanations": {}, "encodings": ["WFE"]}, {"id": 146, "asmtemplate": "EOR  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise Exclusive OR (shifted register)", "heading": "EOR (shifted register)", "para": "Bitwise Exclusive OR (shifted register) performs a bitwise Exclusive OR of a  register value and an optionally-shifted register value, and writes the result  to the destination register.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["EOR  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 891, "asmtemplate": "ST4W    {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store four-word structures from four vectors (immediate index)", "heading": "ST4W (scalar plus immediate)", "para": "Contiguous store four-word structures from four vectors (immediate index). \n\nContiguous store four-word structures, each from the same element number in  four vector registers to the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 4 in the range -32 to 28 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive words in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 363, "asmtemplate": "ADDVL   <Xd|SP>, <Xn|SP>, #<imm>", "brief": "Add multiple of vector register size to scalar register", "heading": "ADDVL", "para": "Add multiple of vector register size to scalar register. \n\nAdd the current vector register size in bytes multiplied by an immediate in  the range -32 to 31 to the 64-bit source general-purpose register or current  stack pointer, and place the result in the 64-bit destination general-purpose  register or current stack pointer.", "explanations": {"<imm>": "Is the signed immediate operand, in the range -32 to 31, encoded in the \"imm6\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["ADDVL   <Xd|SP>, <Xn|SP>, #<imm>"]}, {"id": 913, "asmtemplate": "FMLA    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]", "brief": "Floating-point fused multiply-add by indexed elements (Zda = Zda + Zn * Zm[indexed])", "heading": "FMLA (indexed)", "para": "Floating-point fused multiply-add by indexed elements (Zda = Zda + Zn *  Zm[indexed]). \n\nMultiply all floating-point elements within each 128-bit segment of the first  source vector by the specified element in the corresponding second source  vector segment. The products are then destructively added without intermediate  rounding to the corresponding elements of the addend and destination vector. \n\nThe elements within the second source vector are specified using an immediate  index which selects the same element position within each 128-bit vector  segment. The index range is from 0 to one less than the number of elements per  128-bit segment, encoded in 1 to 3 bits depending on the size of the element.  This instruction is unpredicated. \n\nIt has encodings from 3 classes: Half-precision , Single-precision and  Double-precision", "explanations": {"<imm>": "For the double-precision variant: is the immediate index, in the range 0 to 1, encoded in the \"i1\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "For the double-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["FMLA    <Zda>.H, <Zn>.H, <Zm>.H[<imm>]", "FMLA    <Zda>.S, <Zn>.S, <Zm>.S[<imm>]", "FMLA    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]"]}, {"id": 964, "asmtemplate": "SHRN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Shift Right Narrow (immediate)", "heading": "SHRN, SHRN2", "para": "Shift Right Narrow (immediate). This instruction reads each unsigned integer  value from the source SIMD&FP register, right shifts each result by an  immediate value, puts the final result into a vector, and writes the vector to  the lower or upper half of the destination SIMD&FP register. The destination  vector elements are half as long as the source vector elements. The results  are truncated. For rounded results, see RSHRN. \n\nThe RSHRN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the RSHRN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Tb><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD"}, "encodings": ["SHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 1119, "asmtemplate": "LSL     <Zd>.<T>, <Zn>.<T>, #<const>", "brief": "Logical shift left by immediate (unpredicated)", "heading": "LSL (immediate, unpredicated)", "para": "Logical shift left by immediate (unpredicated). \n\nShift left by immediate each element of the source vector, and place the  results in the corresponding elements of the destination vector. The immediate  shift amount is an unsigned value in the range 0 to number of bits per element  minus 1. This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<const>": "Is the immediate shift amount, in the range 0 to number of bits per element minus 1, encoded in \"tsz:imm3\".", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["LSL     <Zd>.<T>, <Zn>.<T>, #<const>"]}, {"id": 449, "asmtemplate": "SQDMLAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Signed saturating Doubling Multiply-Add Long (by element)", "heading": "SQDMLAL, SQDMLAL2 (by element)", "para": "Signed saturating Doubling Multiply-Add Long (by element). This instruction  multiplies each vector element in the lower or upper half of the first source  SIMD&FP register by the specified vector element of the second source SIMD&FP  register, doubles the results, and accumulates the final results with the  vector elements of the destination SIMD&FP register. The destination vector  elements are twice as long as the elements that are multiplied. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLAL instruction extracts vector elements from the lower half of the  first source register, while the SQDMLAL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Vb><n>": "Is the number of the first SIMD", "<Tb><Va><d>": "Is the number of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SQDMLAL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 966, "asmtemplate": "LDSMINL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic signed minimum on word or doubleword in memory, without return", "heading": "STSMIN, STSMINL", "para": "Atomic signed minimum on word or doubleword in memory, without return,  atomically loads a 32-bit word or 64-bit doubleword from memory, compares it  against the value held in a register, and stores the smaller value back to  memory, treating the values as signed numbers.  \n* STSMIN does not have release semantics. \n* STSMINL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMIN, LDSMINA, LDSMINAL, LDSMINL. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSMIN, LDSMINA, LDSMINAL, LDSMINL. \n* The description of LDSMIN, LDSMINA, LDSMINAL, LDSMINL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSMIN  <Ws>, [<Xn|SP>]"]}, {"id": 705, "asmtemplate": "LD1SB   {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load signed bytes to vector (vector index)", "heading": "LD1SB (scalar plus vector)", "para": "Gather load signed bytes to vector (vector index). \n\nGather load of signed bytes to active elements of a vector register from  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally sign or zero-extended from 32 to 64 bits. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector. \n\nIt has encodings from 3 classes: 32-bit unpacked unscaled offset , 32-bit  unscaled offset and 64-bit unscaled offset", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 609, "asmtemplate": "UDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]", "brief": "Unsigned integer indexed dot product", "heading": "UDOT (indexed)", "para": "Unsigned integer indexed dot product. \n\nThe unsigned integer indexed dot product instruction computes the dot product  of a group of four unsigned 8-bit or 16-bit integer values held in each 32-bit  or 64-bit element of the first source vector multiplied by a group of four  unsigned 8-bit or 16-bit integer values in an indexed 32-bit or 64-bit element  of the second source vector, and then destructively adds the widened dot  product to the corresponding 32-bit or 64-bit element of the destination  vector. \n\nThe groups within the second source vector are specified using an immediate  index which selects the same group position within each 128-bit vector  segment. The index range is from 0 to one less than the number of groups per  128-bit segment, encoded in 1 to 2 bits depending on the size of the group.  This instruction is unpredicated. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<imm>": "For the 64-bit variant: is the immediate index of a quadtuplet of four 16-bit elements within each 128-bit vector segment, in the range 0 to 1, encoded in the \"i1\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "For the 64-bit variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["UDOT    <Zda>.S, <Zn>.B, <Zm>.B[<imm>]", "UDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]"]}, {"id": 333, "asmtemplate": "ST3W    {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store three-word structures from three vectors (immediate index)", "heading": "ST3W (scalar plus immediate)", "para": "Contiguous store three-word structures from three vectors (immediate index). \n\nContiguous store three-word structures, each from the same element number in  three vector registers to the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 3 in the range -24 to 21 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive words in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32."}, "encodings": ["ST3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 432, "asmtemplate": "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0", "brief": "Floating-point Compare Less than or Equal to zero (vector)", "heading": "FCMLE (zero)", "para": "Floating-point Compare Less than or Equal to zero (vector). This instruction  reads each floating-point value in the source SIMD&FP register and if the  value is less than or equal to zero sets every bit of the corresponding vector  element in the destination SIMD&FP register to one, otherwise sets every bit  of the corresponding vector element in the destination SIMD&FP register to  zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCMLE  <Hd>, <Hn>, #0.0", "FCMLE  <V><d>, <V><n>, #0.0", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0", "FCMLE  <Vd>.<T>, <Vn>.<T>, #0.0"]}, {"id": 422, "asmtemplate": "SUQADD  <Vd>.<T>, <Vn>.<T>", "brief": "Signed saturating Accumulate of Unsigned value", "heading": "SUQADD", "para": "Signed saturating Accumulate of Unsigned value. This instruction adds the  unsigned integer values of the vector elements in the source SIMD&FP register  to corresponding signed integer values of the vector elements in the  destination SIMD&FP register, and writes the resulting signed integer values  to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SUQADD  <V><d>, <V><n>", "SUQADD  <Vd>.<T>, <Vn>.<T>"]}, {"id": 359, "asmtemplate": "LD3  {<Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Load single 3-element structure to one lane of three registers)", "heading": "LD3 (single structure)", "para": "Load single 3-element structure to one lane of three registers). This  instruction loads a 3-element structure from memory and writes the result to  the corresponding elements of the three SIMD&FP registers without affecting  the other bits of the registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "\".", "<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]", "LD3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3"]}, {"id": 1115, "asmtemplate": "EXTR<Xd>, <Xs>, <Xs>, #<shift>", "brief": "Rotate right (immediate)", "heading": "ROR (immediate)", "para": "Rotate right (immediate) provides the value of the contents of a register  rotated by a variable number of bits. The bits that are rotated off the right  end are inserted into the vacated bit positions on the left. \n\nThis is an alias of EXTR. This means:  \n* The encodings in this description are named to match the encodings of EXTR. \n* The description of EXTR gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xs>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Ws>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the amount by which to rotate, in the range 0 to 63, encoded in the \"imms\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ROR  <Wd>, <Ws>, #<shift>"]}, {"id": 263, "asmtemplate": "FCVTL{2}<Vd>.<Ta>, <Vn>.<Tb>", "brief": "Floating-point Convert to higher precision Long (vector)", "heading": "FCVTL, FCVTL2", "para": "Floating-point Convert to higher precision Long (vector). This instruction  reads each element in a vector in the SIMD&FP source register, converts each  value to double the precision of the source element using the rounding mode  that is determined by the FPCR, and writes each result to the equivalent  element of the vector in the SIMD&FP destination register. \n\nWhere the operation lengthens a 64-bit vector to a 128-bit vector, the FCVTL2  variant operates on the elements in the top 64 bits of the source register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FCVTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 117, "asmtemplate": "SMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Signed multiply returning high half (predicated)", "heading": "SMULH", "para": "Signed multiply returning high half (predicated). \n\nWidening multiply signed integer values in active elements of the first source  vector by corresponding elements of the second source vector and destructively  place the high half of the result in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SMULH   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 46, "asmtemplate": "CPY     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}", "brief": "Copy signed integer immediate to vector elements (zeroing)", "heading": "CPY (immediate, zeroing)", "para": "Copy signed integer immediate to vector elements (zeroing). \n\nCopy a signed integer immediate to each active element in the destination  vector. Inactive elements in the destination vector register are set to zero. \n\nThe immediate operand is a signed value in the range -128 to +127, and for  element widths of 16 bits or higher it may also be a signed multiple of 256 in  the range -32768 to +32512 (excluding 0). \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<simm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\". \n\nThis instruction is used by the alias MOV (immediate, predicated, zeroing).", "explanations": {"<imm>": "Is a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["CPY     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}"]}, {"id": 445, "asmtemplate": "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned saturating Add", "heading": "UQADD", "para": "Unsigned saturating Add. This instruction adds the values of corresponding  elements of the two source SIMD&FP registers, places the results into a  vector, and writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["UQADD  <V><d>, <V><n>, <V><m>", "UQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 109, "asmtemplate": "SQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement scalar by multiple of 8-bit predicate constraint element count", "heading": "SQDECB", "para": "Signed saturating decrement scalar by multiple of 8-bit predicate constraint  element count. \n\nDetermines the number of active 8-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECB  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 1106, "asmtemplate": "SHA1P  <Qd>, <Sn>, <Vm>.4S", "brief": "SHA1 hash update (parity)", "heading": "SHA1P", "para": "SHA1 hash update (parity).", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the third SIMD", "<Sn>": "Is the 32-bit name of the second SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA1P  <Qd>, <Sn>, <Vm>.4S"]}, {"id": 947, "asmtemplate": "UADDL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Add Long (vector)", "heading": "UADDL, UADDL2", "para": "Unsigned Add Long (vector). This instruction adds each vector element in the  lower or upper half of the first source SIMD&FP register to the corresponding  vector element of the second source SIMD&FP register, places the result into a  vector, and writes the vector to the destination SIMD&FP register. The  destination vector elements are twice as long as the source vector elements.  All the values in this instruction are unsigned integer values. \n\nThe UADDL instruction extracts each source vector from the lower half of each  source register, while the UADDL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 1222, "asmtemplate": "LDAPRH  <Wt>, [<Xn|SP> {,#0}]", "brief": "Load-Acquire RCpc Register Halfword", "heading": "LDAPRH", "para": "Load-Acquire RCpc Register Halfword derives an address from a base register  value, loads a halfword from the derived address in memory, zero-extends it  and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDAPRH  <Wt>, [<Xn|SP> {,#0}]"]}, {"id": 511, "asmtemplate": "LDURB  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Byte (unscaled)", "heading": "LDURB", "para": "Load Register Byte (unscaled) calculates an address from a base register and  an immediate offset, loads a byte from memory, zero-extends it, and writes it  to a register. For information about memory accesses, see Load/Store  addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDURB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 295, "asmtemplate": "STR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Store vector register", "heading": "STR (vector)", "para": "Store vector register. \n\nStore a vector register to a memory address generated by a 64-bit scalar base,  plus an immediate offset in the range -256 to 255 which is multiplied by the  current vector register size in bytes. This instruction is unpredicated. \n\nThe store is performed as a stream of byte elements in ascending element  order, without any endian conversion.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."}, "encodings": ["STR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 135, "asmtemplate": "CLS  <Vd>.<T>, <Vn>.<T>", "brief": "Count Leading Sign bits (vector)", "heading": "CLS (vector)", "para": "Count Leading Sign bits (vector). This instruction counts the number of  consecutive bits following the most significant bit that are the same as the  most significant bit in each vector element in the source SIMD&FP register,  places the result into a vector, and writes the vector to the destination  SIMD&FP register. The count does not include the most significant bit itself. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["CLS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 1077, "asmtemplate": "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>", "brief": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector)", "heading": "FCVTZU (vector, fixed-point)", "para": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector).  This instruction converts a scalar or each element in a vector from  floating-point to fixed-point unsigned integer using the Round towards Zero  rounding mode, and writes the result to the general-purpose destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTZU  <V><d>, <V><n>, #<fbits>", "FCVTZU  <Vd>.<T>, <Vn>.<T>, #<fbits>"]}, {"id": 566, "asmtemplate": "UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Absolute difference and Accumulate", "heading": "UABA", "para": "Unsigned Absolute difference and Accumulate. This instruction subtracts the  elements of the vector of the second source SIMD&FP register from the  corresponding elements of the first source SIMD&FP register, and accumulates  the absolute values of the results into the elements of the vector of the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UABA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1227, "asmtemplate": "SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Minimum (vector)", "heading": "SMIN", "para": "Signed Minimum (vector). This instruction compares corresponding elements in  the vectors in the two source SIMD&FP registers, places the smaller of each of  the two signed integer values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMIN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 509, "asmtemplate": "TRN2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>", "brief": "Interleave even or odd elements from two predicates", "heading": "TRN1, TRN2 (predicates)", "para": "Interleave even or odd elements from two predicates. \n\nInterleave alternating even or odd-numbered elements from the first and second  source predicates and place in elements of the destination predicate. This  instruction is unpredicated. \n\nIt has encodings from 2 classes: Even and Odd", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T><Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["TRN1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>", "TRN2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>"]}, {"id": 430, "asmtemplate": "SUB  <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}", "brief": "Subtract (immediate)", "heading": "SUB (immediate)", "para": "Subtract (immediate) subtracts an optionally-shifted immediate value from a  register value, and writes the result to the destination register.", "explanations": {"<imm>": "Is an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field."}, "encodings": ["SUB  <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}"]}, {"id": 814, "asmtemplate": "UQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement scalar by multiple of 64-bit predicate constraint element count", "heading": "UQDECD (scalar)", "para": "Unsigned saturating decrement scalar by multiple of 64-bit predicate  constraint element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECD  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 621, "asmtemplate": "MOVPRFX <Zd>.<T>, <Pg>/<ZM>, <Zn>.<T>", "brief": "Move prefix (predicated)", "heading": "MOVPRFX (predicated)", "para": "Move prefix (predicated). \n\nThe predicated MOVPRFX instruction is a hint to hardware that the instruction  may be combined with the destructive instruction which follows it in program  order to create a single constructive operation. Since it is a hint it is also  permitted to be implemented as a discrete vector copy, and the result of  executing the pair of instructions with or without combining is identical. The  choice of combined versus discrete operation may vary dynamically. \n\nUnless the combination of a constructive operation with merging predication is  specifically required, it is strongly recommended that for performance reasons  software should prefer to use the zeroing form of predicated MOVPRFX or the  unpredicated MOVPRFX instruction. \n\nAlthough the operation of the instruction is defined as a simple predicated  vector copy, it is required that the prefixed instruction at PC+4 must be an  SVE destructive binary or ternary instruction encoding, or a unary operation  with merging predication, but excluding other MOVPRFX instructions. The  prefixed instruction must specify the same predicate register, and have the  same maximum element size (ignoring a fixed 64-bit \"wide vector\" operand), and  the same destination vector as the MOVPRFX instruction. The prefixed  instruction must not use the destination register in any other operand  position, even if they have different names but refer to the same  architectural register state. Any other use is UNPREDICTABLE.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<ZM><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["MOVPRFX <Zd>.<T>, <Pg>/<ZM>, <Zn>.<T>"]}, {"id": 655, "asmtemplate": "SHA512H  <Qd>, <Qn>, <Vm>.2D", "brief": "SHA512 Hash update part 1", "heading": "SHA512H", "para": "SHA512 Hash update part 1 takes the values from the three 128-bit source  SIMD&FP registers and produces a 128-bit output value that combines the sigma1  and chi functions of two iterations of the SHA512 computation. It returns this  value to the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA512 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Qn>": "Is the 128-bit name of the second SIMD", "<Vm>": "Is the name of the third SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA512H  <Qd>, <Qn>, <Vm>.2D"]}, {"id": 382, "asmtemplate": "STGM  <Xt>, [<Xn|SP>]", "brief": "Store Tag Multiple", "heading": "STGM", "para": "Store Tag Multiple writes a naturally aligned block of N Allocation Tags,  where the size of N is identified in GMID_EL1.BS, and the Allocation Tag  written to address A is taken from the source register at 4*A<7:4>+3:4*A<7:4>. \n\nThis instruction is undefined at EL0. \n\nThis instruction generates an Unchecked access. \n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field."}, "encodings": ["STGM  <Xt>, [<Xn|SP>]"]}, {"id": 615, "asmtemplate": "SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Maximum (vector)", "heading": "SMAX", "para": "Signed Maximum (vector). This instruction compares corresponding elements in  the vectors in the two source SIMD&FP registers, places the larger of each  pair of signed integer values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMAX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 942, "asmtemplate": "LDCLRLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic bit clear on halfword in memory", "heading": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH", "para": "Atomic bit clear on halfword in memory atomically loads a 16-bit halfword from  memory, performs a bitwise AND with the complement of the value held in a  register on it, and stores the result back to memory. The value initially  loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDCLRAH and LDCLRALH load from \n  memory with acquire semantics. \n* LDCLRLH and LDCLRALH store to memory with release semantics. \n* LDCLRH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STCLRH, STCLRLH.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDCLRAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 55, "asmtemplate": "LDAPUR  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load-Acquire RCpc Register (unscaled)", "heading": "LDAPUR", "para": "Load-Acquire RCpc Register (unscaled) calculates an address from a base  register and an immediate offset, loads a 32-bit word or 64-bit doubleword  from memory, zero-extends it, and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAPUR  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 1183, "asmtemplate": "FDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point reversed divide by vector (predicated)", "heading": "FDIVR", "para": "Floating-point reversed divide by vector (predicated). \n\nReversed divide active floating-point elements of the second source vector by  corresponding floating-point elements of the first source vector and  destructively place the quotient in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FDIVR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 148, "asmtemplate": "ST4H    {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store four-halfword structures from four vectors (immediate index)", "heading": "ST4H (scalar plus immediate)", "para": "Contiguous store four-halfword structures from four vectors (immediate index). \n\nContiguous store four-halfword structures, each from the same element number  in four vector registers to the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 4 in the range -32 to 28  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive halfwords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 401, "asmtemplate": "STR  <Xt>, [<Xn|SP>{, #<pimm>}]", "brief": "Store Register (immediate)", "heading": "STR (immediate)", "para": "Store Register (immediate) stores a word or a doubleword from a register to  memory. The address that is used for the store is calculated from a base  register and an immediate offset. For information about memory accesses, see  Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/8.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "For the 64-bit variant: is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as ", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STR  <Wt>, [<Xn|SP>], #<simm>", "STR  <Wt>, [<Xn|SP>, #<simm>]!", "STR  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 933, "asmtemplate": "LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault signed halfwords to vector (vector index)", "heading": "LDFF1SH (scalar plus vector)", "para": "Gather load first-fault signed halfwords to vector (vector index). \n\nGather load with first-faulting behavior of signed halfwords to active  elements of a vector register from memory addresses generated by a 64-bit  scalar base plus vector index. The index values are optionally first sign or  zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 47, "asmtemplate": "ABS     <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Absolute value (predicated)", "heading": "ABS", "para": "Absolute value (predicated). \n\nCompute the absolute value of the signed integer in each active element of the  source vector, and place the results in the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["ABS     <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 120, "asmtemplate": "FRINTX  <Dd>, <Dn>", "brief": "Floating-point Round to Integral exact, using current rounding mode (scalar)", "heading": "FRINTX (scalar)", "para": "Floating-point Round to Integral exact, using current rounding mode (scalar).  This instruction rounds a floating-point value in the SIMD&FP source register  to an integral floating-point value of the same size using the rounding mode  that is determined by the FPCR, and writes the result to the SIMD&FP  destination register. \n\nWhen the result value is not numerically equal to the input value, an Inexact  exception is raised. A zero input gives a zero result with the same sign, an  infinite input gives an infinite result with the same sign, and a NaN is  propagated as for normal arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTX  <Hd>, <Hn>"]}, {"id": 1074, "asmtemplate": "NOP", "brief": "No Operation", "heading": "NOP", "para": "No Operation does nothing, other than advance the value of the program counter  by 4. This instruction can be used for instruction alignment purposes. \n\nThe timing effects of including a NOP instruction in a program are not  guaranteed. It can increase execution time, leave it unchanged, or even reduce  it. Therefore, NOP instructions are not suitable for timing loops.", "explanations": {}, "encodings": ["NOP"]}, {"id": 1122, "asmtemplate": "BR  <Xn>", "brief": "Branch to Register", "heading": "BR", "para": "Branch to Register branches unconditionally to an address in a register, with  a hint that this is not a subroutine return.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."}, "encodings": ["BR  <Xn>"]}, {"id": 1172, "asmtemplate": "ST3H    {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store three-halfword structures from three vectors (immediate index)", "heading": "ST3H (scalar plus immediate)", "para": "Contiguous store three-halfword structures from three vectors (immediate  index). \n\nContiguous store three-halfword structures, each from the same element number  in three vector registers to the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 3 in the range -24 to 21  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive halfwords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 765, "asmtemplate": "PRFD    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous prefetch doublewords (immediate index)", "heading": "PRFD (scalar plus immediate)", "para": "Contiguous prefetch doublewords (immediate index). \n\nContiguous prefetch of doubleword elements from the memory address generated  by a 64-bit scalar base and immediate index in the range -32 to 31 which is  multiplied by the vector's in-memory size, irrespective of predication, and  added to the base address. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>": "Is the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFD    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 530, "asmtemplate": "BFCVT   <Zd>.H, <Pg>/M, <Zn>.S", "brief": "Floating-point down convert to BFloat16 format (predicated)", "heading": "BFCVT", "para": "Floating-point down convert to BFloat16 format (predicated). \n\nConvert to BFloat16 from single-precision in each active floating-point  element of the source vector, and place the results in the corresponding  elements of the destination vector. Inactive elements in the destination  vector register remain unmodified. \n\nSince the result type is smaller than the input type, the results are  zero-extended to fill each destination element. \n\nUnlike the BFloat16 matrix multiplication and dot product instructions, this  instruction honors all of the FPCR bits that apply to single-precision  arithmetic. It can also generate a floating-point exception that causes  cumulative exception bits in the FPSR to be set, or a synchronous exception to  be taken, depending on the enable bits in the FPCR. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["BFCVT   <Zd>.H, <Pg>/M, <Zn>.S"]}, {"id": 845, "asmtemplate": "LDEORLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic exclusive OR on halfword in memory", "heading": "LDEORH, LDEORAH, LDEORALH, LDEORLH", "para": "Atomic exclusive OR on halfword in memory atomically loads a 16-bit halfword  from memory, performs an exclusive OR with the value held in a register on it,  and stores the result back to memory. The value initially loaded from memory  is returned in the destination register.  \n* If the destination register is not WZR, LDEORAH and LDEORALH load from \n  memory with acquire semantics. \n* LDEORLH and LDEORALH store to memory with release semantics. \n* LDEORH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STEORH, STEORLH.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDEORAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 278, "asmtemplate": "LDRSH  <Xt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load Register Signed Halfword (immediate)", "heading": "LDRSH (immediate)", "para": "Load Register Signed Halfword (immediate) loads a halfword from memory,  sign-extends it to 32 bits or 64 bits, and writes the result to a register.  The address that is used for the load is calculated from a base register and  an immediate offset. For information about memory accesses, see Load/Store  addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/2.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as ", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDRSH  <Wt>, [<Xn|SP>], #<simm>", "LDRSH  <Wt>, [<Xn|SP>, #<simm>]!", "LDRSH  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 902, "asmtemplate": "PRFB    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Gather prefetch bytes (vector plus immediate)", "heading": "PRFB (vector plus immediate)", "para": "Gather prefetch bytes (vector plus immediate). \n\nGather prefetch of bytes from the active memory addresses generated by a  vector base plus immediate index. The index is in the range 0 to 31. Inactive  addresses are not prefetched from memory. \n\nThe <prfop> symbol specifies the prefetch hint as a combination of three  options: access type PLD for load or PST for store; target cache level L1, L2  or L3; temporality (KEEP for temporal or STRM for non-temporal). \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFB    <prfop>, <Pg>, [<Zn>.S{, #<imm>}]", "PRFB    <prfop>, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 479, "asmtemplate": "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Multiply (vector)", "heading": "MUL (vector)", "para": "Multiply (vector). This instruction multiplies corresponding elements in the  vectors of the two source SIMD&FP registers, places the results in a vector,  and writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 859, "asmtemplate": "DUPM    <Zd>.<T>, #<const>", "brief": "Broadcast logical bitmask immediate to vector (unpredicated)", "heading": "DUPM", "para": "Broadcast logical bitmask immediate to vector (unpredicated). \n\nUnconditionally broadcast the logical bitmask immediate into each element of  the destination vector. This instruction is unpredicated. The immediate is a  64-bit value consisting of a single run of ones or zeros repeating every 2, 4,  8, 16, 32 or 64 bits. \n\nThis instruction is used by the alias MOV (bitmask immediate).", "explanations": {"<T><const>": "Is a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["DUPM    <Zd>.<T>, #<const>"]}, {"id": 1202, "asmtemplate": "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Floating-point Multiply extended (by element)", "heading": "FMULX (by element)", "para": "Floating-point Multiply extended (by element). This instruction multiplies the  floating-point values in the vector elements in the first source SIMD&FP  register by the specified floating-point value in the second source SIMD&FP  register, places the results in a vector, and writes the vector to the  destination SIMD&FP register. \n\nIf one value is zero and the other value is infinite, the result is 2.0. In  this case, the result is negative if only one of the values is negative,  otherwise the result is positive. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar,  single-precision and double-precision , Vector, half-precision and Vector,  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<n>": "Is the number of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<V><d>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<Vm>": "For the single-precision and double-precision variant: is the name of the second SIMD", "<Ts><index>": "For the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."}, "encodings": ["FMULX  <Hd>, <Hn>, <Vm>.H[<index>]", "FMULX  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 594, "asmtemplate": "LDFF1H  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]", "brief": "Contiguous load first-fault unsigned halfwords to vector (scalar index)", "heading": "LDFF1H (scalar plus scalar)", "para": "Contiguous load first-fault unsigned halfwords to vector (scalar index). \n\nContiguous load with first-faulting behavior of unsigned halfwords to elements  of a vector register from the memory address generated by a 64-bit scalar base  and scalar index which is multiplied by 2 and added to the base address. After  each element access the index value is incremented, but the index register is  not updated. Inactive elements will not not cause a read from Device memory or  signal a fault, and are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]", "LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]"]}, {"id": 7, "asmtemplate": "FABS  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Absolute value (vector)", "heading": "FABS (vector)", "para": "Floating-point Absolute value (vector). This instruction calculates the  absolute value of each vector element in the source SIMD&FP register, writes  the result to a vector, and writes the vector to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["FABS  <Vd>.<T>, <Vn>.<T>", "FABS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 940, "asmtemplate": "ST64B  <Xt>, [<Xn|SP> {,#0}]", "brief": "Single-copy Atomic 64-byte Store without Return", "heading": "ST64B", "para": "Single-copy Atomic 64-byte Store without Return stores eight 64-bit  doublewords from consecutive registers, Xt to X(t+7), to a memory location.  The data that is stored is atomic and is required to be 64-byte-aligned.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["ST64B  <Xt>, [<Xn|SP> {,#0}]"]}, {"id": 79, "asmtemplate": "LDUMINLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic unsigned minimum on byte in memory", "heading": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB", "para": "Atomic unsigned minimum on byte in memory atomically loads an 8-bit byte from  memory, compares it against the value held in a register, and stores the  smaller value back to memory, treating the values as unsigned numbers. The  value initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDUMINAB and LDUMINALB load from \n  memory with acquire semantics. \n* LDUMINLB and LDUMINALB store to memory with release semantics. \n* LDUMINB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMINB, STUMINLB.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDUMINAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 73, "asmtemplate": "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>", "brief": "Floating-point Complex Multiply Accumulate (by element)", "heading": "FCMLA (by element)", "para": "Floating-point Complex Multiply Accumulate (by element). \n\nThis instruction operates on complex numbers that are represented in SIMD&FP  registers as pairs of elements, with the more significant element holding the  imaginary part of the number and the less significant element holding the real  part of the number. Each element holds a floating-point value. It performs the  following computation on complex numbers from the first source register and  the destination register with the specified complex number from the second  source register:  \n* Considering the complex number from the second source register on an Argand \n  diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 \n  degrees. \n* The two elements of the transformed complex number are multiplied by:The \n  real element of the complex number from the first source register, if the \n  transformation was a rotation by 0 or 180 degrees.The imaginary element of \n  the complex number from the first source register, if the transformation was \n  a rotation by 90 or 270 degrees. \n* The complex number resulting from that multiplication is added to the \n  complex number from the destination register.  The multiplication and addition operations are performed as a fused  multiply-add, without any intermediate rounding. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"]}, {"id": 988, "asmtemplate": "FMINP  <V><d>, <Vn>.<T>", "brief": "Floating-point Minimum of Pair of elements (scalar)", "heading": "FMINP (scalar)", "para": "Floating-point Minimum of Pair of elements (scalar). This instruction compares  two vector elements in the source SIMD&FP register and writes the smallest of  the floating-point values as a scalar to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><V><d>": "Is the number of the SIMD"}, "encodings": ["FMINP  <V><d>, <Vn>.<T>", "FMINP  <V><d>, <Vn>.<T>"]}, {"id": 1046, "asmtemplate": "SMSUBL<Xd>, <Wn>, <Wm>, XZR", "brief": "Signed Multiply-Negate Long", "heading": "SMNEGL", "para": "Signed Multiply-Negate Long multiplies two 32-bit register values, negates the  product, and writes the result to the 64-bit destination register. \n\nThis is an alias of SMSUBL. This means:  \n* The encodings in this description are named to match the encodings of \n  SMSUBL. \n* The description of SMSUBL gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."}, "encodings": ["SMNEGL  <Xd>, <Wn>, <Wm>"]}, {"id": 805, "asmtemplate": "USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]", "brief": "Dot Product with unsigned and signed integers (vector, by element)", "heading": "USDOT (by element)", "para": "Dot Product index form with unsigned and signed integers. This instruction  performs the dot product of the four unsigned 8-bit integer values in each  32-bit element of the first source register with the four signed 8-bit integer  values in an indexed 32-bit element of the second source register,  accumulating the result into the corresponding 32-bit element of the  destination register. \n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is  mandatory for implementations that include Advanced SIMD to support it.  ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<index>": "Is the immediate index of a quadtuplet of four 8-bit elements in the range 0 to 3, encoded in the \"H:L\" fields.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"]}, {"id": 1248, "asmtemplate": "FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point multiply vectors (predicated)", "heading": "FMUL (vectors, predicated)", "para": "Floating-point multiply vectors (predicated). \n\nMultiply active floating-point elements of the first source vector by  corresponding floating-point elements of the second source vector and  destructively place the results in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 871, "asmtemplate": "SUBS  <Xd>, <Xn|SP>, <R><m>{, <extend>{#<amount>}}", "brief": "Subtract (extended register), setting flags", "heading": "SUBS (extended register)", "para": "Subtract (extended register), setting flags, subtracts a sign or zero-extended  register value, followed by an optional left shift amount, from a register  value, and writes the result to the destination register. The argument that is  extended from the <Rm> register can be a byte, halfword, word, or doubleword.  It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMP (extended register).", "explanations": {"": " is present but not LSL.", "<R><m>": "Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<extend><extend><amount>": "Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn|WSP>": "Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["SUBS  <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"]}, {"id": 553, "asmtemplate": "ST1W    {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous store words from vector (scalar index)", "heading": "ST1W (scalar plus scalar)", "para": "Contiguous store words from vector (scalar index). \n\nContiguous store of words from elements of a vector register to the memory  address generated by a 64-bit scalar base and scalar index which is multiplied  by 4 and added to the base address. After each element access the index value  is incremented, but the index register is not updated. Inactive elements are  not written to memory.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST1W    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 643, "asmtemplate": "BFMMLA  <Vd>.4S, <Vn>.8H, <Vm>.8H", "brief": "BFloat16 floating-point matrix multiply-accumulate into 2x2 matrix", "heading": "BFMMLA", "para": "BFloat16 floating-point matrix multiply-accumulate. \n\nThis BFloat16 floating-point (BF16) matrix multiply-accumulate instruction  multiplies the 2\u00d74 matrix of BF16 values held in each 128-bit segment of the  first source vector by the 4\u00d72 BF16 matrix in the corresponding segment of the  second source vector. The resulting 2\u00d72 single-precision (FP32) matrix product  is then destructively added to the FP32 matrix accumulator held in the  corresponding segment of the addend and destination vector. This is equivalent  to performing a 4-way dot product per destination element. \n\nThis instruction is unpredicated and vector length agnostic. \n\nAll floating-point calculations performed by this instruction are performed  with the following behaviors, irrespective of the value in FPCR:  \n* Uses the non-IEEE 754 Round-to-Odd mode, which forces bit 0 of an inexact  result to 1, and rounds an overflow to an appropriately signed Infinity.  \n* The cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC and IOC) are not  modified.  \n* Trapped floating-point exceptions are disabled, as if the FPCR trap enable  bits (IDE, IXE, UFE, OFE, DZE and IOE) are all zero.  \n* Denormalized inputs and results are flushed to zero, as if FPCR.FZ == 1.  \n* Only the Default NaN is generated, as if FPCR.DN == 1. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["BFMMLA  <Zda>.S, <Zn>.H, <Zm>.H"]}, {"id": 163, "asmtemplate": "LD1  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load multiple single-element structures to one, two, three, or four registers", "heading": "LD1 (multiple structures)", "para": "Load multiple single-element structures to one, two, three, or four registers.  This instruction loads multiple single-element structures from memory and  writes the result to one, two, three, or four SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<imm><imm><imm><imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<T><Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD1  { <Vt>.<T> }, [<Xn|SP>]", "LD1  { <Vt>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 207, "asmtemplate": "FADDP  <V><d>, <Vn>.<T>", "brief": "Floating-point Add Pair of elements (scalar)", "heading": "FADDP (scalar)", "para": "Floating-point Add Pair of elements (scalar). This instruction adds two  floating-point vector elements in the source SIMD&FP register and writes the  scalar result into the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><V><d>": "Is the number of the SIMD"}, "encodings": ["FADDP  <V><d>, <Vn>.<T>", "FADDP  <V><d>, <Vn>.<T>"]}, {"id": 918, "asmtemplate": "UMLSL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Multiply-Subtract Long (vector)", "heading": "UMLSL, UMLSL2 (vector)", "para": "Unsigned Multiply-Subtract Long (vector). This instruction multiplies  corresponding vector elements in the lower or upper half of the two source  SIMD&FP registers, and subtracts the results from the vector elements of the  destination SIMD&FP register. The destination vector elements are twice as  long as the elements that are multiplied. All the values in this instruction  are unsigned integer values. \n\nThe UMLSL instruction extracts each source vector from the lower half of each  source register, while the UMLSL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 352, "asmtemplate": "FCMP  <Dn>, #0.0", "brief": "Floating-point quiet Compare (scalar)", "heading": "FCMP", "para": "Floating-point quiet Compare (scalar). This instruction compares the two  SIMD&FP source register values, or the first SIMD&FP source register value and  zero. It writes the result to the PSTATE.{N, Z, C, V} flags. \n\nThis instruction raises an Invalid Operation floating-point exception if  either or both of the operands is a signaling NaN. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Dn>": "For the double-precision, zero variant: is the 64-bit name of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "For the half-precision, zero variant: is the 16-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "For the single-precision, zero variant: is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FCMP  <Hn>, <Hm>"]}, {"id": 316, "asmtemplate": "FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point minimum number with immediate (predicated)", "heading": "FMINNM (immediate)", "para": "Floating-point minimum number with immediate (predicated). \n\nDetermine the minimum number value of an immediate and each active  floating-point element of the source vector, and destructively place the  results in the corresponding elements of the source vector. The immediate may  take the value +0.0 or +1.0 only. If the element value is NaN then the result  is the immediate. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 239, "asmtemplate": "STG  <Xt|SP>, [<Xn|SP>{, #<simm>}]", "brief": "Store Allocation Tag", "heading": "STG", "para": "Store Allocation Tag stores an Allocation Tag to memory. The address used for  the store is calculated from the base register and an immediate signed offset  scaled by the Tag granule. The Allocation Tag is calculated from the Logical  Address Tag in the source register. \n\nThis instruction generates an Unchecked access. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"<Xt|SP>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<simm>": "Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field."}, "encodings": ["STG  <Xt|SP>, [<Xn|SP>], #<simm>", "STG  <Xt|SP>, [<Xn|SP>, #<simm>]!", "STG  <Xt|SP>, [<Xn|SP>{, #<simm>}]"]}, {"id": 806, "asmtemplate": "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Compare signed Greater than (vector)", "heading": "CMGT (register)", "para": "Compare signed Greater than (vector). This instruction compares each vector  element in the first source SIMD&FP register with the corresponding vector  element in the second source SIMD&FP register and if the first signed integer  value is greater than the second signed integer value sets every bit of the  corresponding vector element in the destination SIMD&FP register to one,  otherwise sets every bit of the corresponding vector element in the  destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["CMGT  <V><d>, <V><n>, <V><m>", "CMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1130, "asmtemplate": "STUR  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Store Register (unscaled)", "heading": "STUR", "para": "Store Register (unscaled) calculates an address from a base register value and  an immediate offset, and stores a 32-bit word or a 64-bit doubleword to the  calculated address, from a register. For information about memory accesses,  see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STUR  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 1223, "asmtemplate": "REV32  <Xd>, <Xn>", "brief": "Reverse bytes in 32-bit words", "heading": "REV32", "para": "Reverse bytes in 32-bit words reverses the byte order in each 32-bit word of a  register.", "explanations": {"<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."}, "encodings": ["REV32  <Xd>, <Xn>"]}, {"id": 139, "asmtemplate": "CASLB  <Ws>, <Wt>, [<Xn|SP>{,#0}]", "brief": "Compare and Swap byte in memory", "heading": "CASB, CASAB, CASALB, CASLB", "para": "Compare and Swap byte in memory reads an 8-bit byte from memory, and compares  it against the value held in a first register. If the comparison is equal, the  value in a second register is written to memory. If the write is performed,  the read and write occur atomically such that no other modification of the  memory location can take place between the read and write.  \n* CASAB and CASALB load from memory with acquire semantics. \n* CASLB and CASALB store to memory with release semantics. \n* CASB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors  associated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the register which is  compared and loaded, that is <Ws>, is restored to the values held in the  register before the instruction was executed.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field."}, "encodings": ["CASAB  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 981, "asmtemplate": "LD1SH   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load signed halfwords to vector (immediate index)", "heading": "LD1SH (scalar plus immediate)", "para": "Contiguous load signed halfwords to vector (immediate index). \n\nContiguous load of signed halfwords to elements of a vector register from the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements will not not  cause a read from Device memory or signal a fault, and are set to zero in the  destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 497, "asmtemplate": "STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]", "brief": "Store-Release Exclusive Register Halfword", "heading": "STLXRH", "para": "Store-Release Exclusive Register Halfword stores a halfword from a 32-bit  register to memory if the PE has exclusive access to the memory address, and  returns a status value of 0 if the store was successful, or of 1 if no store  was performed. See Synchronization and semaphores. The memory access is  atomic. The instruction also has memory ordering semantics as described in  Load-Acquire, Store-Release. For information about memory accesses see  Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:"}, "encodings": ["STLXRH  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 965, "asmtemplate": "SUDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]", "brief": "Signed by unsigned integer indexed dot product", "heading": "SUDOT", "para": "Signed by unsigned integer indexed dot product. \n\nThe signed by unsigned integer indexed dot product instruction computes the  dot product of a group of four signed 8-bit integer values held in each 32-bit  element of the first source vector multiplied by a group of four unsigned  8-bit integer values in an indexed 32-bit element of the second source vector,  and then destructively adds the widened dot product to the corresponding  32-bit element of the destination vector. \n\nThe groups within the second source vector are specified using an immediate  index which selects the same group position within each 128-bit vector  segment. The index range is from 0 to 3. This instruction is unpredicated. \n\nID_AA64ZFR0_EL1.I8MM indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the immediate index of a quadtuplet of four 8-bit elements within each 128-bit vector segment, in the range 0 to 3, encoded in the \"i2\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["SUDOT   <Zda>.S, <Zn>.B, <Zm>.B[<imm>]"]}, {"id": 415, "asmtemplate": "PSSBB", "brief": "Physical Speculative Store Bypass Barrier", "heading": "PSSBB", "para": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents  speculative loads from bypassing earlier stores to the same physical address. \n\nThe semantics of the Physical Speculative Store Bypass Barrier are:  \n* When a load to a location appears in program order after the PSSBB, then the \n  load does not speculatively read an entry earlier in the coherence order for \n  that location than the entry generated by the latest store satisfying all of \n  the following conditions:The store is to the same location as the load.The \n  store appears in program order before the PSSBB. \n* When a load to a location appears in program order before the PSSBB, then \n  the load does not speculatively read data from any store satisfying all of \n  the following conditions:The store is to the same location as the load.The \n  store appears in program order after the PSSBB.", "explanations": {}, "encodings": ["PSSBB"]}, {"id": 1073, "asmtemplate": "LSR     <Zd>.<T>, <Zn>.<T>, #<const>", "brief": "Logical shift right by immediate (unpredicated)", "heading": "LSR (immediate, unpredicated)", "para": "Logical shift right by immediate (unpredicated). \n\nShift right by immediate, inserting zeroes, each element of the source vector,  and place the results in the corresponding elements of the destination vector.  The immediate shift amount is an unsigned value in the range 1 to number of  bits per element. This instruction is unpredicated.", "explanations": {"<const>": "Is the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\".", "<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["LSR     <Zd>.<T>, <Zn>.<T>, #<const>"]}, {"id": 1094, "asmtemplate": "LDADDLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic add on halfword in memory, without return", "heading": "STADDH, STADDLH", "para": "Atomic add on halfword in memory, without return, atomically loads a 16-bit  halfword from memory, adds the value held in a register to it, and stores the  result back to memory.  \n* STADDH does not have release semantics. \n* STADDLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDADDH, LDADDAH, LDADDALH, LDADDLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDADDH, LDADDAH, LDADDALH, LDADDLH. \n* The description of LDADDH, LDADDAH, LDADDALH, LDADDLH gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STADDH  <Ws>, [<Xn|SP>]"]}, {"id": 616, "asmtemplate": "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]", "brief": "Load Register Signed Word (immediate)", "heading": "LDRSW (immediate)", "para": "Load Register Signed Word (immediate) loads a word from memory, sign-extends  it to 64 bits, and writes the result to a register. The address that is used  for the load is calculated from a base register and an immediate offset. For  information about memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/4.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, a multiple of 4 in the range 0 to 16380, defaulting to 0 and encoded in the \"imm12\" field as ", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDRSW  <Xt>, [<Xn|SP>], #<simm>", "LDRSW  <Xt>, [<Xn|SP>, #<simm>]!", "LDRSW  <Xt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 837, "asmtemplate": "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Signed saturating Shift Left (immediate)", "heading": "SQSHL (immediate)", "para": "Signed saturating Shift Left (immediate). This instruction reads each vector  element in the source SIMD&FP register, shifts each result by an immediate  value, places the final result in a vector, and writes the vector to the  destination SIMD&FP register. The results are truncated. For rounded results,  see UQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SQSHL  <V><d>, <V><n>, #<shift>", "SQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 617, "asmtemplate": "ZIP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>", "brief": "Interleave elements from two half predicates", "heading": "ZIP1, ZIP2 (predicates)", "para": "Interleave elements from two half predicates. \n\nInterleave alternating elements from the lowest or highest halves of the first  and second source predicates and place in elements of the destination  predicate. This instruction is unpredicated. \n\nIt has encodings from 2 classes: High halves and Low halves", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T><Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["ZIP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>", "ZIP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>"]}, {"id": 1143, "asmtemplate": "FCVTMU  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector)", "heading": "FCVTMU (vector)", "para": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity \n(vector). This instruction converts a scalar or each element in a vector from  a floating-point value to an unsigned integer value using the Round towards  Minus Infinity rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTMU  <Hd>, <Hn>", "FCVTMU  <V><d>, <V><n>", "FCVTMU  <Vd>.<T>, <Vn>.<T>", "FCVTMU  <Vd>.<T>, <Vn>.<T>"]}, {"id": 547, "asmtemplate": "FRINT64X  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to 64-bit Integer, using current rounding mode (vector)", "heading": "FRINT64X (vector)", "para": "Floating-point Round to 64-bit Integer, using current rounding mode (vector).  This instruction rounds a vector of floating-point values in the SIMD&FP  source register to integral floating-point values that fit into a 64-bit  integer size using the rounding mode that is determined by the FPCR, and  writes the result to the SIMD&FP destination register. \n\nA zero input returns a zero result with the same sign. When one of the result  values is not numerically equal to the corresponding input value, an Inexact  exception is raised. When an input is infinite, NaN or out-of-range, the  instruction returns for the corresponding result value the most negative  integer representable in the destination size, and an Invalid Operation  floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["FRINT64X  <Vd>.<T>, <Vn>.<T>"]}, {"id": 989, "asmtemplate": "RMIF  <Xn>, #<shift>, #<mask>", "brief": "Rotate, Mask Insert Flags", "heading": "RMIF", "para": "Performs a rotation right of a value held in a general purpose register by an  immediate value, and then inserts a selection of the bottom four bits of the  result of the rotation into the PSTATE flags, under the control of a second  immediate mask.", "explanations": {"<shift>": "Is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<mask>": "Is the flag bit mask, an immediate in the range 0 to 15, which selects the bits that are inserted into the NZCV condition flags, encoded in the \"mask\" field."}, "encodings": ["RMIF  <Xn>, #<shift>, #<mask>"]}, {"id": 1006, "asmtemplate": "LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Logical shift right by vector (predicated)", "heading": "LSR (vectors)", "para": "Logical shift right by vector (predicated). \n\nShift right, inserting zeroes, active elements of the first source vector by  corresponding elements of the second source vector and destructively place the  results in the corresponding elements of the first source vector. The shift  amount operand is a vector of unsigned elements in which all bits are  significant, and not used modulo the element size. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1044, "asmtemplate": "LDFF1W  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]", "brief": "Contiguous load first-fault unsigned words to vector (scalar index)", "heading": "LDFF1W (scalar plus scalar)", "para": "Contiguous load first-fault unsigned words to vector (scalar index). \n\nContiguous load with first-faulting behavior of unsigned words to elements of  a vector register from the memory address generated by a 64-bit scalar base  and scalar index which is multiplied by 4 and added to the base address. After  each element access the index value is incremented, but the index register is  not updated. Inactive elements will not not cause a read from Device memory or  signal a fault, and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]"]}, {"id": 467, "asmtemplate": "SBFM<Xd>, <Xn>, #(-<lsb> MOD 64), #(<width>-1)", "brief": "Signed Bitfield Insert in Zero", "heading": "SBFIZ", "para": "Signed Bitfield Insert in Zeros copies a bitfield of <width> bits from the  least significant bits of the source register to bit position <lsb> of the  destination register, setting the destination bits below the bitfield to zero,  and the bits above the bitfield to a copy of the most significant bit of the  bitfield. \n\nThis is an alias of SBFM. This means:  \n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the destination bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-"}, "encodings": ["SBFIZ  <Wd>, <Wn>, #<lsb>, #<width>"]}, {"id": 611, "asmtemplate": "LDSMINL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic signed minimum on word or doubleword in memory", "heading": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL", "para": "Atomic signed minimum on word or doubleword in memory atomically loads a  32-bit word or 64-bit doubleword from memory, compares it against the value  held in a register, and stores the smaller value back to memory, treating the  values as signed numbers. The value initially loaded from memory is returned  in the destination register.  \n* If the destination register is not one of WZR or XZR, LDSMINA and LDSMINAL \n  load from memory with acquire semantics. \n* LDSMINL and LDSMINAL store to memory with release semantics. \n* LDSMIN has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMIN, STSMINL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDSMIN  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 529, "asmtemplate": "UDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>", "brief": "Unsigned integer dot product", "heading": "UDOT (vectors)", "para": "Unsigned integer dot product. \n\nThe unsigned integer dot product instruction computes the dot product of a  group of four unsigned 8-bit or 16-bit integer values held in each 32-bit or  64-bit element of the first source vector multiplied by a group of four  unsigned 8-bit or 16-bit integer values in the corresponding 32-bit or 64-bit  element of the second source vector, and then destructively adds the widened  dot product to the corresponding 32-bit or 64-bit element of the destination  vector. \n\nThis instruction is unpredicated.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Tb><Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>"]}, {"id": 784, "asmtemplate": "RDVL    <Xd>, #<imm>", "brief": "Read multiple of vector register size to scalar register", "heading": "RDVL", "para": "Read multiple of vector register size to scalar register. \n\nMultiply the current vector register size in bytes by an immediate in the  range -32 to 31 and place the result in the 64-bit destination general-purpose  register.", "explanations": {"<imm>": "Is the signed immediate operand, in the range -32 to 31, encoded in the \"imm6\" field.", "<Xd>": "Is the 64-bit name of the destination general-purpose register, encoded in the \"Rd\" field."}, "encodings": ["RDVL    <Xd>, #<imm>"]}, {"id": 1214, "asmtemplate": "CLREX  {#<imm>}", "brief": "Clear Exclusive", "heading": "CLREX", "para": "Clear Exclusive clears the local monitor of the executing PE.", "explanations": {"<imm>": "Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the \"CRm\" field."}, "encodings": ["CLREX  {#<imm>}"]}, {"id": 910, "asmtemplate": "EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise Exclusive OR (vector)", "heading": "EOR (vector)", "para": "Bitwise Exclusive OR (vector). This instruction performs a bitwise Exclusive  OR operation between the two source SIMD&FP registers, and places the result  in the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["EOR  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 975, "asmtemplate": "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Signed saturating Rounding Doubling Multiply returning High half (by element)", "heading": "SQRDMULH (by element)", "para": "Signed saturating Rounding Doubling Multiply returning High half (by element).  This instruction multiplies each vector element in the first source SIMD&FP  register by the specified vector element of the second source SIMD&FP  register, doubles the results, places the most significant half of the final  results into a vector, and writes the vector to the destination SIMD&FP  register. \n\nThe results are rounded. For truncated results, see SQDMULH. \n\nIf any of the results overflows, they are saturated. If saturation occurs, the  cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SQRDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 1021, "asmtemplate": "LD1RD   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast doubleword to vector", "heading": "LD1RD", "para": "Load and broadcast doubleword to vector. \n\nLoad a single doubleword from a memory address generated by a 64-bit scalar  base address plus an immediate offset which is a multiple of 8 in the range 0  to 504. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 504, defaulting to 0, encoded in the \"imm6\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD1RD   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 190, "asmtemplate": "SQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}", "brief": "Signed saturating subtract immediate (unpredicated)", "heading": "SQSUB (immediate)", "para": "Signed saturating subtract immediate (unpredicated). \n\nSigned saturating subtract of an unsigned immediate from each element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. Each result element is saturated to the N-bit  element's signed integer range -2(N-1) to (2(N-1) )-1. This instruction is  unpredicated. \n\nThe immediate is an unsigned value in the range 0 to 255, and for element  widths of 16 bits or higher it may also be a positive multiple of 256 in the  range 256 to 65280. \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<uimm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\".", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><imm>": "Is an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field."}, "encodings": ["SQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}"]}, {"id": 0, "asmtemplate": "LDNT1D  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load non-temporal doublewords to vector (scalar index)", "heading": "LDNT1D (scalar plus scalar)", "para": "Contiguous load non-temporal doublewords to vector (scalar index). \n\nContiguous load non-temporal of doublewords to elements of a vector register  from the memory address generated by a 64-bit scalar base and scalar index  which is multiplied by 8 and added to the base address. After each element  access the index value is incremented, but the index register is not updated.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LDNT1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 869, "asmtemplate": "SMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>", "brief": "Signed minimum with immediate (unpredicated)", "heading": "SMIN (immediate)", "para": "Signed minimum with immediate (unpredicated). \n\nDetermine the signed minimum of an immediate and each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate is a signed 8-bit value in the range -128 to \n+127, inclusive. This instruction is unpredicated.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><imm>": "Is the signed immediate operand, in the range -128 to 127, encoded in the \"imm8\" field."}, "encodings": ["SMIN    <Zdn>.<T>, <Zdn>.<T>, #<imm>"]}, {"id": 865, "asmtemplate": "SQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment vector by multiple of 16-bit predicate constraint element count", "heading": "SQINCH (vector)", "para": "Signed saturating increment vector by multiple of 16-bit predicate constraint  element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment all destination vector elements. The  results are saturated to the 16-bit signed integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCH  <Zdn>.H{, <pattern>{, MUL #<imm>}}"]}, {"id": 1093, "asmtemplate": "ST1H    {<Zt>.<T>}, <Pg>, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous store halfwords from vector (scalar index)", "heading": "ST1H (scalar plus scalar)", "para": "Contiguous store halfwords from vector (scalar index). \n\nContiguous store of halfwords from elements of a vector register to the memory  address generated by a 64-bit scalar base and scalar index which is multiplied  by 2 and added to the base address. After each element access the index value  is incremented, but the index register is not updated. Inactive elements are  not written to memory.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST1H    { <Zt>.<T> }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 114, "asmtemplate": "ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}", "brief": "Bitwise inclusive OR (vector, immediate)", "heading": "ORR (vector, immediate)", "para": "Bitwise inclusive OR (vector, immediate). This instruction reads each vector  element from the destination SIMD&FP register, performs a bitwise OR between  each result and an immediate constant, places the result into a vector, and  writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><T><imm8>": "Is an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\".", "": "FP register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD"}, "encodings": ["ORR  <Vd>.<T>, #<imm8>{, LSL #<amount>}"]}, {"id": 862, "asmtemplate": "STP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", "brief": "Store Pair of SIMD&FP registers", "heading": "STP (SIMD&FP)", "para": "Store Pair of SIMD&FP registers. This instruction stores a pair of SIMD&FP  registers to memory. The address used for the store is calculated from a base  register value and an immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"": "/16.", "<St1>": "Is the 32-bit name of the first SIMD", "<Dt1>": "Is the 64-bit name of the first SIMD", "<Qt1>": "Is the 128-bit name of the first SIMD", "<imm>": "For the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as ", "<St2>": "Is the 32-bit name of the second SIMD", "<Dt2>": "Is the 64-bit name of the second SIMD", "<Qt2>": "Is the 128-bit name of the second SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STP  <St1>, <St2>, [<Xn|SP>], #<imm>", "STP  <St1>, <St2>, [<Xn|SP>, #<imm>]!", "STP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 21, "asmtemplate": "BLRAB  <Xn>, <Xm|SP>", "brief": "Branch with Link to Register, with pointer authentication", "heading": "BLRAA, BLRAAZ, BLRAB, BLRABZ", "para": "Branch with Link to Register, with pointer authentication. This instruction  authenticates the address in the general-purpose register that is specified by \n<Xn>, using a modifier and the specified key, and calls a subroutine at the  authenticated address, setting register X30 to PC+4. \n\nThe modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xm|SP> for BLRAA and BLRAB. \n* The value zero, for BLRAAZ and BLRABZ.  Key A is used for BLRAA and BLRAAZ, and key B is used for BLRAB and BLRABZ. \n\nIf the authentication passes, the PE continues execution at the target of the  branch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to the general-purpose register.", "explanations": {"<Xm|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer holding the modifier, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."}, "encodings": ["BLRAAZ  <Xn>"]}, {"id": 85, "asmtemplate": "CNT  <Vd>.<T>, <Vn>.<T>", "brief": "Population Count per byte", "heading": "CNT", "para": "Population Count per byte. This instruction counts the number of bits that  have a value of one in each vector element in the source SIMD&FP register,  places the result into a vector, and writes the vector to the destination  SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["CNT  <Vd>.<T>, <Vn>.<T>"]}, {"id": 927, "asmtemplate": "FCVTZU  <Xd>, <Dn>, #<fbits>", "brief": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar)", "heading": "FCVTZU (scalar, fixed-point)", "para": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar).  This instruction converts the floating-point value in the SIMD&FP source  register to a 32-bit or 64-bit fixed-point unsigned integer using the Round  towards Zero rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped.", "explanations": {"<Dn>": "Is the 64-bit name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<fbits>": "For the double-precision to 64-bit, half-precision to 64-bit and single-precision to 64-bit variant: is the number of bits after the binary point in the fixed-point destination, in the range 1 to 64, encoded as 64 minus \"scale\".", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTZU  <Wd>, <Hn>, #<fbits>"]}, {"id": 216, "asmtemplate": "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Compare vectors", "heading": "CMP<cc> (vectors)", "para": "Compare vectors. \n\nCompare active integer elements in the first source vector with corresponding  elements in the second source vector, and place the boolean results of the  specified comparison in the corresponding elements of the destination  predicate. Inactive elements in the destination predicate register are set to  zero. Sets the First (N), None (Z), !Last (C) condition flags based on the  predicate result, and the V flag to zero. \n\n \n\nThe <cc> symbol specifies one of the standard ARM condition codes: EQ, GE, GT,  HI, HS or NE. \n\nThis instruction is used by the pseudo-instructions CMPLE (vectors), CMPLO \n(vectors), CMPLS (vectors), and CMPLT (vectors). \n\nIt has encodings from 6 classes: Equal , Greater than , Greater than or equal \n, Higher , Higher or same and Not equal", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "CMPGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "CMPGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "CMPHI   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "CMPHS   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "CMPNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>"]}, {"id": 535, "asmtemplate": "LD1SW   {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load signed words to vector (immediate index)", "heading": "LD1SW (scalar plus immediate)", "para": "Contiguous load signed words to vector (immediate index). \n\nContiguous load of signed words to elements of a vector register from the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements will not not  cause a read from Device memory or signal a fault, and are set to zero in the  destination vector.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 389, "asmtemplate": "LDUMAXL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic unsigned maximum on word or doubleword in memory, without return", "heading": "STUMAX, STUMAXL", "para": "Atomic unsigned maximum on word or doubleword in memory, without return,  atomically loads a 32-bit word or 64-bit doubleword from memory, compares it  against the value held in a register, and stores the larger value back to  memory, treating the values as unsigned numbers.  \n* STUMAX does not have release semantics. \n* STUMAXL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL. This means:  \n* The encodings in this description are named to match the encodings of \n  LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL. \n* The description of LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STUMAX  <Ws>, [<Xn|SP>]"]}, {"id": 660, "asmtemplate": "LDR  <Qt>, <label>", "brief": "Load SIMD&FP Register (PC-relative literal)", "heading": "LDR (literal, SIMD&FP)", "para": "Load SIMD&FP Register (PC-relative literal). This instruction loads a SIMD&FP  register from memory. The address that is used for the load is calculated from  the PC value and an immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register to be loaded, encoded in the \"Rt\" field.", "<Qt>": "Is the 128-bit name of the SIMD", "<St>": "Is the 32-bit name of the SIMD", "<Dt>": "Is the 64-bit name of the SIMD", "<label>": "Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."}, "encodings": ["LDR  <St>, <label>"]}, {"id": 1075, "asmtemplate": "EOR     <Zd>.D, <Zn>.D, <Zm>.D", "brief": "Bitwise exclusive OR vectors (unpredicated)", "heading": "EOR (vectors, unpredicated)", "para": "Bitwise exclusive OR vectors (unpredicated). \n\nBitwise exclusive OR all elements of the second source vector with  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. This instruction is  unpredicated.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["EOR     <Zd>.D, <Zn>.D, <Zm>.D"]}, {"id": 979, "asmtemplate": "FMUL  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Multiply (scalar)", "heading": "FMUL (scalar)", "para": "Floating-point Multiply (scalar). This instruction multiplies the  floating-point values of the two source SIMD&FP registers, and writes the  result to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMUL  <Hd>, <Hn>, <Hm>"]}, {"id": 197, "asmtemplate": "LDRSB  <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", "brief": "Load Register Signed Byte (register)", "heading": "LDRSB (register)", "para": "Load Register Signed Byte (register) calculates an address from a base  register value and an offset register value, loads a byte from memory,  sign-extends it, and writes it to a register. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Xm>": "When ", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>": "When ", "<extend><amount>": "Is the index shift amount, it must be ", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDRSB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"]}, {"id": 1042, "asmtemplate": "STLLRH  <Wt>, [<Xn|SP>{,#0}]", "brief": "Store LORelease Register Halfword", "heading": "STLLRH", "para": "Store LORelease Register Halfword stores a halfword from a 32-bit register to  a memory location. The instruction also has memory ordering semantics as  described in Load LOAcquire, Store LORelease. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STLLRH  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1040, "asmtemplate": "LD1RQB  {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Contiguous load and replicate sixteen bytes (immediate index)", "heading": "LD1RQB (scalar plus immediate)", "para": "Contiguous load and replicate sixteen bytes (immediate index). \n\nLoad sixteen contiguous bytes to elements of a short, 128-bit (quadword)  vector from the memory address generated by a 64-bit scalar base address and  immediate index that is a multiple of 16 in the range -128 to +112 added to  the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first sixteen predicate elements are used  and higher numbered predicate elements are ignored.", "explanations": {"<imm>": "Is the optional signed immediate byte offset, a multiple of 16 in the range -128 to 112, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1RQB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 1261, "asmtemplate": "UQDECP  <Zdn>.<T>, <Pm>.<T>", "brief": "Unsigned saturating decrement vector by count of true predicate elements", "heading": "UQDECP (vector)", "para": "Unsigned saturating decrement vector by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to decrement all destination vector elements. The results are saturated  to the element unsigned integer range. \n\nThe predicate size specifier may be omitted in assembler source code, but this  is deprecated and will be prohibited in a future release of the architecture.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["UQDECP  <Zdn>.<T>, <Pm>.<T>"]}, {"id": 846, "asmtemplate": "SUNPKLO <Zd>.<T>, <Zn>.<Tb>", "brief": "Signed unpack and extend half of vector", "heading": "SUNPKHI, SUNPKLO", "para": "Signed unpack and extend half of vector. \n\nUnpack elements from the lowest or highest half of the source vector and then  sign-extend them to place in elements of twice their size within the  destination vector. This instruction is unpredicated. \n\nIt has encodings from 2 classes: High half and Low half", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["SUNPKHI <Zd>.<T>, <Zn>.<Tb>", "SUNPKLO <Zd>.<T>, <Zn>.<Tb>"]}, {"id": 280, "asmtemplate": "FCVT    <Zd>.S, <Pg>/M, <Zn>.D", "brief": "Floating-point convert precision (predicated)", "heading": "FCVT", "para": "Floating-point convert precision (predicated). \n\nConvert the size and precision of each active floating-point element of the  source vector, and place the results in the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nSince the input and result types have a different size the smaller type is  held unpacked in the least significant bits of elements of the larger size.  When the input is the smaller type the upper bits of each source element are  ignored. When the result is the smaller type the results are zero-extended to  fill each destination element. \n\nIt has encodings from 6 classes: Half-precision to single-precision ,  Half-precision to double-precision , Single-precision to half-precision ,  Single-precision to double-precision , Double-precision to half-precision and  Double-precision to single-precision", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FCVT    <Zd>.S, <Pg>/M, <Zn>.H", "FCVT    <Zd>.D, <Pg>/M, <Zn>.H", "FCVT    <Zd>.H, <Pg>/M, <Zn>.S", "FCVT    <Zd>.D, <Pg>/M, <Zn>.S", "FCVT    <Zd>.H, <Pg>/M, <Zn>.D", "FCVT    <Zd>.S, <Pg>/M, <Zn>.D"]}, {"id": 641, "asmtemplate": "LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Signed Word (unprivileged)", "heading": "LDTRSW", "para": "Load Register Signed Word (unprivileged) loads a word from memory,  sign-extends it to 64 bits, and writes the result to a register. The address  that is used for the load is calculated from a base register and an immediate  offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDTRSW  <Xt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 963, "asmtemplate": "UQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement scalar by multiple of 8-bit predicate constraint element count", "heading": "UQDECB", "para": "Unsigned saturating decrement scalar by multiple of 8-bit predicate constraint  element count. \n\nDetermines the number of active 8-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECB  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQDECB  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 508, "asmtemplate": "LD4  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load multiple 4-element structures to four registers", "heading": "LD4 (multiple structures)", "para": "Load multiple 4-element structures to four registers. This instruction loads  multiple 4-element structures from memory and writes the result to the four  SIMD&FP registers, with de-interleaving. \n\nFor an example of de-interleaving, see LD3 (multiple structures). \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<T><Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", "LD4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 499, "asmtemplate": "UABDL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Absolute Difference Long", "heading": "UABDL, UABDL2", "para": "Unsigned Absolute Difference Long. This instruction subtracts the vector  elements in the lower or upper half of the second source SIMD&FP register from  the corresponding vector elements of the first source SIMD&FP register, places  the absolute value of the result into a vector, and writes the vector to the  destination SIMD&FP register. The destination vector elements are twice as  long as the source vector elements. All the values in this instruction are  unsigned integer values. \n\nThe UABDL instruction extracts each source vector from the lower half of each  source register, while the UABDL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 1037, "asmtemplate": "FRINTN  <Dd>, <Dn>", "brief": "Floating-point Round to Integral, to nearest with ties to even (scalar)", "heading": "FRINTN (scalar)", "para": "Floating-point Round to Integral, to nearest with ties to even (scalar). This  instruction rounds a floating-point value in the SIMD&FP source register to an  integral floating-point value of the same size using the Round to Nearest  rounding mode, and writes the result to the SIMD&FP destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTN  <Hd>, <Hn>"]}, {"id": 549, "asmtemplate": "FSQRT  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Square Root (vector)", "heading": "FSQRT (vector)", "para": "Floating-point Square Root (vector). This instruction calculates the square  root for each vector element in the source SIMD&FP register, places the result  in a vector, and writes the vector to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["FSQRT  <Vd>.<T>, <Vn>.<T>", "FSQRT  <Vd>.<T>, <Vn>.<T>"]}, {"id": 334, "asmtemplate": "ANDS XZR, <Xn>, #<imm>", "brief": "Test bits (immediate)", "heading": "TST (immediate)", "para": "Test bits (immediate), setting the condition flags and discarding the result \n\n: Rn AND imm. \n\nThis is an alias of ANDS (immediate). This means:  \n* The encodings in this description are named to match the encodings of ANDS \n  (immediate). \n* The description of ANDS (immediate) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>": "For the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."}, "encodings": ["TST  <Wn>, #<imm>"]}, {"id": 798, "asmtemplate": "FCVTNU  <Xd>, <Dn>", "brief": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar)", "heading": "FCVTNU (scalar)", "para": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to  even (scalar). This instruction converts the floating-point value in the  SIMD&FP source register to a 32-bit or 64-bit unsigned integer using the Round  to Nearest rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTNU  <Wd>, <Hn>"]}, {"id": 640, "asmtemplate": "PRFW    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous prefetch words (immediate index)", "heading": "PRFW (scalar plus immediate)", "para": "Contiguous prefetch words (immediate index). \n\nContiguous prefetch of word elements from the memory address generated by a  64-bit scalar base and immediate index in the range -32 to 31 which is  multiplied by the vector's in-memory size, irrespective of predication, and  added to the base address. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFW    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1179, "asmtemplate": "LDAXRB  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Exclusive Register Byte", "heading": "LDAXRB", "para": "Load-Acquire Exclusive Register Byte derives an address from a base register  value, loads a byte from memory, zero-extends it and writes it to a register.  The memory access is atomic. The PE marks the physical address being accessed  as an exclusive access. This exclusive access mark is checked by Store  Exclusive instructions. See Synchronization and semaphores. The instruction  also has memory ordering semantics as described in Load-Acquire,  Store-Release. For information about memory accesses see Load/Store addressing  modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDAXRB  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 159, "asmtemplate": "BIC  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise Bit Clear (shifted register)", "heading": "BIC (shifted register)", "para": "Bitwise Bit Clear (shifted register) performs a bitwise AND of a register  value and the complement of an optionally-shifted register value, and writes  the result to the destination register.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["BIC  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 544, "asmtemplate": "SQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement scalar by multiple of 64-bit predicate constraint element count", "heading": "SQDECD (scalar)", "para": "Signed saturating decrement scalar by multiple of 64-bit predicate constraint  element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECD  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQDECD  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 346, "asmtemplate": "FRINTP  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral, toward Plus infinity (vector)", "heading": "FRINTP (vector)", "para": "Floating-point Round to Integral, toward Plus infinity (vector). This  instruction rounds a vector of floating-point values in the SIMD&FP source  register to integral floating-point values of the same size using the Round  towards Plus Infinity rounding mode, and writes the result to the SIMD&FP  destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FRINTP  <Vd>.<T>, <Vn>.<T>", "FRINTP  <Vd>.<T>, <Vn>.<T>"]}, {"id": 94, "asmtemplate": "STNT1H  {<Zt>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store non-temporal halfwords from vector (immediate index)", "heading": "STNT1H (scalar plus immediate)", "para": "Contiguous store non-temporal halfwords from vector (immediate index). \n\nContiguous store non-temporal of halfwords from elements of a vector register  to the memory address generated by a 64-bit scalar base and immediate index in  the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["STNT1H  { <Zt>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1005, "asmtemplate": "BFMLAL<bt><Vd>.4S, <Vn>.8H, <Vm>.8H", "brief": "BFloat16 floating-point widening multiply-add long (vector)", "heading": "BFMLALB, BFMLALT (vector)", "para": "BFloat16 floating-point widening multiply-add long (vector) widens the  even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first and  second source vectors from Bfloat16 to single-precision format. The  instruction then multiplies and adds these values to the overlapping  single-precision elements of the destination vector. \n\nThis performs a fused multiply-add without intermediate rounding that honors  all of the control bits in the FPCR that apply to single-precision arithmetic,  including the rounding mode. It can also generate a floating-point exception  that causes cumulative exception bits in the FPSR to be set, or a synchronous  exception to be taken, depending on the enable bits in the FPCR.  ID_AA64ISAR1_EL1.BF16 indicates whether these instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD", "<bt><Vd>": "Is the name of the SIMD"}, "encodings": ["BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.8H"]}, {"id": 872, "asmtemplate": "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Floating-point fused Multiply-Subtract from accumulator (by element)", "heading": "FMLS (by element)", "para": "Floating-point fused Multiply-Subtract from accumulator (by element). This  instruction multiplies the vector elements in the first source SIMD&FP  register by the specified value in the second source SIMD&FP register, and  subtracts the results from the vector elements of the destination SIMD&FP  register. All the values in this instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar,  single-precision and double-precision , Vector, half-precision and Vector,  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the first SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<Ts><index>": "For the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<Vm>": "For the single-precision and double-precision variant: is the name of the second SIMD"}, "encodings": ["FMLS  <Hd>, <Hn>, <Vm>.H[<index>]", "FMLS  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 834, "asmtemplate": "BRKPAS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Break after first true condition, propagating from previous partition", "heading": "BRKPA, BRKPAS", "para": "Break after first true condition, propagating from previous partition. \n\nIf the last active element of the first source predicate is false then set the  destination predicate to all-false. Otherwise sets destination predicate  elements up to and including the first active and true source element to true,  then sets subsequent elements to false. Inactive elements in the destination  predicate register are set to zero. Optionally sets the First (N), None (Z), \n!Last (C) condition flags based on the predicate result, and the V flag to  zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["BRKPA   <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "BRKPAS  <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 411, "asmtemplate": "ST2H    {<Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store two-halfword structures from two vectors (immediate index)", "heading": "ST2H (scalar plus immediate)", "para": "Contiguous store two-halfword structures from two vectors (immediate index). \n\nContiguous store two-halfword structures, each from the same element number in  two vector registers to the memory address generated by a 64-bit scalar base  and an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive halfwords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST2H    { <Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 820, "asmtemplate": "FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point add immediate (predicated)", "heading": "FADD (immediate)", "para": "Floating-point add immediate (predicated). \n\nAdd an immediate to each active floating-point element of the source vector,  and destructively place the results in the corresponding elements of the  source vector. The immediate may take the value +0.5 or +1.0 only. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 637, "asmtemplate": "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Divide (vector)", "heading": "FDIV (vector)", "para": "Floating-point Divide (vector). This instruction divides the floating-point  values in the elements in the first source SIMD&FP register, by the  floating-point values in the corresponding elements in the second source  SIMD&FP register, places the results in a vector, and writes the vector to the  destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FDIV  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 3, "asmtemplate": "TSB CSYNC", "brief": "Trace Synchronization Barrier", "heading": "TSB CSYNC", "para": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes  the trace operations of instructions. \n\nIf FEAT_TRF is not implemented, this instruction executes as a NOP.", "explanations": {}, "encodings": ["TSB CSYNC"]}, {"id": 140, "asmtemplate": "LDSETLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic bit set on halfword in memory", "heading": "LDSETH, LDSETAH, LDSETALH, LDSETLH", "para": "Atomic bit set on halfword in memory atomically loads a 16-bit halfword from  memory, performs a bitwise OR with the value held in a register on it, and  stores the result back to memory. The value initially loaded from memory is  returned in the destination register.  \n* If the destination register is not WZR, LDSETAH and LDSETALH load from \n  memory with acquire semantics. \n* LDSETLH and LDSETALH store to memory with release semantics. \n* LDSETH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSETH, STSETLH.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDSETAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 1216, "asmtemplate": "UMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Multiply long (vector)", "heading": "UMULL, UMULL2 (vector)", "para": "Unsigned Multiply long (vector). This instruction multiplies corresponding  vector elements in the lower or upper half of the two source SIMD&FP  registers, places the result in a vector, and writes the vector to the  destination SIMD&FP register. The destination vector elements are twice as  long as the elements that are multiplied. All the values in this instruction  are unsigned integer values. \n\nThe UMULL instruction extracts each source vector from the lower half of each  source register, while the UMULL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 999, "asmtemplate": "WHILELT <Pd>.<T>, <R><n>, <R><m>", "brief": "While incrementing signed scalar less than scalar", "heading": "WHILELT", "para": "While incrementing signed scalar less than scalar. \n\nGenerate a predicate that starting from the lowest numbered element is true  while the incrementing value of the first, signed scalar operand is less than  the second scalar operand and false thereafter up to the highest numbered  element. \n\n \n\nThe full width of the scalar operands is significant for the purposes of  comparison, and the full width first operand is incremented by one for each  destination predicate element, irrespective of the predicate result element  size. The first general-purpose source register is not itself updated. \n\nThe predicate result is placed in the predicate destination register. Sets the  First (N), None (Z), !Last (C) condition flags based on the predicate result,  and the V flag to zero.", "explanations": {"<m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T><R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field."}, "encodings": ["WHILELT <Pd>.<T>, <R><n>, <R><m>"]}, {"id": 1064, "asmtemplate": "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", "brief": "Floating-point fused Multiply-Subtract Long from accumulator (by element)", "heading": "FMLSL, FMLSL2 (by element)", "para": "Floating-point fused Multiply-Subtract Long from accumulator (by element).  This instruction multiplies the negated vector elements in the first source  SIMD&FP register by the specified value in the second source SIMD&FP register,  and accumulates the product to the corresponding vector element of the  destination SIMD&FP register. The instruction does not round the result of the  multiply before the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLSL and FMLSL2", "explanations": {"<index>": "Is the element index, encoded in the \"H:L:M\" fields.", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"]}, {"id": 340, "asmtemplate": "ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise inclusive OR NOT (vector)", "heading": "ORN (vector)", "para": "Bitwise inclusive OR NOT (vector). This instruction performs a bitwise OR NOT  between the two source SIMD&FP registers, and writes the result to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["ORN  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 664, "asmtemplate": "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element)", "heading": "SQRDMLSH (by element)", "para": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by  element). This instruction multiplies the vector elements of the first source  SIMD&FP register with the value of a vector element of the second source  SIMD&FP register without saturating the multiply results, doubles the results,  and subtracts the most significant half of the final results from the vector  elements of the destination SIMD&FP register. The results are rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation  bit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SQRDMLSH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 852, "asmtemplate": "ST4D    {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store four-doubleword structures from four vectors (immediate index)", "heading": "ST4D (scalar plus immediate)", "para": "Contiguous store four-doubleword structures from four vectors (immediate  index). \n\nContiguous store four-doubleword structures, each from the same element number  in four vector registers to the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 4 in the range -32 to 28  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive doublewords in  memory which make up each structure. Inactive structures are not written to  memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 601, "asmtemplate": "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]", "brief": "Dot Product signed arithmetic (vector, by element)", "heading": "SDOT (by element)", "para": "Dot Product signed arithmetic (vector, by element). This instruction performs  the dot product of the four 8-bit elements in each 32-bit element of the first  source register with the four 8-bit elements of an indexed 32-bit element in  the second source register, accumulating the result into the corresponding  32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<index>": "Is the element index, encoded in the \"H:L\" fields.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"]}, {"id": 976, "asmtemplate": "SCVTF  <Vd>.<T>, <Vn>.<T>", "brief": "Signed integer Convert to Floating-point (vector)", "heading": "SCVTF (vector, integer)", "para": "Signed integer Convert to Floating-point (vector). This instruction converts  each element in a vector from signed integer to floating-point using the  rounding mode that is specified by the FPCR, and writes the result to the  SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["SCVTF  <Hd>, <Hn>", "SCVTF  <V><d>, <V><n>", "SCVTF  <Vd>.<T>, <Vn>.<T>", "SCVTF  <Vd>.<T>, <Vn>.<T>"]}, {"id": 214, "asmtemplate": "IRG  <Xd|SP>, <Xn|SP>{, <Xm>}", "brief": "Insert Random Tag", "heading": "IRG", "para": "Insert Random Tag inserts a random Logical Address Tag into the address in the  first source register, and writes the result to the destination register. Any  tags specified in the optional second source register or in GCR_EL1.Exclude  are excluded from the selection of the random Logical Address Tag.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Xm\" field. Defaults to XZR if absent.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Xd\" field."}, "encodings": ["IRG  <Xd|SP>, <Xn|SP>{, <Xm>}"]}, {"id": 40, "asmtemplate": "LD2  {<Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Load single 2-element structure to one lane of two registers", "heading": "LD2 (single structure)", "para": "Load single 2-element structure to one lane of two registers. This instruction  loads a 2-element structure from memory and writes the result to the  corresponding elements of the two SIMD&FP registers without affecting the  other bits of the registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "": "\".", "<Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]", "LD2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2"]}, {"id": 671, "asmtemplate": "ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>", "brief": "Arithmetic shift right by immediate (predicated)", "heading": "ASR (immediate, predicated)", "para": "Arithmetic shift right by immediate (predicated). \n\nShift right by immediate, preserving the sign bit, each active element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. The immediate shift amount is an unsigned value  in the range 1 to number of bits per element. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>": "Is the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\"."}, "encodings": ["ASR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>"]}, {"id": 482, "asmtemplate": "LDRSH  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Load Register Signed Halfword (register)", "heading": "LDRSH (register)", "para": "Load Register Signed Halfword (register) calculates an address from a base  register value and an offset register value, loads a halfword from memory,  sign-extends it, and writes it to a register. For information about memory  accesses see Load/Store addressing modes.", "explanations": {"<Xm>": "When ", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDRSH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 65, "asmtemplate": "MLS     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>", "brief": "Multiply-subtract vectors (predicated), writing addend [Zda = Zda - Zn * Zm]", "heading": "MLS", "para": "Multiply-subtract vectors (predicated), writing addend [Zda = Zda - Zn * Zm]. \n\nMultiply the corresponding active elements of the first and second source  vectors and subtract from elements of the third source (addend) vector.  Destructively place the results in the destination and third source (addend)  vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["MLS     <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>"]}, {"id": 1013, "asmtemplate": "AUTIBZ", "brief": "Authenticate Instruction address, using key B", "heading": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB", "para": "Authenticate Instruction address, using key B. This instruction authenticates  an instruction address, using a modifier and key B. \n\nThe address is:  \n* In the general-purpose register that is specified by <Xd> for AUTIB and \n  AUTIZB. \n* In X17, for AUTIB1716. \n* In X30, for AUTIBSP and AUTIBZ.  The modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTIB. \n* The value zero, for AUTIZB and AUTIBZ. \n* In X16, for AUTIB1716. \n* In SP, for AUTIBSP.  If the authentication passes, the upper bits of the address are restored to  enable subsequent use of the address. If the authentication fails, the upper  bits are corrupted and any subsequent use of the address results in a  Translation fault. \n\nIt has encodings from 2 classes: Integer and System", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["AUTIB  <Xd>, <Xn|SP>", "AUTIB1716"]}, {"id": 459, "asmtemplate": "ST3D    {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store three-doubleword structures from three vectors (immediate index)", "heading": "ST3D (scalar plus immediate)", "para": "Contiguous store three-doubleword structures from three vectors (immediate  index). \n\nContiguous store three-doubleword structures, each from the same element  number in three vector registers to the memory address generated by a 64-bit  scalar base and an immediate index which is a multiple of 3 in the range -24  to 21 that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive doublewords in  memory which make up each structure. Inactive structures are not written to  memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 223, "asmtemplate": "PRFH    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous prefetch halfwords (immediate index)", "heading": "PRFH (scalar plus immediate)", "para": "Contiguous prefetch halfwords (immediate index). \n\nContiguous prefetch of halfword elements from the memory address generated by  a 64-bit scalar base and immediate index in the range -32 to 31 which is  multiplied by the vector's in-memory size, irrespective of predication, and  added to the base address. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -32 to 31, defaulting to 0, encoded in the \"imm6\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFH    <prfop>, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1059, "asmtemplate": "DUP<V><d>, <Vn>.<T>[<index>]", "brief": "Move vector element to scalar", "heading": "MOV (scalar)", "para": "Move vector element to scalar. This instruction duplicates the specified  vector element in the SIMD&FP source register into a scalar, and writes the  result to the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of DUP (element). This means:  \n* The encodings in this description are named to match the encodings of DUP \n  (element). \n* The description of DUP (element) gives the operational pseudocode for this \n  instruction.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["MOV  <V><d>, <Vn>.<T>[<index>]"]}, {"id": 626, "asmtemplate": "AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise AND (vector)", "heading": "AND (vector)", "para": "Bitwise AND (vector). This instruction performs a bitwise AND between the two  source SIMD&FP registers, and writes the result to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["AND  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 61, "asmtemplate": "SQRSHRN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Signed saturating Rounded Shift Right Narrow (immediate)", "heading": "SQRSHRN, SQRSHRN2", "para": "Signed saturating Rounded Shift Right Narrow (immediate). This instruction  reads each vector element in the source SIMD&FP register, right shifts each  result by an immediate value, saturates each shifted result to a value that is  half the original width, puts the final result into a vector, and writes the  vector to the lower or upper half of the destination SIMD&FP register. All the  values in this instruction are signed integer values. The destination vector  elements are half as long as the source vector elements. The results are  rounded. For truncated results, see SQSHRN. \n\nThe SQRSHRN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SQRSHRN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Va><n>": "Is the number of the first SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["SQRSHRN  <Vb><d>, <Va><n>, #<shift>", "SQRSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 935, "asmtemplate": "LDLARH  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load LOAcquire Register Halfword", "heading": "LDLARH", "para": "Load LOAcquire Register Halfword loads a halfword from memory, zero-extends  it, and writes it to a register. The instruction also has memory ordering  semantics as described in Load LOAcquire, Store LORelease. For information  about memory accesses, see Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/XZR, it is impossible for  software to observe the presence of the acquire semantic other than its effect  on the arrival at endpoints.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDLARH  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 690, "asmtemplate": "LDSETLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic bit set on byte in memory, without return", "heading": "STSETB, STSETLB", "para": "Atomic bit set on byte in memory, without return, atomically loads an 8-bit  byte from memory, performs a bitwise OR with the value held in a register on  it, and stores the result back to memory.  \n* STSETB does not have release semantics. \n* STSETLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSETB, LDSETAB, LDSETALB, LDSETLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSETB, LDSETAB, LDSETALB, LDSETLB. \n* The description of LDSETB, LDSETAB, LDSETALB, LDSETLB gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSETB  <Ws>, [<Xn|SP>]"]}, {"id": 1054, "asmtemplate": "RET  {<Xn>}", "brief": "Return from subroutine", "heading": "RET", "para": "Return from subroutine branches unconditionally to an address in a register,  with a hint that this is a subroutine return.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field. Defaults to X30 if absent."}, "encodings": ["RET  {<Xn>}"]}, {"id": 311, "asmtemplate": "PFIRST  <Pdn>.B, <Pg>, <Pdn>.B", "brief": "Set the first active predicate element to true", "heading": "PFIRST", "para": "Set the first active predicate element to true. \n\nSets the first active element in the destination predicate to true, otherwise  elements from the source predicate are passed through unchanged. Sets the  First (N), None (Z), !Last (C) condition flags based on the predicate result,  and the V flag to zero.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pdn>": "Is the name of the source and destination scalable predicate register, encoded in the \"Pdn\" field."}, "encodings": ["PFIRST  <Pdn>.B, <Pg>, <Pdn>.B"]}, {"id": 431, "asmtemplate": "URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Rounding Halving Add", "heading": "URHADD", "para": "Unsigned Rounding Halving Add. This instruction adds corresponding unsigned  integer values from the two source SIMD&FP registers, shifts each result right  one bit, places the results into a vector, and writes the vector to the  destination SIMD&FP register. \n\nThe results are rounded. For truncated results, see UHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["URHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 180, "asmtemplate": "DECW    <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Decrement scalar by multiple of predicate constraint element count", "heading": "DECB, DECD, DECH, DECW (scalar)", "para": "Decrement scalar by multiple of predicate constraint element count. \n\nDetermines the number of active elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 4 classes: Byte , Doubleword , Halfword and Word", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["DECB    <Xdn>{, <pattern>{, MUL #<imm>}}", "DECD    <Xdn>{, <pattern>{, MUL #<imm>}}", "DECH    <Xdn>{, <pattern>{, MUL #<imm>}}", "DECW    <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 1155, "asmtemplate": "UQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement scalar by multiple of 32-bit predicate constraint element count", "heading": "UQDECW (scalar)", "para": "Unsigned saturating decrement scalar by multiple of 32-bit predicate  constraint element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECW  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQDECW  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 759, "asmtemplate": "LD4B    {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load four-byte structures to four vectors (immediate index)", "heading": "LD4B (scalar plus immediate)", "para": "Contiguous load four-byte structures to four vectors (immediate index). \n\nContiguous load four-byte structures, each to the same element number in four  vector registers from the memory address generated by a 64-bit scalar base and  an immediate index which is a multiple of 4 in the range -32 to 28 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive bytes in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<imm>": "Is the optional signed immediate vector offset, a multiple of 4 in the range -32 to 28, defaulting to 0, encoded in the \"imm4\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 551, "asmtemplate": "FNMSUB  <Dd>, <Dn>, <Dm>, <Da>", "brief": "Floating-point Negated fused Multiply-Subtract (scalar)", "heading": "FNMSUB", "para": "Floating-point Negated fused Multiply-Subtract (scalar). This instruction  multiplies the values of the first two SIMD&FP source registers, subtracts the  value of the third SIMD&FP source register, and writes the result to the  destination SIMD&FP register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register holding the minuend, encoded in the \"Ra\" field.", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Da>": "Is the 64-bit name of the third SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Ha>": "Is the 16-bit name of the third SIMD", "<Sa>": "Is the 32-bit name of the third SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FNMSUB  <Hd>, <Hn>, <Hm>, <Ha>"]}, {"id": 490, "asmtemplate": "SUB     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Subtract vectors (predicated)", "heading": "SUB (vectors, predicated)", "para": "Subtract vectors (predicated). \n\nSubtract active elements of the second source vector from corresponding  elements of the first source vector and destructively place the results in the  corresponding elements of the first source vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SUB     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 10, "asmtemplate": "CPY<Zd>.<T>, <Pg>/M, #<imm>{, <shift>}", "brief": "Move signed integer immediate to vector elements (merging)", "heading": "MOV (immediate, predicated, merging)", "para": "Move signed integer immediate to vector elements (merging). \n\nMove a signed integer immediate to each active element in the destination  vector. Inactive elements in the destination vector register remain  unmodified. \n\nThe immediate operand is a signed value in the range -128 to +127, and for  element widths of 16 bits or higher it may also be a signed multiple of 256 in  the range -32768 to +32512 (excluding 0). \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<simm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\". \n\nThis is an alias of CPY (immediate, merging). This means:  \n* The encodings in this description are named to match the encodings of CPY \n  (immediate, merging). \n* The description of CPY (immediate, merging) gives the operational pseudocode \n  for this instruction.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>": "Is a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOV     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}"]}, {"id": 174, "asmtemplate": "SMLAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Multiply-Add Long (vector)", "heading": "SMLAL, SMLAL2 (vector)", "para": "Signed Multiply-Add Long (vector). This instruction multiplies corresponding  signed integer values in the lower or upper half of the vectors of the two  source SIMD&FP registers, and accumulates the results with the vector elements  of the destination SIMD&FP register. The destination vector elements are twice  as long as the elements that are multiplied. \n\nThe SMLAL instruction extracts each source vector from the lower half of each  source register, while the SMLAL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 1253, "asmtemplate": "ST2W    {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store two-word structures from two vectors (immediate index)", "heading": "ST2W (scalar plus immediate)", "para": "Contiguous store two-word structures from two vectors (immediate index). \n\nContiguous store two-word structures, each from the same element number in two  vector registers to the memory address generated by a 64-bit scalar base and  an immediate index which is a multiple of 2 in the range -16 to 14 that is  multiplied by the vector's in-memory size, irrespective of predication, \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive words in memory which  make up each structure. Inactive structures are not written to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, a multiple of 2 in the range -16 to 14, defaulting to 0, encoded in the \"imm4\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["ST2W    { <Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 95, "asmtemplate": "LDGM  <Xt>, [<Xn|SP>]", "brief": "Load Tag Multiple", "heading": "LDGM", "para": "Load Tag Multiple reads a naturally aligned block of N Allocation Tags, where  the size of N is identified in GMID_EL1.BS, and writes the Allocation Tag read  from address A to the destination register at 4*A<7:4>+3:4*A<7:4>. Bits of the  destination register not written with an Allocation Tag are set to 0. \n\nThis instruction is undefined at EL0. \n\nThis instruction generates an Unchecked access. \n\nIf ID_AA64PFR1_EL1.MTE != 0b0010, this instruction is undefined.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field."}, "encodings": ["LDGM  <Xt>, [<Xn|SP>]"]}, {"id": 244, "asmtemplate": "SUBS XZR, <Xn|SP>, <R><m>{, <extend>{#<amount>}}", "brief": "Compare (extended register)", "heading": "CMP (extended register)", "para": "Compare (extended register) subtracts a sign or zero-extended register value,  followed by an optional left shift amount, from a register value. The argument  that is extended from the <Rm> register can be a byte, halfword, word, or  doubleword. It updates the condition flags based on the result, and discards  the result. \n\nThis is an alias of SUBS (extended register). This means:  \n* The encodings in this description are named to match the encodings of SUBS \n  (extended register). \n* The description of SUBS (extended register) gives the operational pseudocode \n  for this instruction.", "explanations": {"": " is present but not LSL.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<extend><extend><amount>": "Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when ", "<Wn|WSP>": "Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<R><m>": "Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field."}, "encodings": ["CMP  <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"]}, {"id": 327, "asmtemplate": "SUB  <Xd|SP>, <Xn|SP>, <R><m>{, <extend>{#<amount>}}", "brief": "Subtract (extended register)", "heading": "SUB (extended register)", "para": "Subtract (extended register) subtracts a sign or zero-extended register value,  followed by an optional left shift amount, from a register value, and writes  the result to the destination register. The argument that is extended from the \n<Rm> register can be a byte, halfword, word, or doubleword.", "explanations": {"": " is present but not LSL.", "<R><m>": "Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<extend><extend><amount>": "Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when ", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Wn|WSP>": "Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["SUB  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"]}, {"id": 819, "asmtemplate": "STNT1W  {<Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store non-temporal words from vector (immediate index)", "heading": "STNT1W (scalar plus immediate)", "para": "Contiguous store non-temporal words from vector (immediate index). \n\nContiguous store non-temporal of words from elements of a vector register to  the memory address generated by a 64-bit scalar base and immediate index in  the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["STNT1W  { <Zt>.S }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1247, "asmtemplate": "DMB  <option>|#<imm>", "brief": "Data Memory Barrier", "heading": "DMB", "para": "Data Memory Barrier is a memory barrier that ensures the ordering of  observations of memory accesses, see Data Memory Barrier.", "explanations": {"<imm>": "Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field.", "": "All other encodings of ", "<option>": "Specifies the limitation on the barrier operation. Values are:"}, "encodings": ["DMB  <option>|#<imm>"]}, {"id": 741, "asmtemplate": "LDTRSB  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Signed Byte (unprivileged)", "heading": "LDTRSB", "para": "Load Register Signed Byte (unprivileged) loads a byte from memory,  sign-extends it to 32 bits or 64 bits, and writes the result to a register.  The address that is used for the load is calculated from a base register and  an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDTRSB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 397, "asmtemplate": "UQINCP  <Zdn>.<T>, <Pm>.<T>", "brief": "Unsigned saturating increment vector by count of true predicate elements", "heading": "UQINCP (vector)", "para": "Unsigned saturating increment vector by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to increment all destination vector elements. The results are saturated  to the element unsigned integer range. \n\nThe predicate size specifier may be omitted in assembler source code, but this  is deprecated and will be prohibited in a future release of the architecture.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["UQINCP  <Zdn>.<T>, <Pm>.<T>"]}, {"id": 1129, "asmtemplate": "FRINTP  <Dd>, <Dn>", "brief": "Floating-point Round to Integral, toward Plus infinity (scalar)", "heading": "FRINTP (scalar)", "para": "Floating-point Round to Integral, toward Plus infinity (scalar). This  instruction rounds a floating-point value in the SIMD&FP source register to an  integral floating-point value of the same size using the Round towards Plus  Infinity rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTP  <Hd>, <Hn>"]}, {"id": 463, "asmtemplate": "FCVTNS  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector)", "heading": "FCVTNS (vector)", "para": "Floating-point Convert to Signed integer, rounding to nearest with ties to  even (vector). This instruction converts a scalar or each element in a vector  from a floating-point value to a signed integer value using the Round to  Nearest rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTNS  <Hd>, <Hn>", "FCVTNS  <V><d>, <V><n>", "FCVTNS  <Vd>.<T>, <Vn>.<T>", "FCVTNS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 515, "asmtemplate": "LD3B    {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load three-byte structures to three vectors (immediate index)", "heading": "LD3B (scalar plus immediate)", "para": "Contiguous load three-byte structures to three vectors (immediate index). \n\nContiguous load three-byte structures, each to the same element number in  three vector registers from the memory address generated by a 64-bit scalar  base and an immediate index which is a multiple of 3 in the range -24 to 21  that is multiplied by the vector's in-memory size, irrespective of  predication, \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive bytes in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the three destination vector registers.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, a multiple of 3 in the range -24 to 21, defaulting to 0, encoded in the \"imm4\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32."}, "encodings": ["LD3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1097, "asmtemplate": "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Unsigned Shift Right and Accumulate (immediate)", "heading": "USRA", "para": "Unsigned Shift Right and Accumulate (immediate). This instruction reads each  vector element in the source SIMD&FP register, right shifts each result by an  immediate value, and accumulates the final results with the vector elements of  the destination SIMD&FP register. All the values in this instruction are  unsigned integer values. The results are truncated. For rounded results, see  URSRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["USRA  <V><d>, <V><n>, #<shift>", "USRA  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 957, "asmtemplate": "FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point minimum (predicated)", "heading": "FMIN (vectors)", "para": "Floating-point minimum (predicated). \n\nDetermine the minimum of active floating-point elements of the second source  vector and corresponding floating-point elements of the first source vector  and destructively place the results in the corresponding elements of the first  source vector. If either element value is NaN then the result is NaN. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 436, "asmtemplate": "LD2R  {<Vt>.<T>, <Vt2>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load single 2-element structure and Replicate to all lanes of two registers", "heading": "LD2R", "para": "Load single 2-element structure and Replicate to all lanes of two registers.  This instruction loads a 2-element structure from memory and replicates the  structure to all the lanes of the two SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<T><Vt2>": "Is the name of the second SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", "LD2R  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 1252, "asmtemplate": "EOR<Zdn>.<T>, <Zdn>.<T>, #(-<const> - 1)", "brief": "Bitwise exclusive OR with inverted immediate (unpredicated)", "heading": "EON", "para": "Bitwise exclusive OR with inverted immediate (unpredicated). \n\nBitwise exclusive OR an inverted immediate with each 64-bit element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. The immediate is a 64-bit value consisting of a  single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This  instruction is unpredicated. \n\nThis is a pseudo-instruction of EOR (immediate). This means:  \n* The encodings in this description are named to match the encodings of EOR \n  (immediate). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of EOR (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<T><const>": "Is a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["EON     <Zdn>.<T>, <Zdn>.<T>, #<const>"]}, {"id": 895, "asmtemplate": "LDP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", "brief": "Load Pair of Registers", "heading": "LDP", "para": "Load Pair of Registers calculates an address from a base register value and an  immediate offset, loads two 32-bit words or two 64-bit doublewords from  memory, and writes them to two registers. For information about memory  accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"": "/8.", "<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<imm>": "For the 64-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDP  <Wt1>, <Wt2>, [<Xn|SP>], #<imm>", "LDP  <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!", "LDP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 825, "asmtemplate": "SDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]", "brief": "Signed integer indexed dot product", "heading": "SDOT (indexed)", "para": "Signed integer indexed dot product. \n\nThe signed integer indexed dot product instruction computes the dot product of  a group of four signed 8-bit or 16-bit integer values held in each 32-bit or  64-bit element of the first source vector multiplied by a group of four signed  8-bit or 16-bit integer values in an indexed 32-bit or 64-bit element of the  second source vector, and then destructively adds the widened dot product to  the corresponding 32-bit or 64-bit element of the destination vector. \n\nThe groups within the second source vector are specified using an immediate  index which selects the same group position within each 128-bit vector  segment. The index range is from 0 to one less than the number of groups per  128-bit segment, encoded in 1 to 2 bits depending on the size of the group.  This instruction is unpredicated. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<imm>": "For the 64-bit variant: is the immediate index of a quadtuplet of four 16-bit elements within each 128-bit vector segment, in the range 0 to 1, encoded in the \"i1\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "For the 64-bit variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["SDOT    <Zda>.S, <Zn>.B, <Zm>.B[<imm>]", "SDOT    <Zda>.D, <Zn>.H, <Zm>.H[<imm>]"]}, {"id": 930, "asmtemplate": "ORR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Bitwise inclusive OR vectors (predicated)", "heading": "ORR (vectors, predicated)", "para": "Bitwise inclusive OR vectors (predicated). \n\nBitwise inclusive OR active elements of the second source vector with  corresponding elements of the first source vector and destructively place the  results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ORR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 980, "asmtemplate": "ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Add Pairwise (vector)", "heading": "ADDP (vector)", "para": "Add Pairwise (vector). This instruction creates a vector by concatenating the  vector elements of the first source SIMD&FP register after the vector elements  of the second source SIMD&FP register, reads each pair of adjacent vector  elements from the concatenated vector, adds each pair of values together,  places the result into a vector, and writes the vector to the destination  SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["ADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 288, "asmtemplate": "STLXR  <Ws>, <Xt>, [<Xn|SP>{,#0}]", "brief": "Store-Release Exclusive Register", "heading": "STLXR", "para": "Store-Release Exclusive Register stores a 32-bit word or a 64-bit doubleword  to memory if the PE has exclusive access to the memory address, from two  registers, and returns a status value of 0 if the store was successful, or of  1 if no store was performed. See Synchronization and semaphores. The memory  access is atomic. The instruction also has memory ordering semantics as  described in Load-Acquire, Store-Release. For information about memory  accesses see Load/Store addressing modes.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STLXR  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 355, "asmtemplate": "INSR    <Zdn>.<T>, <V><m>", "brief": "Insert SIMD&FP scalar register in shifted vector", "heading": "INSR (SIMD&FP scalar)", "para": "Insert SIMD&FP scalar register in shifted vector. \n\nShift the destination vector left by one element, and then place a copy of the  SIMD&FP scalar register in element 0 of the destination vector. This  instruction is unpredicated.", "explanations": {"": "FP register, encoded in the \"Vm\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><V><m>": "Is the number [0-31] of the source SIMD"}, "encodings": ["INSR    <Zdn>.<T>, <V><m>"]}, {"id": 63, "asmtemplate": "LDAPURB  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Load-Acquire RCpc Register Byte (unscaled)", "heading": "LDAPURB", "para": "Load-Acquire RCpc Register Byte (unscaled) calculates an address from a base  register and an immediate offset, loads a byte from memory, zero-extends it,  and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDAPURB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 217, "asmtemplate": "SQXTUN{2}<Vd>.<Tb>, <Vn>.<Ta>", "brief": "Signed saturating extract Unsigned Narrow", "heading": "SQXTUN, SQXTUN2", "para": "Signed saturating extract Unsigned Narrow. This instruction reads each signed  integer value in the vector of the source SIMD&FP register, saturates the  value to an unsigned integer value that is half the original width, places the  result into a vector, and writes the vector to the lower or upper half of the  destination SIMD&FP register. The destination vector elements are half as long  as the source vector elements. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQXTUN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SQXTUN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"<Va><n>": "Is the number of the SIMD", "2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["SQXTUN  <Vb><d>, <Va><n>", "SQXTUN{2}  <Vd>.<Tb>, <Vn>.<Ta>"]}, {"id": 990, "asmtemplate": "SMMLA   <Zda>.S, <Zn>.B, <Zm>.B", "brief": "Signed integer matrix multiply-accumulate", "heading": "SMMLA", "para": "Signed integer matrix multiply-accumulate. \n\nThe signed integer matrix multiply-accumulate instruction multiplies the 2\u00d78  matrix of signed 8-bit integer values held in each 128-bit segment of the  first source vector by the 8\u00d72 matrix of signed 8-bit integer values in the  corresponding segment of the second source vector. The resulting 2\u00d72 widened  32-bit integer matrix product is then destructively added to the 32-bit  integer matrix accumulator held in the corresponding segment of the addend and  destination vector. This is equivalent to performing an 8-way dot product per  destination element. \n\nThis instruction is unpredicated. \n\nID_AA64ZFR0_EL1.I8MM indicates whether this instruction is implemented.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SMMLA   <Zda>.S, <Zn>.B, <Zm>.B"]}, {"id": 1184, "asmtemplate": "DCPS3  {#<imm>}", "brief": "Debug Change PE State to EL3", "heading": "DCPS3", "para": "Debug Change PE State to EL3, when executed in Debug state:  \n* If executed at EL3 selects SP_EL3. \n* Otherwise, changes the current Exception level and SP to EL3 using SP_EL3.  The target exception level of a DCPS3 instruction is EL3. \n\nOn executing a DCPS3 instruction:  \n* ELR_EL3 becomes unknown. \n* SPSR_EL3 becomes unknown. \n* ESR_EL3 becomes unknown. \n* DLR_EL0 and DSPSR_EL0 become unknown. \n* The endianness is set according to SCTLR_EL3.EE.  This instruction is undefined at all exception levels if either:  \n* EDSCR.SDD == 1. \n* EL3 is not implemented.  This instruction is always undefined in Non-debug state. \n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "explanations": {"<imm>": "Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."}, "encodings": ["DCPS3  {#<imm>}"]}, {"id": 1171, "asmtemplate": "LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Halfword (unprivileged)", "heading": "LDTRH", "para": "Load Register Halfword (unprivileged) loads a halfword from memory,  zero-extends it, and writes the result to a register. The address that is used  for the load is calculated from a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."}, "encodings": ["LDTRH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 907, "asmtemplate": "FRINT64Z  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to 64-bit Integer toward Zero (vector)", "heading": "FRINT64Z (vector)", "para": "Floating-point Round to 64-bit Integer toward Zero (vector). This instruction  rounds a vector of floating-point values in the SIMD&FP source register to  integral floating-point values that fit into a 64-bit integer size using the  Round towards Zero rounding mode, and writes the result to the SIMD&FP  destination register. \n\nA zero input returns a zero result with the same sign. When one of the result  values is not numerically equal to the corresponding input value, an Inexact  exception is raised. When an input is infinite, NaN or out-of-range, the  instruction returns for the corresponding result value the most negative  integer representable in the destination size, and an Invalid Operation  floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD"}, "encodings": ["FRINT64Z  <Vd>.<T>, <Vn>.<T>"]}, {"id": 161, "asmtemplate": "RDFFR   <Pd>.B", "brief": "Read the first-fault register", "heading": "RDFFR (unpredicated)", "para": "Read the first-fault register. \n\nRead the first-fault register (FFR) and place in the destination predicate  without predication.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["RDFFR   <Pd>.B"]}, {"id": 864, "asmtemplate": "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Shift Left (register)", "heading": "USHL", "para": "Unsigned Shift Left (register). This instruction takes each element in the  vector of the first source SIMD&FP register, shifts each element by a value  from the least significant byte of the corresponding element of the second  source SIMD&FP register, places the results in a vector, and writes the vector  to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift  value is negative, it is a truncating right shift. For a rounding shift, see  URSHL. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["USHL  <V><d>, <V><n>, <V><m>", "USHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 15, "asmtemplate": "SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S", "brief": "SM3PARTW2", "heading": "SM3PARTW2", "para": "SM3PARTW2 takes three 128-bit vectors from three source SIMD&FP registers and  returns a 128-bit result in the destination SIMD&FP register. The result is  obtained by a three-way exclusive OR of the elements within the input vectors  with some fixed rotations, see the Operation pseudocode for more information. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SM3PARTW2  <Vd>.4S, <Vn>.4S, <Vm>.4S"]}, {"id": 1144, "asmtemplate": "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Absolute Compare Greater than (vector)", "heading": "FACGT", "para": "Floating-point Absolute Compare Greater than (vector). This instruction  compares the absolute value of each vector element in the first source SIMD&FP  register with the absolute value of the corresponding vector element in the  second source SIMD&FP register and if the first value is greater than the  second value sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<m>": "Is the number of the second SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the first SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<V><d>": "Is the number of the SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["FACGT  <Hd>, <Hn>, <Hm>", "FACGT  <V><d>, <V><n>, <V><m>", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FACGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 376, "asmtemplate": "LDSMAXLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic signed maximum on halfword in memory", "heading": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH", "para": "Atomic signed maximum on halfword in memory atomically loads a 16-bit halfword  from memory, compares it against the value held in a register, and stores the  larger value back to memory, treating the values as signed numbers. The value  initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDSMAXAH and LDSMAXALH load from \n  memory with acquire semantics. \n* LDSMAXLH and LDSMAXALH store to memory with release semantics. \n* LDSMAXH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMAXH, STSMAXLH.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDSMAXAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 291, "asmtemplate": "UADDW{2}<Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", "brief": "Unsigned Add Wide", "heading": "UADDW, UADDW2", "para": "Unsigned Add Wide. This instruction adds the vector elements of the first  source SIMD&FP register to the corresponding vector elements in the lower or  upper half of the second source SIMD&FP register, places the result in a  vector, and writes the vector to the SIMD&FP destination register. The vector  elements of the destination register and the first source register are twice  as long as the vector elements of the second source register. All the values  in this instruction are unsigned integer values. \n\nThe UADDW instruction extracts vector elements from the lower half of the  second source register, while the UADDW2 instruction extracts vector elements  from the upper half of the second source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UADDW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"]}, {"id": 470, "asmtemplate": "TBL  <Vd>.<Ta>, {<Vn>.16B }, <Vm>.<Ta>", "brief": "Table vector Lookup", "heading": "TBL", "para": "Programmable table lookup in single vector table. \n\nReads each element of the second source (index) vector and uses its value to  select an indexed element from the first source (table) vector, and places the  indexed table element in the destination vector element corresponding to the  index vector element. If an index value is greater than or equal to the number  of vector elements then it places zero in the corresponding destination vector  element. \n\nSince the index values can select any element in a vector this operation is  not naturally vector length agnostic.", "explanations": {"": "FP index register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vn+1>": "Is the name of the second SIMD", "<Vn+3>": "Is the name of the fourth SIMD", "<Ta><Vn>": "For the four register table, three register table and two register table variant: is the name of the first SIMD", "<Vn+2>": "Is the name of the third SIMD", "<Vm>": "Is the name of the SIMD", "<Vn>": "For the single register table variant: is the name of the SIMD"}, "encodings": ["TBL     <Zd>.<T>, { <Zn>.<T> }, <Zm>.<T>"]}, {"id": 695, "asmtemplate": "LD1ROB  {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load and replicate thirty-two bytes (scalar index)", "heading": "LD1ROB (scalar plus scalar)", "para": "Contiguous load and replicate thirty-two bytes (scalar index). \n\nLoad thirty-two contiguous bytes to elements of a 256-bit (octaword) vector  from the memory address generated by a 64-bit scalar base address and scalar  index which is added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first thirty-two predicate elements are used and higher numbered  predicate elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1ROB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 162, "asmtemplate": "EXTR  <Xd>, <Xn>, <Xm>, #<lsb>", "brief": "Extract register", "heading": "EXTR", "para": "Extract register extracts a register from a pair of registers. \n\nThis instruction is used by the alias ROR (immediate).", "explanations": {"<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the least significant bit position from which to extract, in the range 0 to 63, encoded in the \"imms\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["EXTR  <Wd>, <Wn>, <Wm>, #<lsb>"]}, {"id": 1111, "asmtemplate": "LDFF1B  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault unsigned bytes to vector (vector index)", "heading": "LDFF1B (scalar plus vector)", "para": "Gather load first-fault unsigned bytes to vector (vector index). \n\nGather load with first-faulting behavior of unsigned bytes to active elements  of a vector register from memory addresses generated by a 64-bit scalar base  plus vector index. The index values are optionally sign or zero-extended from  32 to 64 bits. Inactive elements will not cause a read from Device memory or  signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 32-bit unpacked unscaled offset , 32-bit  unscaled offset and 64-bit unscaled offset", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 662, "asmtemplate": "FRINTM  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral, toward Minus infinity (vector)", "heading": "FRINTM (vector)", "para": "Floating-point Round to Integral, toward Minus infinity (vector). This  instruction rounds a vector of floating-point values in the SIMD&FP source  register to integral floating-point values of the same size using the Round  towards Minus Infinity rounding mode, and writes the result to the SIMD&FP  destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"<Vd>": "Is the name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FRINTM  <Vd>.<T>, <Vn>.<T>", "FRINTM  <Vd>.<T>, <Vn>.<T>"]}, {"id": 1035, "asmtemplate": "SCVTF   <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Signed integer convert to floating-point (predicated)", "heading": "SCVTF", "para": "Signed integer convert to floating-point (predicated). \n\nConvert to floating-point from the signed integer in each active element of  the source vector, and place the results in the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nIf the input and result types have a different size the smaller type is held  unpacked in the least significant bits of elements of the larger size. When  the input is the smaller type the upper bits of each source element are  ignored. When the result is the smaller type the results are zero-extended to  fill each destination element. \n\nIt has encodings from 7 classes: 16-bit to half-precision , 32-bit to  half-precision , 32-bit to single-precision , 32-bit to double-precision ,  64-bit to half-precision , 64-bit to single-precision and 64-bit to  double-precision", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["SCVTF   <Zd>.H, <Pg>/M, <Zn>.H", "SCVTF   <Zd>.H, <Pg>/M, <Zn>.S", "SCVTF   <Zd>.S, <Pg>/M, <Zn>.S", "SCVTF   <Zd>.D, <Pg>/M, <Zn>.S", "SCVTF   <Zd>.H, <Pg>/M, <Zn>.D", "SCVTF   <Zd>.S, <Pg>/M, <Zn>.D", "SCVTF   <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 383, "asmtemplate": "STNT1D  {<Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous store non-temporal doublewords from vector (scalar index)", "heading": "STNT1D (scalar plus scalar)", "para": "Contiguous store non-temporal doublewords from vector (scalar index). \n\nContiguous store non-temporal of doublewords from elements of a vector  register to the memory address generated by a 64-bit scalar base and scalar  index which is multiplied by 8 and added to the base address. After each  element access the index value is incremented, but the index register is not  updated. Inactive elements are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["STNT1D  { <Zt>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 703, "asmtemplate": "AND     <Zd>.D, <Zn>.D, <Zm>.D", "brief": "Bitwise AND vectors (unpredicated)", "heading": "AND (vectors, unpredicated)", "para": "Bitwise AND vectors (unpredicated). \n\nBitwise AND all elements of the second source vector with corresponding  elements of the first source vector and place the results in the corresponding  elements of the destination vector. This instruction is unpredicated.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["AND     <Zd>.D, <Zn>.D, <Zm>.D"]}, {"id": 766, "asmtemplate": "FCPY<Zd>.<T>, <Pg>/M, #<const>", "brief": "Move 8-bit floating-point immediate to vector elements (predicated)", "heading": "FMOV (immediate, predicated)", "para": "Move 8-bit floating-point immediate to vector elements (predicated). \n\nMove a floating-point immediate into each active element in the destination  vector. Inactive elements in the destination vector register remain  unmodified. \n\nThis is an alias of FCPY. This means:  \n* The encodings in this description are named to match the encodings of FCPY. \n* The description of FCPY gives the operational pseudocode for this \n  instruction.", "explanations": {"": "\u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<const>": "Is a floating-point immediate value expressable as ", "<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["FMOV    <Zd>.<T>, <Pg>/M, #<const>"]}, {"id": 116, "asmtemplate": "ST2D    {<Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous store two-doubleword structures from two vectors (scalar index)", "heading": "ST2D (scalar plus scalar)", "para": "Contiguous store two-doubleword structures from two vectors (scalar index). \n\nContiguous store two-doubleword structures, each from the same element number  in two vector registers to the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by two. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive doublewords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST2D    { <Zt1>.D, <Zt2>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 816, "asmtemplate": "TRN2    <Zd>.Q, <Zn>.Q, <Zm>.Q", "brief": "Interleave even or odd elements from two vectors", "heading": "TRN1, TRN2 (vectors)", "para": "Interleave even or odd elements from two vectors. \n\nInterleave alternating even or odd-numbered elements from the first and second  source vectors and place in elements of the destination vector. This  instruction is unpredicated. The 128-bit element variant of this instruction  requires that the current vector length is at least 256 bits, and if the  current vector length is not an integer multiple of 256 bits then the trailing  bits are set to zero. \n\nID_AA64ZFR0_EL1.F64MM indicates whether the 128-bit element variant of the  instruction is implemented. \n\nIt has encodings from 4 classes: Even , Even (quadwords) , Odd and Odd \n(quadwords)", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["TRN1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "TRN1    <Zd>.Q, <Zn>.Q, <Zm>.Q", "TRN2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "TRN2    <Zd>.Q, <Zn>.Q, <Zm>.Q"]}, {"id": 1225, "asmtemplate": "SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Minimum Pairwise", "heading": "SMINP", "para": "Signed Minimum Pairwise. This instruction creates a vector by concatenating  the vector elements of the first source SIMD&FP register after the vector  elements of the second source SIMD&FP register, reads each pair of adjacent  vector elements in the two source SIMD&FP registers, writes the smallest of  each pair of signed integer values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMINP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 607, "asmtemplate": "LSLV  <Xd>, <Xn>, <Xm>", "brief": "Logical Shift Left Variable", "heading": "LSLV", "para": "Logical Shift Left Variable shifts a register value left by a variable number  of bits, shifting in zeros, and writes the result to the destination register.  The remainder obtained by dividing the second source register by the data size  defines the number of bits by which the first source register is left-shifted. \n\nThis instruction is used by the alias LSL (register).", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["LSLV  <Wd>, <Wn>, <Wm>"]}, {"id": 391, "asmtemplate": "SQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}", "brief": "Signed saturating add immediate (unpredicated)", "heading": "SQADD (immediate)", "para": "Signed saturating add immediate (unpredicated). \n\nSigned saturating add of an unsigned immediate to each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. Each result element is saturated to the N-bit element's  signed integer range -2(N-1) to (2(N-1) )-1. This instruction is unpredicated. \n\nThe immediate is an unsigned value in the range 0 to 255, and for element  widths of 16 bits or higher it may also be a positive multiple of 256 in the  range 256 to 65280. \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<uimm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\".", "explanations": {"<T><imm>": "Is an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["SQADD   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}"]}, {"id": 468, "asmtemplate": "STR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Store Register (register)", "heading": "STR (register)", "para": "Store Register (register) calculates an address from a base register value and  an offset register value, and stores a 32-bit word or a 64-bit doubleword to  the calculated address, from a register. For information about memory  accesses, see Load/Store addressing modes. \n\nThe instruction uses an offset addressing mode, that calculates the address  used for the memory access from a base register value and an offset register  value. The offset can be optionally shifted and extended.", "explanations": {"<Xm>": "When ", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 1082, "asmtemplate": "NORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise NOR predicates", "heading": "NOR, NORS", "para": "Bitwise NOR predicates. \n\nBitwise NOR active elements of the second source predicate with corresponding  elements of the first source predicate and place the results in the  corresponding elements of the destination predicate. Inactive elements in the  destination predicate register are set to zero. Optionally sets the First (N),  None (Z), !Last (C) condition flags based on the predicate result, and the V  flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["NOR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "NORS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 622, "asmtemplate": "FMSB    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>", "brief": "Floating-point fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za + -Zdn * Zm]", "heading": "FMSB", "para": "Floating-point fused multiply-subtract vectors (predicated), writing  multiplicand [Zdn = Za + -Zdn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and subtract from elements of the third (addend) vector  without intermediate rounding. Destructively place the results in the  destination and first source (multiplicand) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Za>": "Is the name of the third source scalable vector register, encoded in the \"Za\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FMSB    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>"]}, {"id": 1012, "asmtemplate": "SMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Multiply Long (vector)", "heading": "SMULL, SMULL2 (vector)", "para": "Signed Multiply Long (vector). This instruction multiplies corresponding  signed integer values in the lower or upper half of the vectors of the two  source SIMD&FP registers, places the results in a vector, and writes the  vector to the destination SIMD&FP register. \n\nThe destination vector elements are twice as long as the elements that are  multiplied. \n\nThe SMULL instruction extracts each source vector from the lower half of each  source register, while the SMULL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 952, "asmtemplate": "SUBPS  <Xd>, <Xn|SP>, <Xm|SP>", "brief": "Subtract Pointer, setting Flags", "heading": "SUBPS", "para": "Subtract Pointer, setting Flags subtracts the 56-bit address held in the  second source register from the 56-bit address held in the first source  register, sign-extends the result to 64-bits, and writes the result to the  destination register. It updates the condition flags based on the result of  the subtraction. \n\nThis instruction is used by the alias CMPP.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Xd\" field.", "<Xm|SP>": "Is the 64-bit name of the second general-purpose source register or stack pointer, encoded in the \"Xm\" field."}, "encodings": ["SUBPS  <Xd>, <Xn|SP>, <Xm|SP>"]}, {"id": 236, "asmtemplate": "SUBS XZR, <Xn|SP>, #<imm>{, <shift>}", "brief": "Compare (immediate)", "heading": "CMP (immediate)", "para": "Compare (immediate) subtracts an optionally-shifted immediate value from a  register value. It updates the condition flags based on the result, and  discards the result. \n\nThis is an alias of SUBS (immediate). This means:  \n* The encodings in this description are named to match the encodings of SUBS \n  (immediate). \n* The description of SUBS (immediate) gives the operational pseudocode for \n  this instruction.", "explanations": {"<imm>": "Is an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["CMP  <Wn|WSP>, #<imm>{, <shift>}"]}, {"id": 1007, "asmtemplate": "ASRV<Xd>, <Xn>, <Xm>", "brief": "Arithmetic Shift Right (register)", "heading": "ASR (register)", "para": "Arithmetic Shift Right (register) shifts a register value right by a variable  number of bits, shifting in copies of its sign bit, and writes the result to  the destination register. The remainder obtained by dividing the second source  register by the data size defines the number of bits by which the first source  register is right-shifted. \n\nThis is an alias of ASRV. This means:  \n* The encodings in this description are named to match the encodings of ASRV. \n* The description of ASRV gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ASR  <Wd>, <Wn>, <Wm>"]}, {"id": 1140, "asmtemplate": "LDEORL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic exclusive OR on word or doubleword in memory, without return", "heading": "STEOR, STEORL", "para": "Atomic exclusive OR on word or doubleword in memory, without return,  atomically loads a 32-bit word or 64-bit doubleword from memory, performs an  exclusive OR with the value held in a register on it, and stores the result  back to memory.  \n* STEOR does not have release semantics. \n* STEORL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDEOR, LDEORA, LDEORAL, LDEORL. This means:  \n* The encodings in this description are named to match the encodings of LDEOR, \n  LDEORA, LDEORAL, LDEORL. \n* The description of LDEOR, LDEORA, LDEORAL, LDEORL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STEOR  <Ws>, [<Xn|SP>]"]}, {"id": 1230, "asmtemplate": "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Compare Greater than or Equal (vector)", "heading": "FCMGE (register)", "para": "Floating-point Compare Greater than or Equal (vector). This instruction reads  each floating-point value in the first source SIMD&FP register and if the  value is greater than or equal to the corresponding floating-point value in  the second source SIMD&FP register sets every bit of the corresponding vector  element in the destination SIMD&FP register to one, otherwise sets every bit  of the corresponding vector element in the destination SIMD&FP register to  zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<V><d>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["FCMGE  <Hd>, <Hn>, <Hm>", "FCMGE  <V><d>, <V><n>, <V><m>", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FCMGE  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 894, "asmtemplate": "ST3W    {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous store three-word structures from three vectors (scalar index)", "heading": "ST3W (scalar plus scalar)", "para": "Contiguous store three-word structures from three vectors (scalar index). \n\nContiguous store three-word structures, each from the same element number in  three vector registers to the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by three. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive words in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 296, "asmtemplate": "LDEORLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic exclusive OR on byte in memory, without return", "heading": "STEORB, STEORLB", "para": "Atomic exclusive OR on byte in memory, without return, atomically loads an  8-bit byte from memory, performs an exclusive OR with the value held in a  register on it, and stores the result back to memory.  \n* STEORB does not have release semantics. \n* STEORLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDEORB, LDEORAB, LDEORALB, LDEORLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDEORB, LDEORAB, LDEORALB, LDEORLB. \n* The description of LDEORB, LDEORAB, LDEORALB, LDEORLB gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STEORB  <Ws>, [<Xn|SP>]"]}, {"id": 748, "asmtemplate": "FNEG    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Floating-point negate (predicated)", "heading": "FNEG", "para": "Floating-point negate (predicated). \n\nNegate each active floating-point element of the source vector, and place the  results in the corresponding elements of the destination vector. This inverts  the sign bit and cannot signal a floating-point exception. Inactive elements  in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FNEG    <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 1126, "asmtemplate": "BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise Insert if True", "heading": "BIT", "para": "Bitwise Insert if True. This instruction inserts each bit from the first  source SIMD&FP register into the SIMD&FP destination register if the  corresponding bit of the second source SIMD&FP register is 1, otherwise leaves  the bit in the destination register unchanged. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["BIT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 675, "asmtemplate": "ST4  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T>}, [<Xn|SP>], <Xm>", "brief": "Store multiple 4-element structures from four registers", "heading": "ST4 (multiple structures)", "para": "Store multiple 4-element structures from four registers. This instruction  stores multiple 4-element structures to memory from four SIMD&FP registers,  with interleaving. Every element of each register is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<T><Vt2>": "Is the name of the second SIMD"}, "encodings": ["ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", "ST4  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 102, "asmtemplate": "LDXRH  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load Exclusive Register Halfword", "heading": "LDXRH", "para": "Load Exclusive Register Halfword derives an address from a base register  value, loads a halfword from memory, zero-extends it and writes it to a  register. The memory access is atomic. The PE marks the physical address being  accessed as an exclusive access. This exclusive access mark is checked by  Store Exclusive instructions. See Synchronization and semaphores. For  information about memory accesses see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDXRH  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1213, "asmtemplate": "LDP  <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]", "brief": "Load Pair of SIMD&FP registers", "heading": "LDP (SIMD&FP)", "para": "Load Pair of SIMD&FP registers. This instruction loads a pair of SIMD&FP  registers from memory. The address that is used for the load is calculated  from a base register value and an optional immediate offset. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"": "/16.", "<St1>": "Is the 32-bit name of the first SIMD", "<Dt1>": "Is the 64-bit name of the first SIMD", "<Qt1>": "Is the 128-bit name of the first SIMD", "<imm>": "For the 128-bit signed offset variant: is the optional signed immediate byte offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"imm7\" field as ", "<St2>": "Is the 32-bit name of the second SIMD", "<Qt2>": "Is the 128-bit name of the second SIMD", "<Dt2>": "Is the 64-bit name of the second SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDP  <St1>, <St2>, [<Xn|SP>], #<imm>", "LDP  <St1>, <St2>, [<Xn|SP>, #<imm>]!", "LDP  <St1>, <St2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 35, "asmtemplate": "EXT     <Zdn>.B, <Zdn>.B, <Zm>.B, #<imm>", "brief": "Extract vector from pair of vectors", "heading": "EXT", "para": "Extract vector from pair of vectors. \n\nCopy the indexed byte up to the last byte of the first source vector to the  bottom of the result vector, then fill the remainder of the result starting  from the first byte of the second source vector. The result is placed  destructively in the first source vector. This instruction is unpredicated. \n\nAn index that is greater than or equal to the vector length in bytes is  treated as zero, leaving the destination and first source vector unmodified.", "explanations": {"<imm>": "Is the unsigned immediate operand, in the range 0 to 255, encoded in the \"imm8h:imm8l\" fields.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["EXT     <Zdn>.B, <Zdn>.B, <Zm>.B, #<imm>"]}, {"id": 1194, "asmtemplate": "UBFM<Xd>, <Xn>, #(-<shift> MOD 64), #(63-<shift>)", "brief": "Logical Shift Left (immediate)", "heading": "LSL (immediate)", "para": "Logical Shift Left (immediate) shifts a register value left by an immediate  number of bits, shifting in zeros, and writes the result to the destination  register. \n\nThis is an alias of UBFM. This means:  \n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the shift amount, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["LSL  <Wd>, <Wn>, #<shift>"]}, {"id": 196, "asmtemplate": "LD2B    {<Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load two-byte structures to two vectors (scalar index)", "heading": "LD2B (scalar plus scalar)", "para": "Contiguous load two-byte structures to two vectors (scalar index). \n\nContiguous load two-byte structures, each to the same element number in two  vector registers from the memory address generated by a 64-bit scalar base and  a 64-bit scalar index register and added to the base address. After each  structure access the index value is incremented by two. The index register is  not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive bytes in memory which  make up each structure. Inactive elements will not cause a read from Device  memory or signal a fault, and the corresponding element is set to zero in each  of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD2B    { <Zt1>.B, <Zt2>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 651, "asmtemplate": "SBFM<Xd>, <Xn>, #<shift>, #63", "brief": "Arithmetic Shift Right (immediate)", "heading": "ASR (immediate)", "para": "Arithmetic Shift Right (immediate) shifts a register value right by an  immediate number of bits, shifting in copies of the sign bit in the upper bits  and zeros in the lower bits, and writes the result to the destination  register. \n\nThis is an alias of SBFM. This means:  \n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the \"immr\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ASR  <Wd>, <Wn>, #<shift>"]}, {"id": 179, "asmtemplate": "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Signed Rounding Shift Right (immediate)", "heading": "SRSHR", "para": "Signed Rounding Shift Right (immediate). This instruction reads each vector  element in the source SIMD&FP register, right shifts each result by an  immediate value, places the final result into a vector, and writes the vector  to the destination SIMD&FP register. All the values in this instruction are  signed integer values. The results are rounded. For truncated results, see  SSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SRSHR  <V><d>, <V><n>, #<shift>", "SRSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 900, "asmtemplate": "WHILELS <Pd>.<T>, <R><n>, <R><m>", "brief": "While incrementing unsigned scalar lower or same as scalar", "heading": "WHILELS", "para": "While incrementing unsigned scalar lower or same as scalar. \n\nGenerate a predicate that starting from the lowest numbered element is true  while the incrementing value of the first, unsigned scalar operand is lower or  same as the second scalar operand and false thereafter up to the highest  numbered element. \n\nIf the second scalar operand is equal to the maximum unsigned integer value  then a condition which includes an equality test can never fail and the result  will be an all-true predicate. \n\nThe full width of the scalar operands is significant for the purposes of  comparison, and the full width first operand is incremented by one for each  destination predicate element, irrespective of the predicate result element  size. The first general-purpose source register is not itself updated. \n\nThe predicate result is placed in the predicate destination register. Sets the  First (N), None (Z), !Last (C) condition flags based on the predicate result,  and the V flag to zero.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<T><R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field."}, "encodings": ["WHILELS <Pd>.<T>, <R><n>, <R><m>"]}, {"id": 326, "asmtemplate": "ST4W    {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous store four-word structures from four vectors (scalar index)", "heading": "ST4W (scalar plus scalar)", "para": "Contiguous store four-word structures from four vectors (scalar index). \n\nContiguous store four-word structures, each from the same element number in  four vector registers to the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by four. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive words in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 373, "asmtemplate": "USHLL{2}<Vd>.<Ta>, <Vn>.<Tb>, #0", "brief": "Unsigned extend Long", "heading": "UXTL, UXTL2", "para": "Unsigned extend Long. This instruction copies each vector element from the  lower or upper half of the source SIMD&FP register into a vector, and writes  the vector to the destination SIMD&FP register. The destination vector  elements are twice as long as the source vector elements. \n\nThe UXTL instruction extracts vector elements from the lower half of the  source register, while the UXTL2 instruction extracts vector elements from the  upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of USHLL, USHLL2. This means:  \n* The encodings in this description are named to match the encodings of USHLL, \n  USHLL2. \n* The description of USHLL, USHLL2 gives the operational pseudocode for this \n  instruction.", "explanations": {"<Ta><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD"}, "encodings": ["UXTL{2}  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 1081, "asmtemplate": "ESB", "brief": "Error Synchronization Barrier", "heading": "ESB", "para": "Error Synchronization Barrier is an error synchronization event that might  also update DISR_EL1 and VDISR_EL2. \n\nThis instruction can be used at all Exception levels and in Debug state. \n\nIn Debug state, this instruction behaves as if SError interrupts are masked at  all Exception levels. See Error Synchronization Barrier in the Arm(R)  Reliability, Availability, and Serviceability (RAS) Specification, Armv8, for  Armv8-A architecture profile. \n\nIf the RAS Extension is not implemented, this instruction executes as a NOP.", "explanations": {}, "encodings": ["ESB"]}, {"id": 1105, "asmtemplate": "AUTIAZ", "brief": "Authenticate Instruction address, using key A", "heading": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA", "para": "Authenticate Instruction address, using key A. This instruction authenticates  an instruction address, using a modifier and key A. \n\nThe address is:  \n* In the general-purpose register that is specified by <Xd> for AUTIA and \n  AUTIZA. \n* In X17, for AUTIA1716. \n* In X30, for AUTIASP and AUTIAZ.  The modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTIA. \n* The value zero, for AUTIZA and AUTIAZ. \n* In X16, for AUTIA1716. \n* In SP, for AUTIASP.  If the authentication passes, the upper bits of the address are restored to  enable subsequent use of the address. If the authentication fails, the upper  bits are corrupted and any subsequent use of the address results in a  Translation fault. \n\nIt has encodings from 2 classes: Integer and System", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["AUTIA  <Xd>, <Xn|SP>", "AUTIA1716"]}, {"id": 606, "asmtemplate": "BFDOT   <Zda>.S, <Zn>.H, <Zm>.H", "brief": "BFloat16 floating-point dot product", "heading": "BFDOT (vectors)", "para": "BFloat16 floating-point dot product. \n\nThe BFloat16 floating-point (BF16) dot product instruction computes the dot  product of a pair of BF16 values held in each 32-bit element of the first  source vector multiplied by a pair of BF16 values in the corresponding 32-bit  element of the second source vector, and then destructively adds the  single-precision dot product to the corresponding single-precision element of  the destination vector. \n\nThis instruction is unpredicated. \n\nAll floating-point calculations performed by this instruction are performed  with the following behaviors, irrespective of the value in FPCR:  \n* Uses the non-IEEE 754 Round-to-Odd mode, which forces bit 0 of an inexact  result to 1, and rounds an overflow to an appropriately signed Infinity.  \n* The cumulative FPSR exception bits (IDC, IXC, UFC, OFC, DZC and IOC) are not  modified.  \n* Trapped floating-point exceptions are disabled, as if the FPCR trap enable  bits (IDE, IXE, UFE, OFE, DZE and IOE) are all zero.  \n* Denormalized inputs and results are flushed to zero, as if FPCR.FZ == 1.  \n* Only the Default NaN is generated, as if FPCR.DN == 1. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["BFDOT   <Zda>.S, <Zn>.H, <Zm>.H"]}, {"id": 124, "asmtemplate": "LD1RSB  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast signed byte to vector", "heading": "LD1RSB", "para": "Load and broadcast signed byte to vector. \n\nLoad a single signed byte from a memory address generated by a 64-bit scalar  base address plus an immediate offset which is in the range 0 to 63. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 63, defaulting to 0, encoded in the \"imm6\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1RSB  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RSB  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RSB  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 1265, "asmtemplate": "LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>", "brief": "Logical shift left by immediate (predicated)", "heading": "LSL (immediate, predicated)", "para": "Logical shift left by immediate (predicated). \n\nShift left by immediate each active element of the source vector, and  destructively place the results in the corresponding elements of the source  vector. The immediate shift amount is an unsigned value in the range 0 to  number of bits per element minus 1. Inactive elements in the destination  vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<const>": "Is the immediate shift amount, in the range 0 to number of bits per element minus 1, encoded in \"tsz:imm3\"."}, "encodings": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, #<const>"]}, {"id": 1243, "asmtemplate": "UCVTF  <Vd>.<T>, <Vn>.<T>", "brief": "Unsigned integer Convert to Floating-point (vector)", "heading": "UCVTF (vector, integer)", "para": "Unsigned integer Convert to Floating-point (vector). This instruction converts  each element in a vector from an unsigned integer value to a floating-point  value using the rounding mode that is specified by the FPCR, and writes the  result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["UCVTF  <Hd>, <Hn>", "UCVTF  <V><d>, <V><n>", "UCVTF  <Vd>.<T>, <Vn>.<T>", "UCVTF  <Vd>.<T>, <Vn>.<T>"]}, {"id": 686, "asmtemplate": "CSINC<Xd>, XZR, XZR, invert(<cond>)", "brief": "Conditional Set", "heading": "CSET", "para": "Conditional Set sets the destination register to 1 if the condition is TRUE,  and otherwise sets it to 0. \n\nThis is an alias of CSINC. This means:  \n* The encodings in this description are named to match the encodings of CSINC. \n* The description of CSINC gives the operational pseudocode for this \n  instruction.", "explanations": {"<cond>": "Is one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CSET  <Wd>, <cond>"]}, {"id": 639, "asmtemplate": "EORS<Pd>.B, <Pg>/Z, <Pn>.B, <Pg>.B", "brief": "Bitwise invert predicate, setting the condition flags", "heading": "NOTS", "para": "Bitwise invert predicate, setting the condition flags. \n\nBitwise invert each active element of the source predicate, and place the  results in the corresponding elements of the destination predicate. Inactive  elements in the destination predicate register are set to zero. Sets the First \n(N), None (Z), !Last (C) condition flags based on the predicate result, and  the V flag to zero. \n\nThis is an alias of EOR, EORS (predicates). This means:  \n* The encodings in this description are named to match the encodings of EOR, \n  EORS (predicates). \n* The description of EOR, EORS (predicates) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["NOTS    <Pd>.B, <Pg>/Z, <Pn>.B"]}, {"id": 272, "asmtemplate": "SMINV   <V><d>, <Pg>, <Zn>.<T>", "brief": "Signed minimum reduction to scalar", "heading": "SMINV", "para": "Signed Minimum across Vector. This instruction compares all the vector  elements in the source SIMD&FP register, and writes the smallest of the values  as a scalar to the destination SIMD&FP register. All the values in this  instruction are signed integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD"}, "encodings": ["SMINV  <V><d>, <Vn>.<T>"]}, {"id": 409, "asmtemplate": "SQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment scalar by multiple of 16-bit predicate constraint element count", "heading": "SQINCH (scalar)", "para": "Signed saturating increment scalar by multiple of 16-bit predicate constraint  element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCH  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 76, "asmtemplate": "ASR     <Zd>.<T>, <Zn>.<T>, <Zm>.D", "brief": "Arithmetic shift right by 64-bit wide elements (unpredicated)", "heading": "ASR (wide elements, unpredicated)", "para": "Arithmetic shift right by 64-bit wide elements (unpredicated). \n\nShift right, preserving the sign bit, all elements of the first source vector  by corresponding overlapping 64-bit elements of the second source vector and  place the first in the corresponding elements of the destination vector. The  shift amount is a vector of unsigned 64-bit doubleword elements in which all  bits are significant, and not used modulo the destination element size. This  instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["ASR     <Zd>.<T>, <Zn>.<T>, <Zm>.D"]}, {"id": 612, "asmtemplate": "ST1B    {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]", "brief": "Scatter store bytes from a vector (vector index)", "heading": "ST1B (scalar plus vector)", "para": "Scatter store bytes from a vector (vector index). \n\nScatter store of bytes from the active elements of a vector register to the  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally sign or zero-extended from 32 to 64 bits. Inactive  elements are not written to memory. \n\nIt has encodings from 3 classes: 32-bit unpacked unscaled offset , 32-bit  unscaled offset and 64-bit unscaled offset", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST1B    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]", "ST1B    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]", "ST1B    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]"]}, {"id": 1142, "asmtemplate": "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Shift Right and Insert (immediate)", "heading": "SRI", "para": "Shift Right and Insert (immediate). This instruction reads each vector element  in the source SIMD&FP register, right shifts each vector element by an  immediate value, and inserts the result into the corresponding vector element  in the destination SIMD&FP register such that the new zero bits created by the  shift are not inserted but retain their existing value. Bits shifted out of  the right of each vector element of the source register are lost. \n\nThe following figure shows an example of the operation of shift right by 3 for  an 8-bit vector element. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SRI  <V><d>, <V><n>, #<shift>", "SRI  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 36, "asmtemplate": "MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Multiply-Add to accumulator (vector)", "heading": "MLA (vector)", "para": "Multiply-Add to accumulator (vector). This instruction multiplies  corresponding elements in the vectors of the two source SIMD&FP registers, and  accumulates the results with the vector elements of the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["MLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 807, "asmtemplate": "FMAD    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>", "brief": "Floating-point fused multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]", "heading": "FMAD", "para": "Floating-point fused multiply-add vectors (predicated), writing multiplicand \n[Zdn = Za + Zdn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and add to elements of the third (addend) vector without  intermediate rounding. Destructively place the results in the destination and  first source (multiplicand) vector. Inactive elements in the destination  vector register remain unmodified.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Za>": "Is the name of the third source scalable vector register, encoded in the \"Za\" field."}, "encodings": ["FMAD    <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>"]}, {"id": 666, "asmtemplate": "SCVTF  <Dd>, <Xn>, #<fbits>", "brief": "Signed fixed-point Convert to Floating-point (scalar)", "heading": "SCVTF (scalar, fixed-point)", "para": "Signed fixed-point Convert to Floating-point (scalar). This instruction  converts the signed value in the 32-bit or 64-bit general-purpose source  register to a floating-point value using the rounding mode that is specified  by the FPCR, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped.", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<fbits>": "For the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus \"scale\".", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["SCVTF  <Hd>, <Wn>, #<fbits>"]}, {"id": 527, "asmtemplate": "PRFD    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous prefetch doublewords (scalar index)", "heading": "PRFD (scalar plus scalar)", "para": "Contiguous prefetch doublewords (scalar index). \n\nContiguous prefetch of doubleword elements from the memory address generated  by a 64-bit scalar base and scalar index which is multiplied by 8 and added to  the base address. After each element prefetch the index value is incremented,  but the index register is not updated. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFD    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 151, "asmtemplate": "ST3H    {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous store three-halfword structures from three vectors (scalar index)", "heading": "ST3H (scalar plus scalar)", "para": "Contiguous store three-halfword structures from three vectors (scalar index). \n\nContiguous store three-halfword structures, each from the same element number  in three vector registers to the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by three. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive halfwords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 732, "asmtemplate": "AND  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise AND (shifted register)", "heading": "AND (shifted register)", "para": "Bitwise AND (shifted register) performs a bitwise AND of a register value and  an optionally-shifted register value, and writes the result to the destination  register.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["AND  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 870, "asmtemplate": "UADDLV  <V><d>, <Vn>.<T>", "brief": "Unsigned sum Long across Vector", "heading": "UADDLV", "para": "Unsigned sum Long across Vector. This instruction adds every vector element in  the source SIMD&FP register together, and writes the scalar result to the  destination SIMD&FP register. The destination scalar is twice as long as the  source vector elements. All the values in this instruction are unsigned  integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["UADDLV  <V><d>, <Vn>.<T>"]}, {"id": 37, "asmtemplate": "SSUBL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Subtract Long", "heading": "SSUBL, SSUBL2", "para": "Signed Subtract Long. This instruction subtracts each vector element in the  lower or upper half of the second source SIMD&FP register from the  corresponding vector element of the first source SIMD&FP register, places the  results into a vector, and writes the vector to the destination SIMD&FP  register. All the values in this instruction are signed integer values. The  destination vector elements are twice as long as the source vector elements. \n\nThe SSUBL instruction extracts each source vector from the lower half of each  source register, while the SSUBL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SSUBL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 809, "asmtemplate": "USQADD  <Vd>.<T>, <Vn>.<T>", "brief": "Unsigned saturating Accumulate of Signed value", "heading": "USQADD", "para": "Unsigned saturating Accumulate of Signed value. This instruction adds the  signed integer values of the vector elements in the source SIMD&FP register to  corresponding unsigned integer values of the vector elements in the  destination SIMD&FP register, and accumulates the resulting unsigned integer  values with the vector elements of the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["USQADD  <V><d>, <V><n>", "USQADD  <Vd>.<T>, <Vn>.<T>"]}, {"id": 476, "asmtemplate": "STR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Store SIMD&FP register (register offset)", "heading": "STR (register, SIMD&FP)", "para": "Store SIMD&FP register (register offset). This instruction stores a single  SIMD&FP register to memory. The address that is used for the store is  calculated from a base register value and an offset register value. The offset  can be optionally shifted and extended. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register to be transferred, encoded in the \"Rt\" field.", "<St>": "Is the 32-bit name of the SIMD", "<Xm>": "When ", "<Qt>": "Is the 128-bit name of the SIMD", "<Ht>": "Is the 16-bit name of the SIMD", "<Dt>": "Is the 64-bit name of the SIMD", "<Wm>": "When ", "<extend><extend><amount>": "For the 8-bit variant: is the index shift amount, it must be ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Bt>": "Is the 8-bit name of the SIMD"}, "encodings": ["STR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"]}, {"id": 395, "asmtemplate": "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Minimum Number Pairwise (vector)", "heading": "FMINNMP (vector)", "para": "Floating-point Minimum Number Pairwise (vector). This instruction creates a  vector by concatenating the vector elements of the first source SIMD&FP  register after the vector elements of the second source SIMD&FP register,  reads each pair of adjacent vector elements in the two source SIMD&FP  registers, writes the smallest of each pair of floating-point values into a  vector, and writes the vector to the destination SIMD&FP register. All the  values in this instruction are floating-point values. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result is the numerical  value, otherwise the result is identical to FMIN (scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMINNMP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 192, "asmtemplate": "ISB  {<option>|#<imm>}", "brief": "Instruction Synchronization Barrier", "heading": "ISB", "para": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a  context synchronization event. For more information, see Instruction  Synchronization Barrier (ISB).", "explanations": {"<imm>": "Is an optional 4-bit unsigned immediate, in the range 0 to 15, defaulting to 15 and encoded in the \"CRm\" field.", "": "All other encodings of ", "<option>": "Specifies an optional limitation on the barrier operation. Values are:"}, "encodings": ["ISB  {<option>|#<imm>}"]}, {"id": 550, "asmtemplate": "TBZ  <R><t>, #<imm>, <label>", "brief": "Test bit and Branch if Zero", "heading": "TBZ", "para": "Test bit and Branch if Zero compares the value of a test bit with zero, and  conditionally branches to a label at a PC-relative offset if the comparison is  equal. It provides a hint that this is not a subroutine call or return. This  instruction does not affect condition flags.", "explanations": {"<imm>": "Is the bit number to be tested, in the range 0 to 63, encoded in \"b5:b40\".", "<R><t>": "Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the \"Rt\" field.", "<label>": "Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as \"imm14\" times 4."}, "encodings": ["TBZ  <R><t>, #<imm>, <label>"]}, {"id": 332, "asmtemplate": "FCVTZS  <Xd>, <Dn>", "brief": "Floating-point Convert to Signed integer, rounding toward Zero (scalar)", "heading": "FCVTZS (scalar, integer)", "para": "Floating-point Convert to Signed integer, rounding toward Zero (scalar). This  instruction converts the floating-point value in the SIMD&FP source register  to a 32-bit or 64-bit signed integer using the Round towards Zero rounding  mode, and writes the result to the general-purpose destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FCVTZS  <Wd>, <Hn>"]}, {"id": 1215, "asmtemplate": "FABS    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Floating-point absolute value (predicated)", "heading": "FABS", "para": "Floating-point absolute value (predicated). \n\nTake the absolute value of each active floating-point element of the source  vector, and place the results in the corresponding elements of the destination  vector. This clears the sign bit and cannot signal a floating-point exception.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FABS    <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 1162, "asmtemplate": "ST4H    {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous store four-halfword structures from four vectors (scalar index)", "heading": "ST4H (scalar plus scalar)", "para": "Contiguous store four-halfword structures from four vectors (scalar index). \n\nContiguous store four-halfword structures, each from the same element number  in four vector registers to the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by four. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive halfwords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 142, "asmtemplate": "UMLAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Multiply-Add Long (vector)", "heading": "UMLAL, UMLAL2 (vector)", "para": "Unsigned Multiply-Add Long (vector). This instruction multiplies the vector  elements in the lower or upper half of the first source SIMD&FP register by  the corresponding vector elements of the second source SIMD&FP register, and  accumulates the results with the vector elements of the destination SIMD&FP  register. The destination vector elements are twice as long as the elements  that are multiplied. \n\nThe UMLAL instruction extracts vector elements from the lower half of the  first source register, while the UMLAL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 466, "asmtemplate": "ADDPL   <Xd|SP>, <Xn|SP>, #<imm>", "brief": "Add multiple of predicate register size to scalar register", "heading": "ADDPL", "para": "Add multiple of predicate register size to scalar register. \n\nAdd the current predicate register size in bytes multiplied by an immediate in  the range -32 to 31 to the 64-bit source general-purpose register or current  stack pointer and place the result in the 64-bit destination general-purpose  register or current stack pointer.", "explanations": {"<imm>": "Is the signed immediate operand, in the range -32 to 31, encoded in the \"imm6\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["ADDPL   <Xd|SP>, <Xn|SP>, #<imm>"]}, {"id": 1198, "asmtemplate": "LDRAB  <Xt>, [<Xn|SP>{, #<simm>}]!", "brief": "Load Register, with pointer authentication", "heading": "LDRAA, LDRAB", "para": "Load Register, with pointer authentication. This instruction authenticates an  address from a base register using a modifier of zero and the specified key,  adds an immediate offset to the authenticated address, and loads a 64-bit  doubleword from memory at this resulting address into a register. \n\nKey A is used for LDRAA, and key B is used for LDRAB. \n\nIf the authentication passes, the PE behaves the same as for an LDR  instruction. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to the base register, unless the  pre-indexed variant of the instruction is used. In this case, the address that  is written back to the base register does not include the pointer  authentication code. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"": "/8.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, a multiple of 8 in the range -4096 to 4088, defaulting to 0 and encoded in the \"S:imm9\" field as ", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDRAA  <Xt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 381, "asmtemplate": "LD1D    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load doublewords to vector (vector index)", "heading": "LD1D (scalar plus vector)", "para": "Gather load doublewords to vector (vector index). \n\nGather load of doublewords to active elements of a vector register from memory  addresses generated by a 64-bit scalar base plus vector index. The index  values are optionally first sign or zero-extended from 32 to 64 bits and then  optionally multiplied by 8. Inactive elements will not cause a read from  Device memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 4 classes: 32-bit unpacked scaled offset , 32-bit  unpacked unscaled offset , 64-bit scaled offset and 64-bit unscaled offset", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]", "LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 1078, "asmtemplate": "SMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>", "brief": "Signed maximum with immediate (unpredicated)", "heading": "SMAX (immediate)", "para": "Signed maximum with immediate (unpredicated). \n\nDetermine the signed maximum of an immediate and each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate is a signed 8-bit value in the range -128 to \n+127, inclusive. This instruction is unpredicated.", "explanations": {"<T><imm>": "Is the signed immediate operand, in the range -128 to 127, encoded in the \"imm8\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["SMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>"]}, {"id": 1141, "asmtemplate": "ST2  {<Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Store single 2-element structure from one lane of two registers", "heading": "ST2 (single structure)", "para": "Store single 2-element structure from one lane of two registers. This  instruction stores a 2-element structure to memory from corresponding elements  of two SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "": "\".", "<Vt2>": "Is the name of the second SIMD"}, "encodings": ["ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]", "ST2  { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2"]}, {"id": 41, "asmtemplate": "BFMLALB <Zda>.S, <Zn>.H, <Zm>.H[<imm>]", "brief": "BFloat16 floating-point multiply-add long to single-precision (bottom, indexed)", "heading": "BFMLALB (indexed)", "para": "BFloat16 floating-point multiply-add long to single-precision (bottom,  indexed). \n\nThis BFloat16 floating-point multiply-add long instruction widens the  even-numbered 16-bit BFloat16 elements in the first source vector and the  indexed element from the corresponding 128-bit segment in the second source  vector to single-precision format and then destructively multiplies and adds  these values without intermediate rounding to the overlapping 32-bit  single-precision elements of the addend and destination vector. This  instruction is unpredicated. \n\nUnlike the BFloat16 matrix multiplication and dot product instructions, this  instruction performs a fused multiply-add that honors all of the FPCR bits  that apply to single-precision arithmetic. It can also generate a  floating-point exception that causes cumulative exception bits in the FPSR to  be set, or a synchronous exception to be taken, depending on the enable bits  in the FPCR. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["BFMLALB <Zda>.S, <Zn>.H, <Zm>.H[<imm>]"]}, {"id": 578, "asmtemplate": "LD3R  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load single 3-element structure and Replicate to all lanes of three registers", "heading": "LD3R", "para": "Load single 3-element structure and Replicate to all lanes of three registers.  This instruction loads a 3-element structure from memory and replicates the  structure to all the lanes of the three SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<T><Vt2>": "Is the name of the second SIMD", "<Vt3>": "Is the name of the third SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", "LD3R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 98, "asmtemplate": "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0", "brief": "Floating-point compare vector with zero", "heading": "FCM<cc> (zero)", "para": "Floating-point compare vector with zero. \n\nCompare active floating-point elements in the source vector with zero, and  place the boolean results of the specified comparison in the corresponding  elements of the destination predicate. Inactive elements in the destination  predicate register are set to zero. Does not set the condition flags. \n\n \n\nThe <cc> symbol specifies one of the standard ARM condition codes: EQ, GE, GT,  LE, LT, or NE. \n\nIt has encodings from 6 classes: Equal , Greater than , Greater than or equal \n, Less than , Less than or equal and Not equal", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["FCMEQ   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0", "FCMGT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0", "FCMGE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0", "FCMLT   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0", "FCMLE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0", "FCMNE   <Pd>.<T>, <Pg>/Z, <Zn>.<T>, #0.0"]}, {"id": 1185, "asmtemplate": "FCVTZU  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector)", "heading": "FCVTZU (vector, integer)", "para": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector).  This instruction converts a scalar or each element in a vector from a  floating-point value to an unsigned integer value using the Round towards Zero  rounding mode, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTZU  <Hd>, <Hn>", "FCVTZU  <V><d>, <V><n>", "FCVTZU  <Vd>.<T>, <Vn>.<T>", "FCVTZU  <Vd>.<T>, <Vn>.<T>"]}, {"id": 877, "asmtemplate": "FCMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>", "brief": "Floating-point complex multiply-add with rotate (predicated)", "heading": "FCMLA (vectors)", "para": "Floating-point complex multiply-add with rotate (predicated). \n\nMultiply the duplicated real components for rotations 0 and 180, or imaginary  components for rotations 90 and 270, of the floating-point complex numbers in  the first source vector by the corresponding complex number in the second  source vector rotated by 0, 90, 180 or 270 degrees in the direction from the  positive real axis towards the positive imaginary axis, when considered in  polar representation. \n\nThen destructively add the products to the corresponding components of the  complex numbers in the addend and destination vector, without intermediate  rounding. \n\nThese transformations permit the creation of a variety of multiply-add and  multiply-subtract operations on complex numbers by combining two of these  instructions with the same vector operands but with rotations that are 90  degrees apart. \n\nEach complex number is represented in a vector register as an even/odd pair of  elements with the real part in the even-numbered element and the imaginary  part in the odd-numbered element. Inactive elements in the destination vector  register remain unmodified.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FCMLA   <Zda>.<T>, <Pg>/M, <Zn>.<T>, <Zm>.<T>, <const>"]}, {"id": 212, "asmtemplate": "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element)", "heading": "SQRDMLAH (by element)", "para": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half \n(by element). This instruction multiplies the vector elements of the first  source SIMD&FP register with the value of a vector element of the second  source SIMD&FP register without saturating the multiply results, doubles the  results, and accumulates the most significant half of the final results with  the vector elements of the destination SIMD&FP register. The results are  rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation  bit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SQRDMLAH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "SQRDMLAH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 719, "asmtemplate": "SQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement vector by multiple of 64-bit predicate constraint element count", "heading": "SQDECD (vector)", "para": "Signed saturating decrement vector by multiple of 64-bit predicate constraint  element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. The  results are saturated to the 64-bit signed integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}"]}, {"id": 674, "asmtemplate": "MOVZ  <Xd>, #<imm>{, LSL #<shift>}", "brief": "Move wide with zero", "heading": "MOVZ", "para": "Move wide with zero moves an optionally-shifted 16-bit immediate value to a  register. \n\nThis instruction is used by the alias MOV (wide immediate).", "explanations": {"<imm>": "Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "": "/16.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MOVZ  <Wd>, #<imm>{, LSL #<shift>}"]}, {"id": 290, "asmtemplate": "AND<Pd>.B, <Pg>/Z, <Pn>.B, <Pn>.B", "brief": "Move predicates (zeroing)", "heading": "MOV (predicate, predicated, zeroing)", "para": "Move predicates (zeroing). \n\nRead active elements from the source predicate and place in the corresponding  elements of the destination predicate. Inactive elements in the destination  predicate register are set to zero. Does not set the condition flags. \n\nThis is an alias of AND, ANDS (predicates). This means:  \n* The encodings in this description are named to match the encodings of AND, \n  ANDS (predicates). \n* The description of AND, ANDS (predicates) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["MOV     <Pd>.B, <Pg>/Z, <Pn>.B"]}, {"id": 946, "asmtemplate": "FMINV  <V><d>, <Vn>.<T>", "brief": "Floating-point Minimum across Vector", "heading": "FMINV", "para": "Floating-point Minimum across Vector. This instruction compares all the vector  elements in the source SIMD&FP register, and writes the smallest of the values  as a scalar to the destination SIMD&FP register. All the values in this  instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<V>": "For the half-precision variant: is the destination width specifier, H.", "<Vn>": "Is the name of the SIMD"}, "encodings": ["FMINV  <V><d>, <Vn>.<T>", "FMINV  <V><d>, <Vn>.<T>"]}, {"id": 240, "asmtemplate": "CPY     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}", "brief": "Copy signed integer immediate to vector elements (merging)", "heading": "CPY (immediate, merging)", "para": "Copy signed integer immediate to vector elements (merging). \n\nCopy a signed integer immediate to each active element in the destination  vector. Inactive elements in the destination vector register remain  unmodified. \n\nThe immediate operand is a signed value in the range -128 to +127, and for  element widths of 16 bits or higher it may also be a signed multiple of 256 in  the range -32768 to +32512 (excluding 0). \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<simm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\". \n\nThis instruction is used by the aliases FMOV (zero, predicated), and MOV \n(immediate, predicated, merging).", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>": "Is a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["CPY     <Zd>.<T>, <Pg>/M, #<imm>{, <shift>}"]}, {"id": 725, "asmtemplate": "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Unsigned saturating Shift Left (immediate)", "heading": "UQSHL (immediate)", "para": "Unsigned saturating Shift Left (immediate). This instruction takes each vector  element in the source SIMD&FP register, shifts it by an immediate value,  places the results in a vector, and writes the vector to the destination  SIMD&FP register. The results are truncated. For rounded results, see UQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["UQSHL  <V><d>, <V><n>, #<shift>", "UQSHL  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 681, "asmtemplate": "UABAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Unsigned Absolute difference and Accumulate Long", "heading": "UABAL, UABAL2", "para": "Unsigned Absolute difference and Accumulate Long. This instruction subtracts  the vector elements in the lower or upper half of the second source SIMD&FP  register from the corresponding vector elements of the first source SIMD&FP  register, and accumulates the absolute values of the results into the vector  elements of the destination SIMD&FP register. The destination vector elements  are twice as long as the source vector elements. All the values in this  instruction are unsigned integer values. \n\nThe UABAL instruction extracts each source vector from the lower half of each  source register, while the UABAL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "2<Vd>": "Is the name of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UABAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 168, "asmtemplate": "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Signed saturating Doubling Multiply returning High half (by element)", "heading": "SQDMULH (by element)", "para": "Signed saturating Doubling Multiply returning High half (by element). This  instruction multiplies each vector element in the first source SIMD&FP  register by the specified vector element of the second source SIMD&FP  register, doubles the results, places the most significant half of the final  results into a vector, and writes the vector to the destination SIMD&FP  register. \n\nThe results are truncated. For rounded results, see SQRDMULH. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SQDMULH  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "SQDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 1160, "asmtemplate": "LDNT1W  {<Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-temporal words to vector (immediate index)", "heading": "LDNT1W (scalar plus immediate)", "para": "Contiguous load non-temporal words to vector (immediate index). \n\nContiguous load non-temporal of words to elements of a vector register from  the memory address generated by a 64-bit scalar base and immediate index in  the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  will not not cause a read from Device memory or signal a fault, and are set to  zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LDNT1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1254, "asmtemplate": "ST1  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T>}, [<Xn|SP>], <Xm>", "brief": "Store multiple single-element structures from one, two, three, or four registers", "heading": "ST1 (multiple structures)", "para": "Store multiple single-element structures from one, two, three, or four  registers. This instruction stores elements to memory from one, two, three, or  four SIMD&FP registers, without interleaving. Every element of each register  is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<imm><imm><imm><imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<T><Vt2>": "Is the name of the second SIMD"}, "encodings": ["ST1  { <Vt>.<T> }, [<Xn|SP>]", "ST1  { <Vt>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 335, "asmtemplate": "CMGE  <Vd>.<T>, <Vn>.<T>, #0", "brief": "Compare signed Greater than or Equal to zero (vector)", "heading": "CMGE (zero)", "para": "Compare signed Greater than or Equal to zero (vector). This instruction reads  each vector element in the source SIMD&FP register and if the signed integer  value is greater than or equal to zero sets every bit of the corresponding  vector element in the destination SIMD&FP register to one, otherwise sets  every bit of the corresponding vector element in the destination SIMD&FP  register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["CMGE  <V><d>, <V><n>, #0", "CMGE  <Vd>.<T>, <Vn>.<T>, #0"]}, {"id": 281, "asmtemplate": "FCSEL  <Dd>, <Dn>, <Dm>, <cond>", "brief": "Floating-point Conditional Select (scalar)", "heading": "FCSEL", "para": "Floating-point Conditional Select (scalar). This instruction allows the  SIMD&FP destination register to take the value from either one or the other of  two SIMD&FP source registers. If the condition passes, the first SIMD&FP  source register value is taken, otherwise the second SIMD&FP source register  value is taken. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Hm>": "Is the 16-bit name of the second SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FCSEL  <Hd>, <Hn>, <Hm>, <cond>"]}, {"id": 202, "asmtemplate": "BFMLALT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]", "brief": "BFloat16 floating-point multiply-add long to single-precision (top, indexed)", "heading": "BFMLALT (indexed)", "para": "BFloat16 floating-point multiply-add long to single-precision (top, indexed). \n\nThis BFloat16 floating-point multiply-add long instruction widens the  odd-numbered 16-bit BFloat16 elements in the first source vector and the  indexed element from the corresponding 128-bit segment in the second source  vector to single-precision format and then destructively multiplies and adds  these values without intermediate rounding to the overlapping 32-bit  single-precision elements of the addend and destination vector. This  instruction is unpredicated. \n\nUnlike the BFloat16 matrix multiplication and dot product instructions, this  instruction performs a fused multiply-add that honors all of the FPCR bits  that apply to single-precision arithmetic. It can also generate a  floating-point exception that causes cumulative exception bits in the FPSR to  be set, or a synchronous exception to be taken, depending on the enable bits  in the FPCR. \n\nID_AA64ZFR0_EL1.BF16 indicates whether this instruction is implemented.", "explanations": {"<imm>": "Is the immediate index, in the range 0 to 7, encoded in the \"i3h:i3l\" fields.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register Z0-Z7, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["BFMLALT <Zda>.S, <Zn>.H, <Zm>.H[<imm>]"]}, {"id": 1086, "asmtemplate": "SYS #3, C7, C3, #7, <Xt>", "brief": "Cache Prefetch Prediction Restriction by Context", "heading": "CPP", "para": "Cache Prefetch Prediction Restriction by Context prevents cache allocation  predictions, based on information gathered from earlier execution within a  particular execution context, from allowing later speculative execution within  that context to be observable through side-channels. \n\nFor more information, see CPP RCTX, Cache Prefetch Prediction Restriction by  Context. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."}, "encodings": ["CPP  RCTX, <Xt>"]}, {"id": 347, "asmtemplate": "BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]", "brief": "BFloat16 floating-point dot product (vector, by element)", "heading": "BFDOT (by element)", "para": "BFloat16 floating-point dot product (vector, by element). This instruction  delimits the source vectors into pairs of 16-bit BF16 elements. Each pair of  elements in the first source vector is multiplied by the specified pair of  elements in the second source vector. The resulting single-precision products  are then summed and added destructively to the single-precision element of the  destination vector that aligns with the pair of BF16 values in the first  source vector. The instruction ignores the FPCR and does not update the FPSR  exception status. \n\nThe BF16 pair within the second source vector is specified using an immediate  index. The index range is from 0 to 3 inclusive. ID_AA64ISAR1_EL1.BF16  indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<index>": "Is the immediate index of a pair of 16-bit elements in the range 0 to 3, encoded in the \"H:L\" fields.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["BFDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.2H[<index>]"]}, {"id": 99, "asmtemplate": "LDFF1B  {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault unsigned bytes to vector (immediate index)", "heading": "LDFF1B (vector plus immediate)", "para": "Gather load first-fault unsigned bytes to vector (immediate index). \n\nGather load with first-faulting behavior of unsigned bytes to active elements  of a vector register from memory addresses generated by a vector base plus  immediate index. The index is in the range 0 to 31. Inactive elements will not  cause a read from Device memory or signal faults, and are set to zero in the  destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDFF1B  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LDFF1B  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 627, "asmtemplate": "SMLSL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Multiply-Subtract Long (vector)", "heading": "SMLSL, SMLSL2 (vector)", "para": "Signed Multiply-Subtract Long (vector). This instruction multiplies  corresponding signed integer values in the lower or upper half of the vectors  of the two source SIMD&FP registers, and subtracts the results from the vector  elements of the destination SIMD&FP register. The destination vector elements  are twice as long as the elements that are multiplied. \n\nThe SMLSL instruction extracts each source vector from the lower half of each  source register, while the SMLSL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "2<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 1125, "asmtemplate": "FMOV  <Vd>.2D, #<imm>", "brief": "Floating-point move immediate (vector)", "heading": "FMOV (vector, immediate)", "para": "Floating-point move immediate (vector). This instruction copies an immediate  floating-point constant into every element of the SIMD&FP destination  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD", "<T><T><imm>": "Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in \"a:b:c:d:e:f:g:h\". For details of the range of constants available and the encoding of "}, "encodings": ["FMOV  <Vd>.<T>, #<imm>", "FMOV  <Vd>.<T>, #<imm>"]}, {"id": 787, "asmtemplate": "FRINTP  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Floating-point round to integral value (predicated)", "heading": "FRINT<r>", "para": "Floating-point round to integral value (predicated). \n\nRound to an integral floating-point value with the specified rounding option  from each active floating-point element of the source vector, and place the  results in the corresponding elements of the destination vector. Inactive  elements in the destination vector register remain unmodified. \n\n \n\nThe <r> symbol specifies one of the following rounding options: N (to nearest,  with ties to even), A (to nearest, with ties away from zero), M (toward minus  Infinity), P (toward plus Infinity), Z (toward zero), I (current FPCR rounding  mode), or X (current FPCR rounding mode, signalling inexact). \n\nIt has encodings from 7 classes: Current mode , Current mode signalling  inexact , Nearest with ties to away , Nearest with ties to even , Toward zero \n, Toward minus infinity and Toward plus infinity", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FRINTI  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "FRINTX  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "FRINTA  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "FRINTN  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "FRINTZ  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "FRINTM  <Zd>.<T>, <Pg>/M, <Zn>.<T>", "FRINTP  <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 531, "asmtemplate": "ST64BV0  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Single-copy Atomic 64-byte EL0 Store with Return", "heading": "ST64BV0", "para": "Single-copy Atomic 64-byte EL0 Store with Return stores eight 64-bit  doublewords from consecutive registers, Xt to X(t+7), to a memory location,  with the bottom 32 bits taken from ACCDATA_EL1, and writes the status result  of the store to a register. The data that is stored is atomic and is required  to be 64-byte aligned.", "explanations": {"": "If XZR is used, then the return value is ignored.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register into which the status result of this instruction is written, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["ST64BV0  <Xs>, <Xt>, [<Xn|SP>]"]}, {"id": 1114, "asmtemplate": "FMUL    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point multiply vectors (unpredicated)", "heading": "FMUL (vectors, unpredicated)", "para": "Floating-point multiply vectors (unpredicated). \n\nMultiply all elements of the first source vector by corresponding  floating-point elements of the second source vector and place the results in  the corresponding elements of the destination vector. This instruction is  unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMUL    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 632, "asmtemplate": "LD1D    {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load doublewords to vector (immediate index)", "heading": "LD1D (vector plus immediate)", "para": "Gather load doublewords to vector (immediate index). \n\nGather load of doublewords to active elements of a vector register from memory  addresses generated by a vector base plus immediate index. The index is a  multiple of 8 in the range 0 to 248. Inactive elements will not cause a read  from Device memory or signal faults, and are set to zero in the destination  vector.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 771, "asmtemplate": "LDNF1D  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault doublewords to vector (immediate index)", "heading": "LDNF1D", "para": "Contiguous load non-fault doublewords to vector (immediate index). \n\nContiguous load with non-faulting behavior of doublewords to elements of a  vector register from the memory address generated by a 64-bit scalar base and  immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDNF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 264, "asmtemplate": "RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D", "brief": "Rotate and Exclusive OR", "heading": "RAX1", "para": "Rotate and Exclusive OR rotates each 64-bit element of the 128-bit vector in a  source SIMD&FP register left by 1, performs a bitwise exclusive OR of the  resulting 128-bit vector and the vector in another source SIMD&FP register,  and writes the result to the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA3 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["RAX1  <Vd>.2D, <Vn>.2D, <Vm>.2D"]}, {"id": 920, "asmtemplate": "ST64BV  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Single-copy Atomic 64-byte Store with Return", "heading": "ST64BV", "para": "Single-copy Atomic 64-byte Store with Return stores eight 64-bit doublewords  from consecutive registers, Xt to X(t+7), to a memory location, and writes the  status result of the store to a register. The data that is stored is atomic  and is required to be 64-byte aligned.", "explanations": {"": "If XZR is used, then the return value is ignored.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register into which the status result of this instruction is written, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["ST64BV  <Xs>, <Xt>, [<Xn|SP>]"]}, {"id": 143, "asmtemplate": "AESD  <Vd>.16B, <Vn>.16B", "brief": "AES single round decryption", "heading": "AESD", "para": "AES single round decryption.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the second SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["AESD  <Vd>.16B, <Vn>.16B"]}, {"id": 830, "asmtemplate": "LD1B    {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load unsigned bytes to vector (immediate index)", "heading": "LD1B (scalar plus immediate)", "para": "Contiguous load unsigned bytes to vector (immediate index). \n\nContiguous load of unsigned bytes to elements of a vector register from the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements will not not  cause a read from Device memory or signal a fault, and are set to zero in the  destination vector. \n\nIt has encodings from 4 classes: 8-bit element , 16-bit element , 32-bit  element and 64-bit element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1B    { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1B    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 201, "asmtemplate": "SMOV  <Xd>, <Vn>.<Ts>[<index>]", "brief": "Signed Move vector element to general-purpose register", "heading": "SMOV", "para": "Signed Move vector element to general-purpose register. This instruction reads  the signed integer from the source SIMD&FP register, sign-extends it to form a  32-bit or 64-bit value, and writes the result to destination general-purpose  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SMOV  <Wd>, <Vn>.<Ts>[<index>]"]}, {"id": 619, "asmtemplate": "UBFM  <Xd>, <Xn>, #<immr>, #<imms>", "brief": "Unsigned Bitfield Move", "heading": "UBFM", "para": "Unsigned Bitfield Move is usually accessed via one of its aliases, which are  always preferred for disassembly. \n\nIf <imms> is greater than or equal to <immr>, this copies a bitfield of \n(<imms>-<immr>+1) bits starting from bit position <immr> in the source  register to the least significant bits of the destination register. \n\nIf <imms> is less than <immr>, this copies a bitfield of (<imms>+1) bits from  the least significant bits of the source register to bit position \n(regsize-<immr>) of the destination register, where regsize is the destination  register size of 32 or 64 bits. \n\nIn both cases the destination bits below and above the bitfield are set to  zero. \n\nThis instruction is used by the aliases LSL (immediate), LSR (immediate),  UBFIZ, UBFX, UXTB, and UXTH.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imms>": "For the 64-bit variant: is the leftmost bit number to be moved from the source, in the range 0 to 63, encoded in the \"imms\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<immr>": "For the 64-bit variant: is the right rotate amount, in the range 0 to 63, encoded in the \"immr\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["UBFM  <Wd>, <Wn>, #<immr>, #<imms>"]}, {"id": 84, "asmtemplate": "UQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement vector by multiple of 32-bit predicate constraint element count", "heading": "UQDECW (vector)", "para": "Unsigned saturating decrement vector by multiple of 32-bit predicate  constraint element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. The  results are saturated to the 32-bit unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}"]}, {"id": 304, "asmtemplate": "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Maximum Pairwise (vector)", "heading": "FMAXP (vector)", "para": "Floating-point Maximum Pairwise (vector). This instruction creates a vector by  concatenating the vector elements of the first source SIMD&FP register after  the vector elements of the second source SIMD&FP register, reads each pair of  adjacent vector elements from the concatenated vector, writes the larger of  each pair of values into a vector, and writes the vector to the destination  SIMD&FP register. All the values in this instruction are floating-point  values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 67, "asmtemplate": "LSLV<Xd>, <Xn>, <Xm>", "brief": "Logical Shift Left (register)", "heading": "LSL (register)", "para": "Logical Shift Left (register) shifts a register value left by a variable  number of bits, shifting in zeros, and writes the result to the destination  register. The remainder obtained by dividing the second source register by the  data size defines the number of bits by which the first source register is  left-shifted. \n\nThis is an alias of LSLV. This means:  \n* The encodings in this description are named to match the encodings of LSLV. \n* The description of LSLV gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["LSL  <Wd>, <Wn>, <Wm>"]}, {"id": 785, "asmtemplate": "LDUR  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register (unscaled)", "heading": "LDUR", "para": "Load Register (unscaled) calculates an address from a base register and an  immediate offset, loads a 32-bit word or 64-bit doubleword from memory,  zero-extends it, and writes it to a register. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDUR  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 1150, "asmtemplate": "MSUB  <Xd>, <Xn>, <Xm>, <Xa>", "brief": "Multiply-Subtract", "heading": "MSUB", "para": "Multiply-Subtract multiplies two register values, subtracts the product from a  third register value, and writes the result to the destination register. \n\nThis instruction is used by the alias MNEG.", "explanations": {"<Xm>": "Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xa>": "Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wa>": "Is the 32-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MSUB  <Wd>, <Wn>, <Wm>, <Wa>"]}, {"id": 850, "asmtemplate": "SUBS  <Xd>, <Xn|SP>, #<imm>{, <shift>}", "brief": "Subtract (immediate), setting flags", "heading": "SUBS (immediate)", "para": "Subtract (immediate), setting flags, subtracts an optionally-shifted immediate  value from a register value, and writes the result to the destination  register. It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMP (immediate).", "explanations": {"<imm>": "Is an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SUBS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}"]}, {"id": 299, "asmtemplate": "ORRS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise inclusive OR predicate", "heading": "ORR, ORRS (predicates)", "para": "Bitwise inclusive OR predicate. \n\nBitwise inclusive OR active elements of the second source predicate with  corresponding elements of the first source predicate and place the results in  the corresponding elements of the destination predicate. Inactive elements in  the destination predicate register are set to zero. Optionally sets the First \n(N), None (Z), !Last (C) condition flags based on the predicate result, and  the V flag to zero. \n\nThis instruction is used by the aliases MOVS (unpredicated), and MOV \n(predicate, unpredicated). \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["ORR     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "ORRS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 786, "asmtemplate": "FDUP    <Zd>.<T>, #<const>", "brief": "Broadcast 8-bit floating-point immediate to vector elements (unpredicated)", "heading": "FDUP", "para": "Broadcast 8-bit floating-point immediate to vector elements (unpredicated). \n\nUnconditionally broadcast the floating-point immediate into each element of  the destination vector. This instruction is unpredicated. \n\nThis instruction is used by the alias FMOV (immediate, unpredicated).", "explanations": {"<T><const>": "Is a floating-point immediate value expressable as ", "": "\u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FDUP    <Zd>.<T>, #<const>"]}, {"id": 630, "asmtemplate": "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Signed saturating Shift Left Unsigned (immediate)", "heading": "SQSHLU", "para": "Signed saturating Shift Left Unsigned (immediate). This instruction reads each  signed integer value in the vector of the source SIMD&FP register, shifts each  value by an immediate value, saturates the shifted result to an unsigned  integer value, places the result in a vector, and writes the vector to the  destination SIMD&FP register. The results are truncated. For rounded results,  see UQRSHL. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SQSHLU  <V><d>, <V><n>, #<shift>", "SQSHLU  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 860, "asmtemplate": "ST1B    {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Scatter store bytes from a vector (immediate index)", "heading": "ST1B (vector plus immediate)", "para": "Scatter store bytes from a vector (immediate index). \n\nScatter store of bytes from the active elements of a vector register to the  memory addresses generated by a vector base plus immediate index. The index is  in the range 0 to 31. Inactive elements are not written to memory. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST1B    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]", "ST1B    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 847, "asmtemplate": "FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>", "brief": "Floating-point Complex Add", "heading": "FCADD", "para": "Floating-point Complex Add. \n\nThis instruction operates on complex numbers that are represented in SIMD&FP  registers as pairs of elements, with the more significant element holding the  imaginary part of the number and the less significant element holding the real  part of the number. Each element holds a floating-point value. It performs the  following computation on the corresponding complex number element pairs from  the two source registers:  \n* Considering the complex number from the second source register on an Argand \n  diagram, the number is rotated counterclockwise by 90 or 270 degrees. \n* The rotated complex number is added to the complex number from the first \n  source register.  This instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FCADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"]}, {"id": 77, "asmtemplate": "UMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Unsigned minimum vectors (predicated)", "heading": "UMIN (vectors)", "para": "Unsigned minimum vectors (predicated). \n\nDetermine the unsigned minimum of active elements of the second source vector  and corresponding elements of the first source vector and destructively place  the results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 565, "asmtemplate": "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", "brief": "Floating-point fused Multiply-Add Long to accumulator (by element)", "heading": "FMLAL, FMLAL2 (by element)", "para": "Floating-point fused Multiply-Add Long to accumulator (by element). This  instruction multiplies the vector elements in the first source SIMD&FP  register by the specified value in the second source SIMD&FP register, and  accumulates the product to the corresponding vector element of the destination  SIMD&FP register. The instruction does not round the result of the multiply  before the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLAL and FMLAL2", "explanations": {"<index>": "Is the element index, encoded in the \"H:L:M\" fields.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMLAL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]", "FMLAL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.H[<index>]"]}, {"id": 738, "asmtemplate": "WHILELE <Pd>.<T>, <R><n>, <R><m>", "brief": "While incrementing signed scalar less than or equal to scalar", "heading": "WHILELE", "para": "While incrementing signed scalar less than or equal to scalar. \n\nGenerate a predicate that starting from the lowest numbered element is true  while the incrementing value of the first, signed scalar operand is less than  or equal to the second scalar operand and false thereafter up to the highest  numbered element. \n\nIf the second scalar operand is equal to the maximum signed integer value then  a condition which includes an equality test can never fail and the result will  be an all-true predicate. \n\nThe full width of the scalar operands is significant for the purposes of  comparison, and the full width first operand is incremented by one for each  destination predicate element, irrespective of the predicate result element  size. The first general-purpose source register is not itself updated. \n\nThe predicate result is placed in the predicate destination register. Sets the  First (N), None (Z), !Last (C) condition flags based on the predicate result,  and the V flag to zero.", "explanations": {"<m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T><R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field."}, "encodings": ["WHILELE <Pd>.<T>, <R><n>, <R><m>"]}, {"id": 739, "asmtemplate": "ST1D    {<Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store doublewords from vector (immediate index)", "heading": "ST1D (scalar plus immediate)", "para": "Contiguous store doublewords from vector (immediate index). \n\nContiguous store of doublewords from elements of a vector register to the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements are not  written to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 165, "asmtemplate": "FRINTM  <Dd>, <Dn>", "brief": "Floating-point Round to Integral, toward Minus infinity (scalar)", "heading": "FRINTM (scalar)", "para": "Floating-point Round to Integral, toward Minus infinity (scalar). This  instruction rounds a floating-point value in the SIMD&FP source register to an  integral floating-point value of the same size using the Round towards Minus  Infinity rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FRINTM  <Hd>, <Hn>"]}, {"id": 322, "asmtemplate": "LDNT1H  {<Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-temporal halfwords to vector (immediate index)", "heading": "LDNT1H (scalar plus immediate)", "para": "Contiguous load non-temporal halfwords to vector (immediate index). \n\nContiguous load non-temporal of halfwords to elements of a vector register  from the memory address generated by a 64-bit scalar base and immediate index  in the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  will not not cause a read from Device memory or signal a fault, and are set to  zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDNT1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 953, "asmtemplate": "UMADDL  <Xd>, <Wn>, <Wm>, <Xa>", "brief": "Unsigned Multiply-Add Long", "heading": "UMADDL", "para": "Unsigned Multiply-Add Long multiplies two 32-bit register values, adds a  64-bit register value, and writes the result to the 64-bit destination  register. \n\nThis instruction is used by the alias UMULL.", "explanations": {"<Xa>": "Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["UMADDL  <Xd>, <Wn>, <Wm>, <Xa>"]}, {"id": 173, "asmtemplate": "CRC32CX  <Wd>, <Wn>, <Xm>", "brief": "CRC32C checksum", "heading": "CRC32CB, CRC32CH, CRC32CW, CRC32CX", "para": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value  held in a general-purpose register. It takes an input CRC value in the first  source operand, performs a CRC on the input value in the second source  operand, and returns the output CRC value. The second source operand can be 8,  16, 32, or 64 bits. To align with common usage, the bit order of the values is  reversed as part of the operation, and the polynomial 0x1EDC6F41 is used for  the CRC calculation. \n\nIn Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory  for all implementations to implement it. \n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.", "explanations": {"<Xm>": "Is the 64-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Wm>": "Is the 32-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose accumulator output register, encoded in the \"Rd\" field."}, "encodings": ["CRC32CB  <Wd>, <Wn>, <Wm>"]}, {"id": 1241, "asmtemplate": "STLR  <Xt>, [<Xn|SP>{,#0}]", "brief": "Store-Release Register", "heading": "STLR", "para": "Store-Release Register stores a 32-bit word or a 64-bit doubleword to a memory  location, from a register. The instruction also has memory ordering semantics  as described in Load-Acquire, Store-Release. For information about memory  accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STLR  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 267, "asmtemplate": "LDCLRLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic bit clear on byte in memory, without return", "heading": "STCLRB, STCLRLB", "para": "Atomic bit clear on byte in memory, without return, atomically loads an 8-bit  byte from memory, performs a bitwise AND with the complement of the value held  in a register on it, and stores the result back to memory.  \n* STCLRB does not have release semantics. \n* STCLRLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB. \n* The description of LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STCLRB  <Ws>, [<Xn|SP>]"]}, {"id": 412, "asmtemplate": "USHLL{2}<Vd>.<Ta>, <Vn>.<Tb>, #<shift>", "brief": "Unsigned Shift Left Long (immediate)", "heading": "USHLL, USHLL2", "para": "Unsigned Shift Left Long (immediate). This instruction reads each vector  element in the lower or upper half of the source SIMD&FP register, shifts the  unsigned integer value left by the specified number of bits, places the result  into a vector, and writes the vector to the destination SIMD&FP register. The  destination vector elements are twice as long as the source vector elements. \n\nThe USHLL instruction extracts vector elements from the lower half of the  source register, while the USHLL2 instruction extracts vector elements from  the upper half of the source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias UXTL, UXTL2.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the SIMD", "2<Vd>": "Is the name of the SIMD"}, "encodings": ["USHLL{2}  <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"]}, {"id": 673, "asmtemplate": "LDR  <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Load SIMD&FP Register (register offset)", "heading": "LDR (register, SIMD&FP)", "para": "Load SIMD&FP Register (register offset). This instruction loads a SIMD&FP  register from memory. The address that is used for the load is calculated from  a base register value and an offset register value. The offset can be  optionally shifted and extended. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP register to be transferred, encoded in the \"Rt\" field.", "<St>": "Is the 32-bit name of the SIMD", "<Xm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Dt>": "Is the 64-bit name of the SIMD", "<Ht>": "Is the 16-bit name of the SIMD", "<Qt>": "Is the 128-bit name of the SIMD", "<extend><extend><amount>": "For the 8-bit variant: is the index shift amount, it must be ", "<Wm>": "When ", "<Bt>": "Is the 8-bit name of the SIMD"}, "encodings": ["LDR  <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"]}, {"id": 464, "asmtemplate": "DUP     <Zd>.<T>, <Zn>.<T>[<imm>]", "brief": "Broadcast indexed element to vector (unpredicated)", "heading": "DUP (indexed)", "para": "Broadcast indexed element to vector (unpredicated). \n\nUnconditionally broadcast the indexed source vector element into each element  of the destination vector. This instruction is unpredicated. \n\nThe immediate element index is in the range of 0 to 63 (bytes), 31 \n(halfwords), 15 (words), 7 (doublewords) or 3 (quadwords). Selecting an  element beyond the accessible vector length causes the destination vector to  be set to zero. \n\nThis instruction is used by the alias MOV (SIMD&FP scalar, unpredicated).", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<imm>": "Is the immediate index, in the range 0 to one less than the number of elements in 512 bits, encoded in \"imm2:tsz\".", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["DUP     <Zd>.<T>, <Zn>.<T>[<imm>]"]}, {"id": 841, "asmtemplate": "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]", "brief": "Duplicate vector element to vector or scalar", "heading": "DUP (element)", "para": "Duplicate vector element to vector or scalar. This instruction duplicates the  vector element at the specified element index in the source SIMD&FP register  into a scalar or each element in a vector, and writes the result to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias MOV (scalar). \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD", "<index><d>": "Is the number of the SIMD", "<T><T><Ts><V><Vn>": "Is the name of the SIMD"}, "encodings": ["DUP  <V><d>, <Vn>.<T>[<index>]", "DUP  <Vd>.<T>, <Vn>.<Ts>[<index>]"]}, {"id": 374, "asmtemplate": "STURB  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Store Register Byte (unscaled)", "heading": "STURB", "para": "Store Register Byte (unscaled) calculates an address from a base register  value and an immediate offset, and stores a byte to the calculated address,  from a 32-bit register. For information about memory accesses, see Load/Store  addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STURB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 561, "asmtemplate": "PRFW    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous prefetch words (scalar index)", "heading": "PRFW (scalar plus scalar)", "para": "Contiguous prefetch words (scalar index). \n\nContiguous prefetch of word elements from the memory address generated by a  64-bit scalar base and scalar index which is multiplied by 4 and added to the  base address. After each element prefetch the index value is incremented, but  the index register is not updated. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFW    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 746, "asmtemplate": "MOVN  <Xd>, #<imm>{, LSL #<shift>}", "brief": "Move wide with NOT", "heading": "MOVN", "para": "Move wide with NOT moves the inverse of an optionally-shifted 16-bit immediate  value to a register. \n\nThis instruction is used by the alias MOV (inverted wide immediate).", "explanations": {"": "/16.", "<imm>": "Is the 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MOVN  <Wd>, #<imm>{, LSL #<shift>}"]}, {"id": 425, "asmtemplate": "SYS #<op1>, C7, <Cm>, #<op2>{, <Xt>}", "brief": "Instruction Cache operation", "heading": "IC", "para": "Instruction Cache operation. For more information, see op0==0b01, cache  maintenance, TLB maintenance, and address translation instructions. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xt>": "Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field.", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<ic_op><op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field."}, "encodings": ["IC  <ic_op>{, <Xt>}"]}, {"id": 414, "asmtemplate": "LD1W    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load unsigned words to vector (vector index)", "heading": "LD1W (scalar plus vector)", "para": "Gather load unsigned words to vector (vector index). \n\nGather load of unsigned words to active elements of a vector register from  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 4. Inactive elements will not cause a read from  Device memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 631, "asmtemplate": "UQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment scalar by multiple of 16-bit predicate constraint element count", "heading": "UQINCH (scalar)", "para": "Unsigned saturating increment scalar by multiple of 16-bit predicate  constraint element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCH  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQINCH  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 857, "asmtemplate": "REV16  <Vd>.<T>, <Vn>.<T>", "brief": "Reverse elements in 16-bit halfwords (vector)", "heading": "REV16 (vector)", "para": "Reverse elements in 16-bit halfwords (vector). This instruction reverses the  order of 8-bit elements in each halfword of the vector in the source SIMD&FP  register, places the results into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["REV16  <Vd>.<T>, <Vn>.<T>"]}, {"id": 1025, "asmtemplate": "FADDA   <V><dn>, <Pg>, <V><dn>, <Zm>.<T>", "brief": "Floating-point add strictly-ordered reduction, accumulating in scalar", "heading": "FADDA", "para": "Floating-point add strictly-ordered reduction, accumulating in scalar. \n\nFloating-point add a SIMD&FP scalar source and all active lanes of the vector  source and place the result destructively in the SIMD&FP scalar source  register. Vector elements are processed strictly in order from low to high,  with the scalar source providing the initial value. Inactive elements in the  source vector are ignored.", "explanations": {"": "FP register, encoded in the \"Vdn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the source scalable vector register, encoded in the \"Zm\" field.", "<V><dn>": "Is the number [0-31] of the source and destination SIMD"}, "encodings": ["FADDA   <V><dn>, <Pg>, <V><dn>, <Zm>.<T>"]}, {"id": 693, "asmtemplate": "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Multiply (vector)", "heading": "FMUL (vector)", "para": "Floating-point Multiply (vector). This instruction multiplies corresponding  floating-point values in the vectors in the two source SIMD&FP registers,  places the result in a vector, and writes the vector to the destination  SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 687, "asmtemplate": "SQABS  <Vd>.<T>, <Vn>.<T>", "brief": "Signed saturating Absolute value", "heading": "SQABS", "para": "Signed saturating Absolute value. This instruction reads each vector element  from the source SIMD&FP register, puts the absolute value of the result into a  vector, and writes the vector to the destination SIMD&FP register. All the  values in this instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SQABS  <V><d>, <V><n>", "SQABS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 68, "asmtemplate": "ADD  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Add (shifted register)", "heading": "ADD (shifted register)", "para": "Add (shifted register) adds a register value and an optionally-shifted  register value, and writes the result to the destination register.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ADD  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 727, "asmtemplate": "CLASTA  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>", "brief": "Conditionally extract element after last to vector register", "heading": "CLASTA (vectors)", "para": "Conditionally extract element after last to vector register. \n\nFrom the second source vector register extract the element after the last  active element, or if the last active element is the final element extract  element zero, and then replicate that element to destructively fill the  destination and first source vector. \n\nIf there are no active elements then leave the destination and source vector  unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["CLASTA  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 262, "asmtemplate": "LDUMAXLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic unsigned maximum on byte in memory", "heading": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB", "para": "Atomic unsigned maximum on byte in memory atomically loads an 8-bit byte from  memory, compares it against the value held in a register, and stores the  larger value back to memory, treating the values as unsigned numbers. The  value initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDUMAXAB and LDUMAXALB load from \n  memory with acquire semantics. \n* LDUMAXLB and LDUMAXALB store to memory with release semantics. \n* LDUMAXB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMAXB, STUMAXLB.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDUMAXAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 199, "asmtemplate": "FMULX   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point multiply-extended vectors (predicated)", "heading": "FMULX", "para": "Floating-point Multiply extended. This instruction multiplies corresponding  floating-point values in the vectors of the two source SIMD&FP registers,  places the resulting floating-point values in a vector, and writes the vector  to the destination SIMD&FP register. \n\nIf one value is zero and the other value is infinite, the result is 2.0. In  this case, the result is negative if only one of the values is negative,  otherwise the result is positive. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMULX  <Hd>, <Hn>, <Hm>", "FMULX  <V><d>, <V><n>, <V><m>", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMULX  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1237, "asmtemplate": "UADDLP  <Vd>.<Ta>, <Vn>.<Tb>", "brief": "Unsigned Add Long Pairwise", "heading": "UADDLP", "para": "Unsigned Add Long Pairwise. This instruction adds pairs of adjacent unsigned  integer values from the vector in the source SIMD&FP register, places the  result into a vector, and writes the vector to the destination SIMD&FP  register. The destination vector elements are twice as long as the source  vector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["UADDLP  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 761, "asmtemplate": "LD64B  <Xt>, [<Xn|SP> {,#0}]", "brief": "Single-copy Atomic 64-byte Load", "heading": "LD64B", "para": "Single-copy Atomic 64-byte Load derives an address from a base register value,  loads eight 64-bit doublewords from a memory location, and writes them to  consecutive registers, Xt to X(t+7). The data that is loaded is atomic and is  required to be 64-byte aligned.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LD64B  <Xt>, [<Xn|SP> {,#0}]"]}, {"id": 30, "asmtemplate": "LDLAR  <Xt>, [<Xn|SP>{,#0}]", "brief": "Load LOAcquire Register", "heading": "LDLAR", "para": "Load LOAcquire Register loads a 32-bit word or 64-bit doubleword from memory,  and writes it to a register. The instruction also has memory ordering  semantics as described in Load LOAcquire, Store LORelease. For information  about memory accesses, see Load/Store addressing modes. \n\nFor this instruction, if the destination is WZR/XZR, it is impossible for  software to observe the presence of the acquire semantic other than its effect  on the arrival at endpoints.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDLAR  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1103, "asmtemplate": "ORV     <V><d>, <Pg>, <Zn>.<T>", "brief": "Bitwise inclusive OR reduction to scalar", "heading": "ORV", "para": "Bitwise inclusive OR reduction to scalar. \n\nBitwise inclusive OR horizontally across all lanes of a vector, and place the  result in the SIMD&FP scalar destination register. Inactive elements in the  source vector are treated as zero.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ORV     <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 585, "asmtemplate": "LDR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Load vector register", "heading": "LDR (vector)", "para": "Load vector register. \n\nLoad a vector register from a memory address generated by a 64-bit scalar  base, plus an immediate offset in the range -256 to 255 which is multiplied by  the current vector register size in bytes. This instruction is unpredicated. \n\nThe load is performed as a stream of byte elements in ascending element order,  without any endian conversion.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>": "Is the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields."}, "encodings": ["LDR     <Zt>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 768, "asmtemplate": "LDCLRL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic bit clear on word or doubleword in memory", "heading": "LDCLR, LDCLRA, LDCLRAL, LDCLRL", "para": "Atomic bit clear on word or doubleword in memory atomically loads a 32-bit  word or 64-bit doubleword from memory, performs a bitwise AND with the  complement of the value held in a register on it, and stores the result back  to memory. The value initially loaded from memory is returned in the  destination register.  \n* If the destination register is not one of WZR or XZR, LDCLRA and LDCLRAL \n  load from memory with acquire semantics. \n* LDCLRL and LDCLRAL store to memory with release semantics. \n* LDCLR has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STCLR, STCLRL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDCLR  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 404, "asmtemplate": "SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Halving Subtract", "heading": "SHSUB", "para": "Signed Halving Subtract. This instruction subtracts the elements in the vector  in the second source SIMD&FP register from the corresponding elements in the  vector in the first source SIMD&FP register, shifts each result right one bit,  places each result into elements of a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SHSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 781, "asmtemplate": "AESMC  <Vd>.16B, <Vn>.16B", "brief": "AES mix columns", "heading": "AESMC", "para": "AES mix columns.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["AESMC  <Vd>.16B, <Vn>.16B"]}, {"id": 700, "asmtemplate": "UMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>", "brief": "Unsigned maximum with immediate (unpredicated)", "heading": "UMAX (immediate)", "para": "Unsigned maximum with immediate (unpredicated). \n\nDetermine the unsigned maximum of an immediate and each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate is an unsigned 8-bit value in the range 0 to  255, inclusive. This instruction is unpredicated.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><imm>": "Is the unsigned immediate operand, in the range 0 to 255, encoded in the \"imm8\" field."}, "encodings": ["UMAX    <Zdn>.<T>, <Zdn>.<T>, #<imm>"]}, {"id": 1263, "asmtemplate": "STNT1H  {<Zt>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous store non-temporal halfwords from vector (scalar index)", "heading": "STNT1H (scalar plus scalar)", "para": "Contiguous store non-temporal halfwords from vector (scalar index). \n\nContiguous store non-temporal of halfwords from elements of a vector register  to the memory address generated by a 64-bit scalar base and scalar index which  is multiplied by 2 and added to the base address. After each element access  the index value is incremented, but the index register is not updated.  Inactive elements are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["STNT1H  { <Zt>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 1259, "asmtemplate": "SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Maximum Pairwise", "heading": "SMAXP", "para": "Signed Maximum Pairwise. This instruction creates a vector by concatenating  the vector elements of the first source SIMD&FP register after the vector  elements of the second source SIMD&FP register, reads each pair of adjacent  vector elements in the two source SIMD&FP registers, writes the largest of  each pair of signed integer values into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["SMAXP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 708, "asmtemplate": "FCVTZU  <Xd>, <Dn>", "brief": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar)", "heading": "FCVTZU (scalar, integer)", "para": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar).  This instruction converts the floating-point value in the SIMD&FP source  register to a 32-bit or 64-bit unsigned integer using the Round towards Zero  rounding mode, and writes the result to the general-purpose destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Dn>": "Is the 64-bit name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTZU  <Wd>, <Hn>"]}, {"id": 620, "asmtemplate": "FMUL    <Zd>.D, <Zn>.D, <Zm>.D[<imm>]", "brief": "Floating-point multiply by indexed elements", "heading": "FMUL (indexed)", "para": "Floating-point multiply by indexed elements. \n\nMultiply all floating-point elements within each 128-bit segment of the first  source vector by the specified element in the corresponding second source  vector segment. The results are placed in the corresponding elements of the  destination vector. \n\nThe elements within the second source vector are specified using an immediate  index which selects the same element position within each 128-bit vector  segment. The index range is from 0 to one less than the number of elements per  128-bit segment, encoded in 1 to 3 bits depending on the size of the element.  This instruction is unpredicated. \n\nIt has encodings from 3 classes: Half-precision , Single-precision and  Double-precision", "explanations": {"<imm>": "For the double-precision variant: is the immediate index, in the range 0 to 1, encoded in the \"i1\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "For the double-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["FMUL    <Zd>.H, <Zn>.H, <Zm>.H[<imm>]", "FMUL    <Zd>.S, <Zn>.S, <Zm>.S[<imm>]", "FMUL    <Zd>.D, <Zn>.D, <Zm>.D[<imm>]"]}, {"id": 75, "asmtemplate": "FCVTXN{2}<Vd>.<Tb>, <Vn>.<Ta>", "brief": "Floating-point Convert to lower precision Narrow, rounding to odd (vector)", "heading": "FCVTXN, FCVTXN2", "para": "Floating-point Convert to lower precision Narrow, rounding to odd (vector).  This instruction reads each vector element in the source SIMD&FP register,  narrows each value to half the precision of the source element using the Round  to Odd rounding mode, writes the result to a vector, and writes the vector to  the destination SIMD&FP register. \n\nThis instruction uses the Round to Odd rounding mode which is not defined by  the IEEE 754-2008 standard. This rounding mode ensures that if the result of  the conversion is inexact the least significant bit of the mantissa is forced  to 1. This rounding mode enables a floating-point value to be converted to a  lower precision format via an intermediate precision format while avoiding  double rounding errors. For example, a 64-bit floating-point value can be  converted to a correctly rounded 16-bit floating-point value by first using  this instruction to produce a 32-bit value and then using another instruction  with the wanted rounding mode to convert the 32-bit value to the final 16-bit  floating-point value. \n\nThe FCVTXN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the FCVTXN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Va><n>": "Is the number of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTXN  <Vb><d>, <Va><n>", "FCVTXN{2}  <Vd>.<Tb>, <Vn>.<Ta>"]}, {"id": 723, "asmtemplate": "HINT  #<imm>", "brief": "Hint instruction", "heading": "HINT", "para": "Hint instruction is for the instruction set space that is reserved for  architectural hint instructions. \n\nSome encodings described here are not allocated in this revision of the  architecture, and behave as NOPs. These encodings might be allocated to other  hint functionality in future revisions of the architecture and therefore must  not be used by software.", "explanations": {"": "For allocated encodings of \"CRm:op2\":", "<imm>": "Is a 7-bit unsigned immediate, in the range 0 to 127 encoded in the \"CRm:op2\" field."}, "encodings": ["HINT  #<imm>"]}, {"id": 731, "asmtemplate": "ORRS<Pd>.B, <Pn>/Z, <Pn>.B, <Pn>.B", "brief": "Move predicate (unpredicated), setting the condition flags", "heading": "MOVS (unpredicated)", "para": "Move predicate (unpredicated), setting the condition flags. \n\nRead all elements from the source predicate and place in the destination  predicate. This instruction is unpredicated. Sets the First (N), None (Z), \n!Last (C) condition flags based on the predicate result, and the V flag to  zero. \n\nThis is an alias of ORR, ORRS (predicates). This means:  \n* The encodings in this description are named to match the encodings of ORR, \n  ORRS (predicates). \n* The description of ORR, ORRS (predicates) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["MOVS    <Pd>.B, <Pn>.B"]}, {"id": 818, "asmtemplate": "ST2H    {<Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous store two-halfword structures from two vectors (scalar index)", "heading": "ST2H (scalar plus scalar)", "para": "Contiguous store two-halfword structures from two vectors (scalar index). \n\nContiguous store two-halfword structures, each from the same element number in  two vector registers to the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by two. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive halfwords in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST2H    { <Zt1>.H, <Zt2>.H }, <Pg>, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 1098, "asmtemplate": "PRFH    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous prefetch halfwords (scalar index)", "heading": "PRFH (scalar plus scalar)", "para": "Contiguous prefetch halfwords (scalar index). \n\nContiguous prefetch of halfword elements from the memory address generated by  a 64-bit scalar base and scalar index which is multiplied by 2 and added to  the base address. After each element prefetch the index value is incremented,  but the index register is not updated. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFH    <prfop>, <Pg>, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 16, "asmtemplate": "LDADDL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic add on word or doubleword in memory", "heading": "LDADD, LDADDA, LDADDAL, LDADDL", "para": "Atomic add on word or doubleword in memory atomically loads a 32-bit word or  64-bit doubleword from memory, adds the value held in a register to it, and  stores the result back to memory. The value initially loaded from memory is  returned in the destination register.  \n* If the destination register is not one of WZR or XZR, LDADDA and LDADDAL \n  load from memory with acquire semantics. \n* LDADDL and LDADDAL store to memory with release semantics. \n* LDADD has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STADD, STADDL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDADD  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 103, "asmtemplate": "SHA1M  <Qd>, <Sn>, <Vm>.4S", "brief": "SHA1 hash update (majority)", "heading": "SHA1M", "para": "SHA1 hash update (majority).", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the third SIMD", "<Sn>": "Is the 32-bit name of the second SIMD", "<Qd>": "Is the 128-bit name of the SIMD"}, "encodings": ["SHA1M  <Qd>, <Sn>, <Vm>.4S"]}, {"id": 856, "asmtemplate": "ST3D    {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous store three-doubleword structures from three vectors (scalar index)", "heading": "ST3D (scalar plus scalar)", "para": "Contiguous store three-doubleword structures from three vectors (scalar  index). \n\nContiguous store three-doubleword structures, each from the same element  number in three vector registers to the memory address generated by a 64-bit  scalar base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by three. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive doublewords in  memory which make up each structure. Inactive structures are not written to  memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 243, "asmtemplate": "ORR<Vd>.<T>, <Vn>.<T>, <Vn>.<T>", "brief": "Move vector", "heading": "MOV (vector)", "para": "Move vector. This instruction copies the vector in the source SIMD&FP register  into the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of ORR (vector, register). This means:  \n* The encodings in this description are named to match the encodings of ORR \n  (vector, register). \n* The description of ORR (vector, register) gives the operational pseudocode \n  for this instruction.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><Vn>": "Is the name of the first SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["MOV  <Vd>.<T>, <Vn>.<T>"]}, {"id": 568, "asmtemplate": "LD4R  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T>}, [<Xn|SP>], <Xm>", "brief": "Load single 4-element structure and Replicate to all lanes of four registers", "heading": "LD4R", "para": "Load single 4-element structure and Replicate to all lanes of four registers.  This instruction loads a 4-element structure from memory and replicates the  structure to all the lanes of the four SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 3 modulo 32.", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<T><Vt2>": "Is the name of the second SIMD"}, "encodings": ["LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]", "LD4R  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 150, "asmtemplate": "UMMLA   <Zda>.S, <Zn>.B, <Zm>.B", "brief": "Unsigned integer matrix multiply-accumulate", "heading": "UMMLA", "para": "Unsigned integer matrix multiply-accumulate. \n\nThe unsigned integer matrix multiply-accumulate instruction multiplies the 2\u00d78  matrix of unsigned 8-bit integer values held in each 128-bit segment of the  first source vector by the 8\u00d72 matrix of unsigned 8-bit integer values in the  corresponding segment of the second source vector. The resulting 2\u00d72 widened  32-bit integer matrix product is then destructively added to the 32-bit  integer matrix accumulator held in the corresponding segment of the addend and  destination vector. This is equivalent to performing an 8-way dot product per  destination element. \n\nThis instruction is unpredicated. \n\nID_AA64ZFR0_EL1.I8MM indicates whether this instruction is implemented.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UMMLA   <Zda>.S, <Zn>.B, <Zm>.B"]}, {"id": 273, "asmtemplate": "FRINT64Z  <Dd>, <Dn>", "brief": "Floating-point Round to 64-bit Integer toward Zero (scalar)", "heading": "FRINT64Z (scalar)", "para": "Floating-point Round to 64-bit Integer toward Zero (scalar). This instruction  rounds a floating-point value in the SIMD&FP source register to an integral  floating-point value that fits into a 64-bit integer size using the Round  towards Zero rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA zero input returns a zero result with the same sign. When the result value  is not numerically equal to the {corresponding} input value, an Inexact  exception is raised. When the input is infinite, NaN or out-of-range, the  instruction returns {for the corresponding result value} the most negative  integer representable in the destination size, and an Invalid Operation  floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Sd>": "Is the 32-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FRINT64Z  <Sd>, <Sn>"]}, {"id": 303, "asmtemplate": "SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S", "brief": "SM4 Key", "heading": "SM4EKEY", "para": "SM4 Key takes an input as a 128-bit vector from the first source SIMD&FP  register and a 128-bit constant from the second SIMD&FP register. It derives  four iterations of the output key, in accordance with the SM4 standard,  returning the 128-bit result to the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SM4 is implemented.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["SM4EKEY  <Vd>.4S, <Vn>.4S, <Vm>.4S"]}, {"id": 657, "asmtemplate": "LDEORLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic exclusive OR on halfword in memory, without return", "heading": "STEORH, STEORLH", "para": "Atomic exclusive OR on halfword in memory, without return, atomically loads a  16-bit halfword from memory, performs an exclusive OR with the value held in a  register on it, and stores the result back to memory.  \n* STEORH does not have release semantics. \n* STEORLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDEORH, LDEORAH, LDEORALH, LDEORLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDEORH, LDEORAH, LDEORALH, LDEORLH. \n* The description of LDEORH, LDEORAH, LDEORALH, LDEORLH gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STEORH  <Ws>, [<Xn|SP>]"]}, {"id": 722, "asmtemplate": "PMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Polynomial Multiply Long", "heading": "PMULL, PMULL2", "para": "Polynomial Multiply Long. This instruction multiplies corresponding elements  in the lower or upper half of the vectors of the two source SIMD&FP registers,  places the results in a vector, and writes the vector to the destination  SIMD&FP register. The destination vector elements are twice as long as the  elements that are multiplied. \n\nFor information about multiplying polynomials see Polynomial arithmetic over \n{0, 1}. \n\nThe PMULL instruction extracts each source vector from the lower half of each  source register, while the PMULL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["PMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 701, "asmtemplate": "ADDS XZR, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Compare Negative (shifted register)", "heading": "CMN (shifted register)", "para": "Compare Negative (shifted register) adds a register value and an  optionally-shifted register value. It updates the condition flags based on the  result, and discards the result. \n\nThis is an alias of ADDS (shifted register). This means:  \n* The encodings in this description are named to match the encodings of ADDS \n  (shifted register). \n* The description of ADDS (shifted register) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["CMN  <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 878, "asmtemplate": "ADDG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>", "brief": "Add with Tag", "heading": "ADDG", "para": "Add with Tag adds an immediate value scaled by the Tag granule to the address  in the source register, modifies the Logical Address Tag of the address using  an immediate value, and writes the result to the destination register. Tags  specified in GCR_EL1.Exclude are excluded from the possible outputs when  modifying the Logical Address Tag.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<uimm4>": "Is an unsigned immediate, in the range 0 to 15, encoded in the \"uimm4\" field.", "<uimm6>": "Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the \"uimm6\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Xd\" field."}, "encodings": ["ADDG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"]}, {"id": 450, "asmtemplate": "ST4D    {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous store four-doubleword structures from four vectors (scalar index)", "heading": "ST4D (scalar plus scalar)", "para": "Contiguous store four-doubleword structures from four vectors (scalar index). \n\nContiguous store four-doubleword structures, each from the same element number  in four vector registers to the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by four. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive doublewords in  memory which make up each structure. Inactive structures are not written to  memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 19, "asmtemplate": "UCVTF   <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Unsigned integer convert to floating-point (predicated)", "heading": "UCVTF", "para": "Unsigned integer convert to floating-point (predicated). \n\nConvert to floating-point from the unsigned integer in each active element of  the source vector, and place the results in the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nIf the input and result types have a different size the smaller type is held  unpacked in the least significant bits of elements of the larger size. When  the input is the smaller type the upper bits of each source element are  ignored. When the result is the smaller type the results are zero-extended to  fill each destination element. \n\nIt has encodings from 7 classes: 16-bit to half-precision , 32-bit to  half-precision , 32-bit to single-precision , 32-bit to double-precision ,  64-bit to half-precision , 64-bit to single-precision and 64-bit to  double-precision", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["UCVTF   <Zd>.H, <Pg>/M, <Zn>.H", "UCVTF   <Zd>.H, <Pg>/M, <Zn>.S", "UCVTF   <Zd>.S, <Pg>/M, <Zn>.S", "UCVTF   <Zd>.D, <Pg>/M, <Zn>.S", "UCVTF   <Zd>.H, <Pg>/M, <Zn>.D", "UCVTF   <Zd>.S, <Pg>/M, <Zn>.D", "UCVTF   <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 828, "asmtemplate": "FSUB  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Subtract (scalar)", "heading": "FSUB (scalar)", "para": "Floating-point Subtract (scalar). This instruction subtracts the  floating-point value of the second source SIMD&FP register from the  floating-point value of the first source SIMD&FP register, and writes the  result to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FSUB  <Hd>, <Hn>, <Hm>"]}, {"id": 164, "asmtemplate": "STZ2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]", "brief": "Store Allocation Tags, Zeroing", "heading": "STZ2G", "para": "Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of  memory, zeroing the associated data locations. The address used for the store  is calculated from the base register and an immediate signed offset scaled by  the Tag granule. The Allocation Tag is calculated from the Logical Address Tag  in the source register. \n\nThis instruction generates an Unchecked access. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"<Xt|SP>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<simm>": "Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."}, "encodings": ["STZ2G  <Xt|SP>, [<Xn|SP>], #<simm>", "STZ2G  <Xt|SP>, [<Xn|SP>, #<simm>]!", "STZ2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]"]}, {"id": 667, "asmtemplate": "FCVTNS  <Xd>, <Dn>", "brief": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar)", "heading": "FCVTNS (scalar)", "para": "Floating-point Convert to Signed integer, rounding to nearest with ties to  even (scalar). This instruction converts the floating-point value in the  SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round  to Nearest rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTNS  <Wd>, <Hn>"]}, {"id": 1260, "asmtemplate": "LD1H    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load unsigned halfwords to vector (vector index)", "heading": "LD1H (scalar plus vector)", "para": "Gather load unsigned halfwords to vector (vector index). \n\nGather load of unsigned halfwords to active elements of a vector register from  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 2. Inactive elements will not cause a read from  Device memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 1157, "asmtemplate": "SUDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]", "brief": "Dot product with signed and unsigned integers (vector, by element)", "heading": "SUDOT (by element)", "para": "Dot product index form with signed and unsigned integers. This instruction  performs the dot product of the four signed 8-bit integer values in each  32-bit element of the first source register with the four unsigned 8-bit  integer values in an indexed 32-bit element of the second source register,  accumulating the result into the corresponding 32-bit element of the  destination vector. \n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is  mandatory for implementations that include Advanced SIMD to support it.  ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "explanations": {"<index>": "Is the immediate index of a quadtuplet of four 8-bit elements in the range 0 to 3, encoded in the \"H:L\" fields.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "": "FP source register, encoded in the \"M:Rm\" fields.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SUDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"]}, {"id": 39, "asmtemplate": "SQSHRUN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Signed saturating Shift Right Unsigned Narrow (immediate)", "heading": "SQSHRUN, SQSHRUN2", "para": "Signed saturating Shift Right Unsigned Narrow (immediate). This instruction  reads each signed integer value in the vector of the source SIMD&FP register,  right shifts each value by an immediate value, saturates the result to an  unsigned integer value that is half the original width, places the final  result into a vector, and writes the vector to the destination SIMD&FP  register. The results are truncated. For rounded results, see SQRSHRUN. \n\nThe SQSHRUN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SQSHRUN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Va><n>": "Is the number of the first SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["SQSHRUN  <Vb><d>, <Va><n>, #<shift>", "SQSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 756, "asmtemplate": "LD3B    {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load three-byte structures to three vectors (scalar index)", "heading": "LD3B (scalar plus scalar)", "para": "Contiguous load three-byte structures to three vectors (scalar index). \n\nContiguous load three-byte structures, each to the same element number in  three vector registers from the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register and added to the base address. After  each structure access the index value is incremented by three. The index  register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive bytes in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 219, "asmtemplate": "LDADDL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic add on word or doubleword in memory, without return", "heading": "STADD, STADDL", "para": "Atomic add on word or doubleword in memory, without return, atomically loads a  32-bit word or 64-bit doubleword from memory, adds the value held in a  register to it, and stores the result back to memory.  \n* STADD does not have release semantics. \n* STADDL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDADD, LDADDA, LDADDAL, LDADDL. This means:  \n* The encodings in this description are named to match the encodings of LDADD, \n  LDADDA, LDADDAL, LDADDL. \n* The description of LDADD, LDADDA, LDADDAL, LDADDL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STADD  <Ws>, [<Xn|SP>]"]}, {"id": 230, "asmtemplate": "CMPGT<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Compare signed less than vector, setting the condition flags", "heading": "CMPLT (vectors)", "para": "Compare signed less than vector, setting the condition flags. \n\nCompare active signed integer elements in the first source vector being less  than corresponding signed elements in the second source vector, and place the  boolean results of the comparison in the corresponding elements of the  destination predicate. Inactive elements in the destination predicate register  are set to zero. Sets the First (N), None (Z), !Last (C) condition flags based  on the predicate result, and the V flag to zero. \n\nThis is a pseudo-instruction of CMP<cc> (vectors). This means:  \n* The encodings in this description are named to match the encodings of \n  CMP<cc> (vectors). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of CMP<cc> (vectors) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 1189, "asmtemplate": "CPY<Zd>.<T>, <Pg>/M, <R><n|SP>", "brief": "Move general-purpose register to vector elements (predicated)", "heading": "MOV (scalar, predicated)", "para": "Move general-purpose register to vector elements (predicated). \n\nMove the general-purpose scalar source register to each active element in the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nThis is an alias of CPY (scalar). This means:  \n* The encodings in this description are named to match the encodings of CPY \n  (scalar). \n* The description of CPY (scalar) gives the operational pseudocode for this \n  instruction.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<R><n|SP>": "Is the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."}, "encodings": ["MOV     <Zd>.<T>, <Pg>/M, <R><n|SP>"]}, {"id": 526, "asmtemplate": "LD4B    {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load four-byte structures to four vectors (scalar index)", "heading": "LD4B (scalar plus scalar)", "para": "Contiguous load four-byte structures to four vectors (scalar index). \n\nContiguous load four-byte structures, each to the same element number in four  vector registers from the memory address generated by a 64-bit scalar base and  a 64-bit scalar index register and added to the base address. After each  structure access the index value is incremented by four. The index register is  not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive bytes in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 209, "asmtemplate": "NOT     <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Bitwise invert vector (predicated)", "heading": "NOT (vector)", "para": "Bitwise invert vector (predicated). \n\nBitwise invert each active element of the source vector, and place the results  in the corresponding elements of the destination vector. Inactive elements in  the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["NOT     <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 1209, "asmtemplate": "SWPLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Swap halfword in memory", "heading": "SWPH, SWPAH, SWPALH, SWPLH", "para": "Swap halfword in memory atomically loads a 16-bit halfword from a memory  location, and stores the value held in a register back to the same memory  location. The value initially loaded from memory is returned in the  destination register.  \n* If the destination register is not WZR, SWPAH and SWPALH load from memory \n  with acquire semantics. \n* SWPLH and SWPALH store to memory with release semantics. \n* SWPH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field."}, "encodings": ["SWPAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 184, "asmtemplate": "SEL<Zd>.<T>, <Pg>, <Zn>.<T>, <Zd>.<T>", "brief": "Move vector elements (predicated)", "heading": "MOV (vector, predicated)", "para": "Move vector elements (predicated). \n\nMove elements from the source vector to the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nThis is an alias of SEL (vectors). This means:  \n* The encodings in this description are named to match the encodings of SEL \n  (vectors). \n* The description of SEL (vectors) gives the operational pseudocode for this \n  instruction.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOV     <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 506, "asmtemplate": "GMI  <Xd>, <Xn|SP>, <Xm>", "brief": "Tag Mask Insert", "heading": "GMI", "para": "Tag Mask Insert inserts the tag in the first source register into the excluded  set specified in the second source register, writing the new excluded set to  the destination register.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Xm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Xd\" field."}, "encodings": ["GMI  <Xd>, <Xn|SP>, <Xm>"]}, {"id": 78, "asmtemplate": "ST2W    {<Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous store two-word structures from two vectors (scalar index)", "heading": "ST2W (scalar plus scalar)", "para": "Contiguous store two-word structures from two vectors (scalar index). \n\nContiguous store two-word structures, each from the same element number in two  vector registers to the memory address generated by a 64-bit scalar base and a  64-bit scalar index register scaled by the element size (LSL option) and added  to the base address. After each structure access the index value is  incremented by two. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive words in memory which  make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST2W    { <Zt1>.S, <Zt2>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 417, "asmtemplate": "STNT1W  {<Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous store non-temporal words from vector (scalar index)", "heading": "STNT1W (scalar plus scalar)", "para": "Contiguous store non-temporal words from vector (scalar index). \n\nContiguous store non-temporal of words from elements of a vector register to  the memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 4 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements are not written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["STNT1W  { <Zt>.S }, <Pg>, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 474, "asmtemplate": "", "brief": "Move indexed element or SIMD&FP scalar to vector (unpredicated)", "heading": "MOV (SIMD&FP scalar, unpredicated)", "para": "Move indexed element or SIMD&FP scalar to vector (unpredicated). \n\nUnconditionally broadcast the SIMD&FP scalar into each element of the  destination vector. This instruction is unpredicated. \n\nThis is an alias of DUP (indexed). This means:  \n* The encodings in this description are named to match the encodings of DUP \n  (indexed). \n* The description of DUP (indexed) gives the operational pseudocode for this \n  instruction.", "explanations": {"": "FP register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<imm>": "Is the immediate index, in the range 0 to one less than the number of elements in 512 bits, encoded in \"imm2:tsz\".", "<V><n>": "Is the number [0-31] of the source SIMD", "<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["MOV     <Zd>.<T>, <V><n>"]}, {"id": 881, "asmtemplate": "SQDMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Signed saturating Doubling Multiply Long (by element)", "heading": "SQDMULL, SQDMULL2 (by element)", "para": "Signed saturating Doubling Multiply Long (by element). This instruction  multiplies each vector element in the lower or upper half of the first source  SIMD&FP register by the specified vector element of the second source SIMD&FP  register, doubles the results, places the final results in a vector, and  writes the vector to the destination SIMD&FP register. All the values in this  instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMULL instruction extracts the first source vector from the lower half  of the first source register, while the SQDMULL2 instruction extracts the  first source vector from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Tb><Va><d>": "Is the number of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD", "2<Vd>": "Is the name of the SIMD", "<Vb><n>": "Is the number of the first SIMD"}, "encodings": ["SQDMULL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]", "SQDMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 823, "asmtemplate": "ST3  {<Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Store single 3-element structure from one lane of three registers", "heading": "ST3 (single structure)", "para": "Store single 3-element structure from one lane of three registers. This  instruction stores a 3-element structure to memory from corresponding elements  of three SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "\".", "<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Vt3>": "Is the name of the third SIMD", "<Vt>": "Is the name of the first or only SIMD", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt2>": "Is the name of the second SIMD"}, "encodings": ["ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]", "ST3  { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3"]}, {"id": 413, "asmtemplate": "BRK  #<imm>", "brief": "Breakpoint instruction", "heading": "BRK", "para": "Breakpoint instruction. A BRK instruction generates a Breakpoint Instruction  exception. The PE records the exception in ESR_ELx, using the EC value 0x3c,  and captures the value of the immediate argument in ESR_ELx.ISS.", "explanations": {"<imm>": "Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."}, "encodings": ["BRK  #<imm>"]}, {"id": 718, "asmtemplate": "TBNZ  <R><t>, #<imm>, <label>", "brief": "Test bit and Branch if Nonzero", "heading": "TBNZ", "para": "Test bit and Branch if Nonzero compares the value of a bit in a  general-purpose register with zero, and conditionally branches to a label at a  PC-relative offset if the comparison is not equal. It provides a hint that  this is not a subroutine call or return. This instruction does not affect  condition flags.", "explanations": {"<label>": "Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-32KB, is encoded as \"imm14\" times 4.", "<R><t>": "Is the number [0-30] of the general-purpose register to be tested or the name ZR (31), encoded in the \"Rt\" field.", "<imm>": "Is the bit number to be tested, in the range 0 to 63, encoded in \"b5:b40\"."}, "encodings": ["TBNZ  <R><t>, #<imm>, <label>"]}, {"id": 1050, "asmtemplate": "MAD     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>", "brief": "Multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]", "heading": "MAD", "para": "Multiply-add vectors (predicated), writing multiplicand [Zdn = Za + Zdn * Zm]. \n\nMultiply the corresponding active elements of the first and second source  vectors and add to elements of the third (addend) vector. Destructively place  the results in the destination and first source (multiplicand) vector.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Za>": "Is the name of the third source scalable vector register, encoded in the \"Za\" field."}, "encodings": ["MAD     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>"]}, {"id": 801, "asmtemplate": "DECW    <Zdn>.S{, <pattern>{, MUL #<imm>}}", "brief": "Decrement vector by multiple of predicate constraint element count", "heading": "DECD, DECH, DECW (vector)", "para": "Decrement vector by multiple of predicate constraint element count. \n\nDetermines the number of active elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 3 classes: Doubleword , Halfword and Word", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["DECD    <Zdn>.D{, <pattern>{, MUL #<imm>}}", "DECH    <Zdn>.H{, <pattern>{, MUL #<imm>}}", "DECW    <Zdn>.S{, <pattern>{, MUL #<imm>}}"]}, {"id": 189, "asmtemplate": "STLXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", "brief": "Store-Release Exclusive Pair of registers", "heading": "STLXP", "para": "Store-Release Exclusive Pair of registers stores two 32-bit words or two  64-bit doublewords to a memory location if the PE has exclusive access to the  memory address, from two registers, and returns a status value of 0 if the  store was successful, or of 1 if no store was performed. See Synchronization  and semaphores. A 32-bit pair requires the address to be doubleword aligned  and is single-copy atomic at doubleword granularity. A 64-bit pair requires  the address to be quadword aligned and, if the Store-Exclusive succeeds, it  causes a single-copy atomic update of the 128-bit memory location being  updated. The instruction also has memory ordering semantics as described in  Load-Acquire, Store-Release. For information about memory accesses see  Load/Store addressing modes.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STLXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"]}, {"id": 638, "asmtemplate": "ST1W    {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store words from vector (immediate index)", "heading": "ST1W (scalar plus immediate)", "para": "Contiguous store words from vector (immediate index). \n\nContiguous store of words from elements of a vector register to the memory  address generated by a 64-bit scalar base and immediate index in the range -8  to 7 which is multiplied by the vector's in-memory size, irrespective of  predication, and added to the base address. Inactive elements are not written  to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST1W    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 683, "asmtemplate": "LDCLRLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic bit clear on halfword in memory, without return", "heading": "STCLRH, STCLRLH", "para": "Atomic bit clear on halfword in memory, without return, atomically loads a  16-bit halfword from memory, performs a bitwise AND with the complement of the  value held in a register on it, and stores the result back to memory.  \n* STCLRH does not have release semantics. \n* STCLRLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH. \n* The description of LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STCLRH  <Ws>, [<Xn|SP>]"]}, {"id": 279, "asmtemplate": "CPY<Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}", "brief": "Move signed integer immediate to vector elements (zeroing)", "heading": "MOV (immediate, predicated, zeroing)", "para": "Move signed integer immediate to vector elements (zeroing). \n\nMove a signed integer immediate to each active element in the destination  vector. Inactive elements in the destination vector register are set to zero. \n\nThe immediate operand is a signed value in the range -128 to +127, and for  element widths of 16 bits or higher it may also be a signed multiple of 256 in  the range -32768 to +32512 (excluding 0). \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<simm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\". \n\nThis is an alias of CPY (immediate, zeroing). This means:  \n* The encodings in this description are named to match the encodings of CPY \n  (immediate, zeroing). \n* The description of CPY (immediate, zeroing) gives the operational pseudocode \n  for this instruction.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<imm>": "Is a signed immediate in the range -128 to 127, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOV     <Zd>.<T>, <Pg>/Z, #<imm>{, <shift>}"]}, {"id": 962, "asmtemplate": "REV32  <Vd>.<T>, <Vn>.<T>", "brief": "Reverse elements in 32-bit words (vector)", "heading": "REV32 (vector)", "para": "Reverse elements in 32-bit words (vector). This instruction reverses the order  of 8-bit or 16-bit elements in each word of the vector in the source SIMD&FP  register, places the results into a vector, and writes the vector to the  destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["REV32  <Vd>.<T>, <Vn>.<T>"]}, {"id": 778, "asmtemplate": "AESE  <Vd>.16B, <Vn>.16B", "brief": "AES single round encryption", "heading": "AESE", "para": "AES single round encryption.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the second SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["AESE  <Vd>.16B, <Vn>.16B"]}, {"id": 1174, "asmtemplate": "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>", "brief": "Signed fixed-point Convert to Floating-point (vector)", "heading": "SCVTF (vector, fixed-point)", "para": "Signed fixed-point Convert to Floating-point (vector). This instruction  converts each element in a vector from fixed-point to floating-point using the  rounding mode that is specified by the FPCR, and writes the result to the  SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SCVTF  <V><d>, <V><n>, #<fbits>", "SCVTF  <Vd>.<T>, <Vn>.<T>, #<fbits>"]}, {"id": 1084, "asmtemplate": "SQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement vector by multiple of 32-bit predicate constraint element count", "heading": "SQDECW (vector)", "para": "Signed saturating decrement vector by multiple of 32-bit predicate constraint  element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. The  results are saturated to the 32-bit signed integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECW  <Zdn>.S{, <pattern>{, MUL #<imm>}}"]}, {"id": 996, "asmtemplate": "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned saturating Shift Left (register)", "heading": "UQSHL (register)", "para": "Unsigned saturating Shift Left (register). This instruction takes each element  in the vector of the first source SIMD&FP register, shifts the element by a  value from the least significant byte of the corresponding element of the  second source SIMD&FP register, places the results in a vector, and writes the  vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. Otherwise, it  is a right shift. The results are truncated. For rounded results, see UQRSHL. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["UQSHL  <V><d>, <V><n>, <V><m>", "UQSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 392, "asmtemplate": "CSNEG<Xd>, <Xn>, <Xn>, invert(<cond>)", "brief": "Conditional Negate", "heading": "CNEG", "para": "Conditional Negate returns, in the destination register, the negated value of  the source register if the condition is TRUE, and otherwise returns the value  of the source register. \n\nThis is an alias of CSNEG. This means:  \n* The encodings in this description are named to match the encodings of CSNEG. \n* The description of CSNEG gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<cond>": "Is one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted."}, "encodings": ["CNEG  <Wd>, <Wn>, <cond>"]}, {"id": 502, "asmtemplate": "SUB  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Subtract (shifted register)", "heading": "SUB (shifted register)", "para": "Subtract (shifted register) subtracts an optionally-shifted register value  from a register value, and writes the result to the destination register. \n\nThis instruction is used by the alias NEG (shifted register).", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SUB  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 908, "asmtemplate": "SADALP  <Vd>.<Ta>, <Vn>.<Tb>", "brief": "Signed Add and Accumulate Long Pairwise", "heading": "SADALP", "para": "Signed Add and Accumulate Long Pairwise. This instruction adds pairs of  adjacent signed integer values from the vector in the source SIMD&FP register  and accumulates the results into the vector elements of the destination  SIMD&FP register. The destination vector elements are twice as long as the  source vector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["SADALP  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 832, "asmtemplate": "FTSSEL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point trigonometric select coefficient", "heading": "FTSSEL", "para": "Floating-point trigonometric select coefficient. \n\nThe FTSSEL instruction selects the coefficient for the final multiplication in  the polynomial series approximation. The instruction places the value 1.0 or a  copy of the first source vector element in the destination element, depending  on bit 0 of the quadrant number q held in the corresponding element of the  second source vector. The sign bit of the destination element is copied from  bit 1 of the corresponding value of q. This instruction is unpredicated. \n\nTo compute sin(x) or cos(x) the instruction is executed with elements of the  first source vector set to x, adjusted to be in the range -\u03c0/4 < x \u2264 \u03c0/4. \n\nThe elements of the second source vector hold the corresponding value of the  quadrant q number as an integer not a floating-point value. The value q  satisfies the relationship (2q-1) \u00d7 \u03c0/4 < x \u2264 (2q+1) \u00d7 \u03c0/4.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FTSSEL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 43, "asmtemplate": "CMPHI<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Compare unsigned lower than vector, setting the condition flags", "heading": "CMPLO (vectors)", "para": "Compare unsigned lower than vector, setting the condition flags. \n\nCompare active unsigned integer elements in the first source vector being  lower than corresponding unsigned elements in the second source vector, and  place the boolean results of the comparison in the corresponding elements of  the destination predicate. Inactive elements in the destination predicate  register are set to zero. Sets the First (N), None (Z), !Last (C) condition  flags based on the predicate result, and the V flag to zero. \n\nThis is a pseudo-instruction of CMP<cc> (vectors). This means:  \n* The encodings in this description are named to match the encodings of \n  CMP<cc> (vectors). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of CMP<cc> (vectors) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPLO   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 224, "asmtemplate": "SYS #<op1>, C7, <Cm>, #<op2>, <Xt>", "brief": "Data Cache operation", "heading": "DC", "para": "Data Cache operation. For more information, see op0==0b01, cache maintenance,  TLB maintenance, and address translation instructions. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<dc_op><op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."}, "encodings": ["DC  <dc_op>, <Xt>"]}, {"id": 715, "asmtemplate": "INS<Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]", "brief": "Move vector element to another vector element", "heading": "MOV (element)", "para": "Move vector element to another vector element. This instruction copies the  vector element of the source SIMD&FP register to the specified vector element  of the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP  register without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of INS (element). This means:  \n* The encodings in this description are named to match the encodings of INS \n  (element). \n* The description of INS (element) gives the operational pseudocode for this \n  instruction.", "explanations": {"<Vd>": "Is the name of the SIMD", "<Ts><index1><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["MOV  <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"]}, {"id": 287, "asmtemplate": "ADD     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Add vectors (predicated)", "heading": "ADD (vectors, predicated)", "para": "Add vectors (predicated). \n\nAdd active elements of the second source vector to corresponding elements of  the first source vector and destructively place the results in the  corresponding elements of the first source vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ADD     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1076, "asmtemplate": "SMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Signed minimum vectors (predicated)", "heading": "SMIN (vectors)", "para": "Signed minimum vectors (predicated). \n\nDetermine the signed minimum of active elements of the second source vector  and corresponding elements of the first source vector and destructively place  the results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 991, "asmtemplate": "REV  <Xd>, <Xn>", "brief": "Reverse Bytes", "heading": "REV", "para": "Reverse Bytes reverses the byte order in a register. \n\nThis instruction is used by the pseudo-instruction REV64.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["REV  <Wd>, <Wn>"]}, {"id": 678, "asmtemplate": "CMLT  <Vd>.<T>, <Vn>.<T>, #0", "brief": "Compare signed Less than zero (vector)", "heading": "CMLT (zero)", "para": "Compare signed Less than zero (vector). This instruction reads each vector  element in the source SIMD&FP register and if the signed integer value is less  than zero sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["CMLT  <V><d>, <V><n>, #0", "CMLT  <Vd>.<T>, <Vn>.<T>, #0"]}, {"id": 356, "asmtemplate": "LDEORL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic exclusive OR on word or doubleword in memory", "heading": "LDEOR, LDEORA, LDEORAL, LDEORL", "para": "Atomic exclusive OR on word or doubleword in memory atomically loads a 32-bit  word or 64-bit doubleword from memory, performs an exclusive OR with the value  held in a register on it, and stores the result back to memory. The value  initially loaded from memory is returned in the destination register.  \n* If the destination register is not one of WZR or XZR, LDEORA and LDEORAL \n  load from memory with acquire semantics. \n* LDEORL and LDEORAL store to memory with release semantics. \n* LDEOR has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STEOR, STEORL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDEOR  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 645, "asmtemplate": "LDNF1W  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault unsigned words to vector (immediate index)", "heading": "LDNF1W", "para": "Contiguous load non-fault unsigned words to vector (immediate index). \n\nContiguous load with non-faulting behavior of unsigned words to elements of a  vector register from the memory address generated by a 64-bit scalar base and  immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LDNF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 736, "asmtemplate": "LD1W    {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load unsigned words to vector (immediate index)", "heading": "LD1W (vector plus immediate)", "para": "Gather load unsigned words to vector (immediate index). \n\nGather load of unsigned words to active elements of a vector register from  memory addresses generated by a vector base plus immediate index. The index is  a multiple of 4 in the range 0 to 124. Inactive elements will not cause a read  from Device memory or signal faults, and are set to zero in the destination  vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 473, "asmtemplate": "LDRSW  <Xt>, <label>", "brief": "Load Register Signed Word (literal)", "heading": "LDRSW (literal)", "para": "Load Register Signed Word (literal) calculates an address from the PC value  and an immediate offset, loads a word from memory, and writes it to a  register. For information about memory accesses, see Load/Store addressing  modes.", "explanations": {"<label>": "Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDRSW  <Xt>, <label>"]}, {"id": 321, "asmtemplate": "MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Multiply-Subtract from accumulator (vector, by element)", "heading": "MLS (by element)", "para": "Multiply-Subtract from accumulator (vector, by element). This instruction  multiplies the vector elements in the first source SIMD&FP register by the  specified value in the second source SIMD&FP register, and subtracts the  results from the vector elements of the destination SIMD&FP register. All the  values in this instruction are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["MLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 939, "asmtemplate": "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Maximum Number (vector)", "heading": "FMAXNM (vector)", "para": "Floating-point Maximum Number (vector). This instruction compares  corresponding vector elements in the two source SIMD&FP registers, writes the  larger of the two floating-point values into a vector, and writes the vector  to the destination SIMD&FP register. \n\nNaNs are handled according to the IEEE 754-2008 standard. If one vector  element is numeric and the other is a quiet NaN, the result placed in the  vector is the numerical value, otherwise the result is identical to FMAX \n(scalar). \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMAXNM  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1205, "asmtemplate": "LDAPURSH  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load-Acquire RCpc Register Signed Halfword (unscaled)", "heading": "LDAPURSH", "para": "Load-Acquire RCpc Register Signed Halfword (unscaled) calculates an address  from a base register and an immediate offset, loads a signed halfword from  memory, sign-extends it, and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAPURSH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 998, "asmtemplate": "UBFM<Xd>, <Xn>, #<shift>, #63", "brief": "Logical Shift Right (immediate)", "heading": "LSR (immediate)", "para": "Logical Shift Right (immediate) shifts a register value right by an immediate  number of bits, shifting in zeros, and writes the result to the destination  register. \n\nThis is an alias of UBFM. This means:  \n* The encodings in this description are named to match the encodings of UBFM. \n* The description of UBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, encoded in the \"immr\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["LSR  <Wd>, <Wn>, #<shift>"]}, {"id": 1057, "asmtemplate": "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0", "brief": "Floating-point Compare Greater than or Equal to zero (vector)", "heading": "FCMGE (zero)", "para": "Floating-point Compare Greater than or Equal to zero (vector). This  instruction reads each floating-point value in the source SIMD&FP register and  if the value is greater than or equal to zero sets every bit of the  corresponding vector element in the destination SIMD&FP register to one,  otherwise sets every bit of the corresponding vector element in the  destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCMGE  <Hd>, <Hn>, #0.0", "FCMGE  <V><d>, <V><n>, #0.0", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0", "FCMGE  <Vd>.<T>, <Vn>.<T>, #0.0"]}, {"id": 796, "asmtemplate": "SMADDL  <Xd>, <Wn>, <Wm>, <Xa>", "brief": "Signed Multiply-Add Long", "heading": "SMADDL", "para": "Signed Multiply-Add Long multiplies two 32-bit register values, adds a 64-bit  register value, and writes the result to the 64-bit destination register. \n\nThis instruction is used by the alias SMULL.", "explanations": {"<Xa>": "Is the 64-bit name of the third general-purpose source register holding the addend, encoded in the \"Ra\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SMADDL  <Xd>, <Wn>, <Wm>, <Xa>"]}, {"id": 539, "asmtemplate": "SUBS XZR, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Compare (shifted register)", "heading": "CMP (shifted register)", "para": "Compare (shifted register) subtracts an optionally-shifted register value from  a register value. It updates the condition flags based on the result, and  discards the result. \n\nThis is an alias of SUBS (shifted register). This means:  \n* The encodings in this description are named to match the encodings of SUBS \n  (shifted register). \n* The description of SUBS (shifted register) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["CMP  <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 270, "asmtemplate": "LD1SH   {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load signed halfwords to vector (scalar index)", "heading": "LD1SH (scalar plus scalar)", "para": "Contiguous load signed halfwords to vector (scalar index). \n\nContiguous load of signed halfwords to elements of a vector register from the  memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 2 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1SH   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "LD1SH   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 1191, "asmtemplate": "MSB     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>", "brief": "Multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za - Zdn * Zm]", "heading": "MSB", "para": "Multiply-subtract vectors (predicated), writing multiplicand [Zdn = Za - Zdn *  Zm]. \n\nMultiply the corresponding active elements of the first and second source  vectors and subtract from elements of the third (addend) vector. Destructively  place the results in the destination and first source (multiplicand) vector.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Za>": "Is the name of the third source scalable vector register, encoded in the \"Za\" field."}, "encodings": ["MSB     <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>"]}, {"id": 91, "asmtemplate": "XPACLRI", "brief": "Strip Pointer Authentication Code", "heading": "XPACD, XPACI, XPACLRI", "para": "Strip Pointer Authentication Code. This instruction removes the pointer  authentication code from an address. The address is in the specified  general-purpose register for XPACI and XPACD, and is in LR for XPACLRI. \n\nThe XPACD instruction is used for data addresses, and XPACI and XPACLRI are  used for instruction addresses. \n\nIt has encodings from 2 classes: Integer and System", "explanations": {"<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["XPACD  <Xd>", "XPACLRI"]}, {"id": 804, "asmtemplate": "SBFM<Xd>, <Xn>, #0, #15", "brief": "Sign Extend Halfword", "heading": "SXTH", "para": "Sign Extend Halfword extracts a 16-bit value, sign-extends it to the size of  the register, and writes the result to the destination register. \n\nThis is an alias of SBFM. This means:  \n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SXTH  <Wd>, <Wn>"]}, {"id": 1187, "asmtemplate": "LDNT1D  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-temporal doublewords to vector (immediate index)", "heading": "LDNT1D (scalar plus immediate)", "para": "Contiguous load non-temporal doublewords to vector (immediate index). \n\nContiguous load non-temporal of doublewords to elements of a vector register  from the memory address generated by a 64-bit scalar base and immediate index  in the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  will not not cause a read from Device memory or signal a fault, and are set to  zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDNT1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 155, "asmtemplate": "STLURB  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Store-Release Register Byte (unscaled)", "heading": "STLURB", "para": "Store-Release Register Byte (unscaled) calculates an address from a base  register value and an immediate offset, and stores a byte to the calculated  address, from a 32-bit register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."}, "encodings": ["STLURB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 961, "asmtemplate": "URSQRTE  <Vd>.<T>, <Vn>.<T>", "brief": "Unsigned Reciprocal Square Root Estimate", "heading": "URSQRTE", "para": "Unsigned Reciprocal Square Root Estimate. This instruction reads each vector  element from the source SIMD&FP register, calculates an approximate inverse  square root for each value, places the result into a vector, and writes the  vector to the destination SIMD&FP register. All the values in this instruction  are unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["URSQRTE  <Vd>.<T>, <Vn>.<T>"]}, {"id": 222, "asmtemplate": "ST1H    {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store halfwords from vector (immediate index)", "heading": "ST1H (scalar plus immediate)", "para": "Contiguous store halfwords from vector (immediate index). \n\nContiguous store of halfwords from elements of a vector register to the memory  address generated by a 64-bit scalar base and immediate index in the range -8  to 7 which is multiplied by the vector's in-memory size, irrespective of  predication, and added to the base address. Inactive elements are not written  to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST1H    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 697, "asmtemplate": "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Rounding Shift Left (register)", "heading": "SRSHL", "para": "Signed Rounding Shift Left (register). This instruction takes each signed  integer value in the vector of the first source SIMD&FP register, shifts it by  a value from the least significant byte of the corresponding element of the  second source SIMD&FP register, places the results in a vector, and writes the  vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift  value is negative, it is a rounding right shift. For a truncating shift, see  SSHL. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SRSHL  <V><d>, <V><n>, <V><m>", "SRSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 461, "asmtemplate": "LDADDLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic add on byte in memory", "heading": "LDADDB, LDADDAB, LDADDALB, LDADDLB", "para": "Atomic add on byte in memory atomically loads an 8-bit byte from memory, adds  the value held in a register to it, and stores the result back to memory. The  value initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDADDAB and LDADDALB load from \n  memory with acquire semantics. \n* LDADDLB and LDADDALB store to memory with release semantics. \n* LDADDB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STADDB, STADDLB.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDADDAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 325, "asmtemplate": "UQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement vector by multiple of 64-bit predicate constraint element count", "heading": "UQDECD (vector)", "para": "Unsigned saturating decrement vector by multiple of 64-bit predicate  constraint element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. The  results are saturated to the 64-bit unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECD  <Zdn>.D{, <pattern>{, MUL #<imm>}}"]}, {"id": 716, "asmtemplate": "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned saturating Subtract", "heading": "UQSUB", "para": "Unsigned saturating Subtract. This instruction subtracts the element values of  the second source SIMD&FP register from the corresponding element values of  the first source SIMD&FP register, places the results into a vector, and  writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["UQSUB  <V><d>, <V><n>, <V><m>", "UQSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 42, "asmtemplate": "FNMUL  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Multiply-Negate (scalar)", "heading": "FNMUL (scalar)", "para": "Floating-point Multiply-Negate (scalar). This instruction multiplies the  floating-point values of the two source SIMD&FP registers, and writes the  negation of the result to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Dn>": "Is the 64-bit name of the first SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FNMUL  <Hd>, <Hn>, <Hm>"]}, {"id": 131, "asmtemplate": "LDFF1SB {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "brief": "Contiguous load first-fault signed bytes to vector (scalar index)", "heading": "LDFF1SB (scalar plus scalar)", "para": "Contiguous load first-fault signed bytes to vector (scalar index). \n\nContiguous load with first-faulting behavior of signed bytes to elements of a  vector register from the memory address generated by a 64-bit scalar base and  scalar index which is added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1SB { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "LDFF1SB { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>}]", "LDFF1SB { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>}]"]}, {"id": 62, "asmtemplate": "UQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}", "brief": "Unsigned saturating subtract immediate (unpredicated)", "heading": "UQSUB (immediate)", "para": "Unsigned saturating subtract immediate (unpredicated). \n\nUnsigned saturating subtract an unsigned immediate from each element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. Each result element is saturated to the N-bit  element's unsigned integer range 0 to (2N)-1. This instruction is  unpredicated. \n\nThe immediate is an unsigned value in the range 0 to 255, and for element  widths of 16 bits or higher it may also be a positive multiple of 256 in the  range 256 to 65280. \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<uimm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\".", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><imm>": "Is an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field."}, "encodings": ["UQSUB   <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}"]}, {"id": 752, "asmtemplate": "UQSHRN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Unsigned saturating Shift Right Narrow (immediate)", "heading": "UQSHRN, UQSHRN2", "para": "Unsigned saturating Shift Right Narrow (immediate). This instruction reads  each vector element in the source SIMD&FP register, right shifts each result  by an immediate value, saturates each shifted result to a value that is half  the original width, puts the final result into a vector, and writes the vector  to the lower or upper half of the destination SIMD&FP register. All the values  in this instruction are unsigned integer values. The results are truncated.  For rounded results, see UQRSHRN. \n\nThe UQSHRN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the UQSHRN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"<Va><n>": "Is the number of the first SIMD", "": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["UQSHRN  <Vb><d>, <Va><n>, #<shift>", "UQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 181, "asmtemplate": "LD1RQB  {<Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load and replicate sixteen bytes (scalar index)", "heading": "LD1RQB (scalar plus scalar)", "para": "Contiguous load and replicate sixteen bytes (scalar index). \n\nLoad sixteen contiguous bytes to elements of a short, 128-bit (quadword)  vector from the memory address generated by a 64-bit scalar base address and  scalar index which is added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first sixteen predicate elements are used  and higher numbered predicate elements are ignored.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1RQB  { <Zt>.B }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 883, "asmtemplate": "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Compare unsigned Higher or Same (vector)", "heading": "CMHS (register)", "para": "Compare unsigned Higher or Same (vector). This instruction compares each  vector element in the first source SIMD&FP register with the corresponding  vector element in the second source SIMD&FP register and if the first unsigned  integer value is greater than or equal to the second unsigned integer value  sets every bit of the corresponding vector element in the destination SIMD&FP  register to one, otherwise sets every bit of the corresponding vector element  in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["CMHS  <V><d>, <V><n>, <V><m>", "CMHS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 231, "asmtemplate": "LDNF1H  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault unsigned halfwords to vector (immediate index)", "heading": "LDNF1H", "para": "Contiguous load non-fault unsigned halfwords to vector (immediate index). \n\nContiguous load with non-faulting behavior of unsigned halfwords to elements  of a vector register from the memory address generated by a 64-bit scalar base  and immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDNF1H  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 247, "asmtemplate": "LD1H    {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load unsigned halfwords to vector (immediate index)", "heading": "LD1H (vector plus immediate)", "para": "Gather load unsigned halfwords to vector (immediate index). \n\nGather load of unsigned halfwords to active elements of a vector register from  memory addresses generated by a vector base plus immediate index. The index is  a multiple of 2 in the range 0 to 62. Inactive elements will not cause a read  from Device memory or signal faults, and are set to zero in the destination  vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LD1H    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 400, "asmtemplate": "ADD  <Xd|SP>, <Xn|SP>, <R><m>{, <extend>{#<amount>}}", "brief": "Add (extended register)", "heading": "ADD (extended register)", "para": "Add (extended register) adds a register value and a sign or zero-extended  register value, followed by an optional left shift amount, and writes the  result to the destination register. The argument that is extended from the \n<Rm> register can be a byte, halfword, word, or doubleword.", "explanations": {"": " is present but not LSL.", "<R><m>": "Is the number [0-30] of the second general-purpose source register or the name ZR (31), encoded in the \"Rm\" field.", "<Xn|SP>": "Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<extend><extend><amount>": "Is the left shift amount to be applied after extension in the range 0 to 4, defaulting to 0, encoded in the \"imm3\" field. It must be absent when ", "<Wn|WSP>": "Is the 32-bit name of the first source general-purpose register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["ADD  <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"]}, {"id": 12, "asmtemplate": "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Unsigned Shift Right (immediate)", "heading": "USHR", "para": "Unsigned Shift Right (immediate). This instruction reads each vector element  in the source SIMD&FP register, right shifts each result by an immediate  value, writes the final result to a vector, and writes the vector to the  destination SIMD&FP register. All the values in this instruction are unsigned  integer values. The results are truncated. For rounded results, see URSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["USHR  <V><d>, <V><n>, #<shift>", "USHR  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 1231, "asmtemplate": "FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point subtract immediate (predicated)", "heading": "FSUB (immediate)", "para": "Floating-point subtract immediate (predicated). \n\nSubtract an immediate from each active floating-point element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate may take the value +0.5 or +1.0 only.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FSUB    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 1246, "asmtemplate": "SQDMLSL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Signed saturating Doubling Multiply-Subtract Long (by element)", "heading": "SQDMLSL, SQDMLSL2 (by element)", "para": "Signed saturating Doubling Multiply-Subtract Long (by element). This  instruction multiplies each vector element in the lower or upper half of the  first source SIMD&FP register by the specified vector element of the second  source SIMD&FP register, doubles the results, and subtracts the final results  from the vector elements of the destination SIMD&FP register. The destination  vector elements are twice as long as the elements that are multiplied. All the  values in this instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLSL instruction extracts vector elements from the lower half of the  first source register, while the SQDMLSL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Vb><n>": "Is the number of the first SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Tb><Va><d>": "Is the number of the SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SQDMLSL  <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]", "SQDMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 783, "asmtemplate": "WRFFR   <Pn>.B", "brief": "Write the first-fault register", "heading": "WRFFR", "para": "Write the first-fault register. \n\nRead the source predicate register and place in the first-fault register \n(FFR). This instruction is intended to restore a saved FFR and is not  recommended for general use by applications. \n\nThis instruction requires that the source predicate contains a monotonic  predicate value, in which starting from bit 0 there are zero or more 1 bits,  followed only by 0 bits in any remaining bit positions. If the source is not a  monotonic predicate value, then the resulting value in the FFR will be  UNPREDICTABLE. It is not possible to generate a non-monotonic value in FFR  when using SETFFR followed by first-fault or non-fault loads.", "explanations": {"<Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["WRFFR   <Pn>.B"]}, {"id": 770, "asmtemplate": "LD1SW   {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load signed words to vector (scalar index)", "heading": "LD1SW (scalar plus scalar)", "para": "Contiguous load signed words to vector (scalar index). \n\nContiguous load of signed words to elements of a vector register from the  memory address generated by a 64-bit scalar base and scalar index which is  multiplied by 4 and added to the base address. After each element access the  index value is incremented, but the index register is not updated. Inactive  elements will not not cause a read from Device memory or signal a fault, and  are set to zero in the destination vector.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1SW   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 380, "asmtemplate": "ZIP1    <Zd>.Q, <Zn>.Q, <Zm>.Q", "brief": "Interleave elements from two half vectors", "heading": "ZIP1, ZIP2 (vectors)", "para": "Interleave elements from two half vectors. \n\nInterleave alternating elements from the lowest or highest halves of the first  and second source vectors and place in elements of the destination vector.  This instruction is unpredicated. The 128-bit element variant of this  instruction requires that the current vector length is at least 256 bits, and  if the current vector length is not an integer multiple of 256 bits then the  trailing bits are set to zero. \n\nID_AA64ZFR0_EL1.F64MM indicates whether the 128-bit element variant of the  instruction is implemented. \n\nIt has encodings from 4 classes: High halves , High halves (quadwords) , Low  halves and Low halves (quadwords)", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ZIP2    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "ZIP2    <Zd>.Q, <Zn>.Q, <Zm>.Q", "ZIP1    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "ZIP1    <Zd>.Q, <Zn>.Q, <Zm>.Q"]}, {"id": 1264, "asmtemplate": "DCPS2  {#<imm>}", "brief": "Debug Change PE State to EL2.", "heading": "DCPS2", "para": "Debug Change PE State to EL2, when executed in Debug state:  \n* If executed at EL0 or EL1 changes the current Exception level and SP to EL2 \n  using SP_EL2. \n* Otherwise, if executed at ELx, selects SP_ELx.  The target exception level of a DCPS2 instruction is:  \n* EL2 if the instruction is executed at an exception level that is not EL3. \n* EL3 if the instruction is executed at EL3.  When the target Exception level of a DCPS2 instruction is ELx, on executing  this instruction:  \n* ELR_ELx becomes unknown. \n* SPSR_ELx becomes unknown. \n* ESR_ELx becomes unknown. \n* DLR_EL0 and DSPSR_EL0 become unknown. \n* The endianness is set according to SCTLR_ELx.EE.  This instruction is undefined at the following exception levels:  \n* All exception levels if EL2 is not implemented. \n* At EL0 and EL1 if EL2 is disabled in the current Security state.  This instruction is always undefined in Non-debug state. \n\nFor more information on the operation of the DCPSn instructions, see DCPS.", "explanations": {"<imm>": "Is an optional 16-bit unsigned immediate, in the range 0 to 65535, defaulting to 0 and encoded in the \"imm16\" field."}, "encodings": ["DCPS2  {#<imm>}"]}, {"id": 365, "asmtemplate": "FCMGE<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point compare less than or equal to vector", "heading": "FCMLE (vectors)", "para": "Floating-point compare less than or equal to vector. \n\nCompare active floating-point elements in the first source vector being less  than or equal to corresponding elements in the second source vector, and place  the boolean results of the comparison in the corresponding elements of the  destination predicate. Inactive elements in the destination predicate register  are set to zero. Does not set the condition flags. \n\nThis is a pseudo-instruction of FCM<cc> (vectors). This means:  \n* The encodings in this description are named to match the encodings of \n  FCM<cc> (vectors). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of FCM<cc> (vectors) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["FCMLE   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 318, "asmtemplate": "ORR  <Xd|SP>, <Xn>, #<imm>", "brief": "Bitwise OR (immediate)", "heading": "ORR (immediate)", "para": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value  and an immediate register value, and writes the result to the destination  register. \n\nThis instruction is used by the alias MOV (bitmask immediate).", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<imm>": "For the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\".", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wd|WSP>": "Is the 32-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Rd\" field."}, "encodings": ["ORR  <Wd|WSP>, <Wn>, #<imm>"]}, {"id": 345, "asmtemplate": "SDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>", "brief": "Signed integer dot product", "heading": "SDOT (vectors)", "para": "Signed integer dot product. \n\nThe signed integer dot product instruction computes the dot product of a group  of four signed 8-bit or 16-bit integer values held in each 32-bit or 64-bit  element of the first source vector multiplied by a group of four signed 8-bit  or 16-bit integer values in the corresponding 32-bit or 64-bit element of the  second source vector, and then destructively adds the widened dot product to  the corresponding 32-bit or 64-bit element of the destination vector. \n\nThis instruction is unpredicated.", "explanations": {"<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Tb><Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["SDOT    <Zda>.<T>, <Zn>.<Tb>, <Zm>.<Tb>"]}, {"id": 1197, "asmtemplate": "FCVTN{2}<Vd>.<Tb>, <Vn>.<Ta>", "brief": "Floating-point Convert to lower precision Narrow (vector)", "heading": "FCVTN, FCVTN2", "para": "Floating-point Convert to lower precision Narrow (vector). This instruction  reads each vector element in the SIMD&FP source register, converts each result  to half the precision of the source element, writes the final result to a  vector, and writes the vector to the lower or upper half of the destination  SIMD&FP register. The destination vector elements are half as long as the  source vector elements. The rounding mode is determined by the FPCR. \n\nThe FCVTN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the FCVTN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in FPSR  or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Tb><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FCVTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"]}, {"id": 1085, "asmtemplate": "PACDZB  <Xd>", "brief": "Pointer Authentication Code for Data address, using key B", "heading": "PACDB, PACDZB", "para": "Pointer Authentication Code for Data address, using key B. This instruction  computes and inserts a pointer authentication code for a data address, using a  modifier and key B. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACDB. \n* The value zero, for PACDZB.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["PACDB  <Xd>, <Xn|SP>"]}, {"id": 32, "asmtemplate": "FMLS    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]", "brief": "Floating-point fused multiply-subtract by indexed elements (Zda = Zda + -Zn * Zm[indexed])", "heading": "FMLS (indexed)", "para": "Floating-point fused multiply-subtract by indexed elements (Zda = Zda + -Zn *  Zm[indexed]). \n\nMultiply all floating-point elements within each 128-bit segment of the first  source vector by the specified element in the corresponding second source  vector segment. The products are then destructively subtracted without  intermediate rounding from the corresponding elements of the addend and  destination vector. \n\nThe elements within the second source vector are specified using an immediate  index which selects the same element position within each 128-bit vector  segment. The index range is from 0 to one less than the number of elements per  128-bit segment, encoded in 1 to 3 bits depending on the size of the element.  This instruction is unpredicated. \n\nIt has encodings from 3 classes: Half-precision , Single-precision and  Double-precision", "explanations": {"<imm>": "For the double-precision variant: is the immediate index, in the range 0 to 1, encoded in the \"i1\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "For the double-precision variant: is the name of the second source scalable vector register Z0-Z15, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["FMLS    <Zda>.H, <Zn>.H, <Zm>.H[<imm>]", "FMLS    <Zda>.S, <Zn>.S, <Zm>.S[<imm>]", "FMLS    <Zda>.D, <Zn>.D, <Zm>.D[<imm>]"]}, {"id": 34, "asmtemplate": "LD4H    {<Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load four-halfword structures to four vectors (scalar index)", "heading": "LD4H (scalar plus scalar)", "para": "Contiguous load four-halfword structures to four vectors (scalar index). \n\nContiguous load four-halfword structures, each to the same element number in  four vector registers from the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by four. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive halfwords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4H    { <Zt1>.H, <Zt2>.H, <Zt3>.H, <Zt4>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 855, "asmtemplate": "FCVTPU  <Xd>, <Dn>", "brief": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar)", "heading": "FCVTPU (scalar)", "para": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP  source register to a 32-bit or 64-bit unsigned integer using the Round towards  Plus Infinity rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Dn>": "Is the 64-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTPU  <Wd>, <Hn>"]}, {"id": 144, "asmtemplate": "STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Store Register Halfword (register)", "heading": "STRH (register)", "para": "Store Register Halfword (register) calculates an address from a base register  value and an offset register value, and stores a halfword from a 32-bit  register to the calculated address. For information about memory accesses, see  Load/Store addressing modes. \n\nThe instruction uses an offset addressing mode, that calculates the address  used for the memory access from a base register value and an offset register  value. The offset can be optionally shifted and extended.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wm>": "When ", "<Xm>": "When "}, "encodings": ["STRH  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 160, "asmtemplate": "UADALP  <Vd>.<Ta>, <Vn>.<Tb>", "brief": "Unsigned Add and Accumulate Long Pairwise", "heading": "UADALP", "para": "Unsigned Add and Accumulate Long Pairwise. This instruction adds pairs of  adjacent unsigned integer values from the vector in the source SIMD&FP  register and accumulates the results with the vector elements of the  destination SIMD&FP register. The destination vector elements are twice as  long as the source vector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Ta><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD"}, "encodings": ["UADALP  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 324, "asmtemplate": "ST2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]", "brief": "Store Allocation Tags", "heading": "ST2G", "para": "Store Allocation Tags stores an Allocation Tag to two Tag granules of memory.  The address used for the store is calculated from the base register and an  immediate signed offset scaled by the Tag granule. The Allocation Tag is  calculated from the Logical Address Tag in the source register. \n\nThis instruction generates an Unchecked access. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<Xt|SP>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Xt\" field.", "<simm>": "Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the \"imm9\" field."}, "encodings": ["ST2G  <Xt|SP>, [<Xn|SP>], #<simm>", "ST2G  <Xt|SP>, [<Xn|SP>, #<simm>]!", "ST2G  <Xt|SP>, [<Xn|SP>{, #<simm>}]"]}, {"id": 532, "asmtemplate": "RADDHN{2}<Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", "brief": "Rounding Add returning High Narrow", "heading": "RADDHN, RADDHN2", "para": "Rounding Add returning High Narrow. This instruction adds each vector element  in the first source SIMD&FP register to the corresponding vector element in  the second source SIMD&FP register, places the most significant half of the  result into a vector, and writes the vector to the lower or upper half of the  destination SIMD&FP register. \n\nThe results are rounded. For truncated results, see ADDHN. \n\nThe RADDHN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the RADDHN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vm>": "Is the name of the second SIMD", "<Tb><Vn>": "Is the name of the first SIMD"}, "encodings": ["RADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"]}, {"id": 1022, "asmtemplate": "SQNEG  <Vd>.<T>, <Vn>.<T>", "brief": "Signed saturating Negate", "heading": "SQNEG", "para": "Signed saturating Negate. This instruction reads each vector element from the  source SIMD&FP register, negates each value, places the result into a vector,  and writes the vector to the destination SIMD&FP register. All the values in  this instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SQNEG  <V><d>, <V><n>", "SQNEG  <Vd>.<T>, <Vn>.<T>"]}, {"id": 302, "asmtemplate": "LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register Byte (unprivileged)", "heading": "LDTRB", "para": "Load Register Byte (unprivileged) loads a byte from memory, zero-extends it,  and writes the result to a register. The address that is used for the load is  calculated from a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field."}, "encodings": ["LDTRB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 70, "asmtemplate": "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Compare Equal (vector)", "heading": "FCMEQ (register)", "para": "Floating-point Compare Equal (vector). This instruction compares each  floating-point value from the first source SIMD&FP register, with the  corresponding floating-point value from the second source SIMD&FP register,  and if the comparison is equal sets every bit of the corresponding vector  element in the destination SIMD&FP register to one, otherwise sets every bit  of the corresponding vector element in the destination SIMD&FP register to  zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<n>": "Is the number of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Vd>": "Is the name of the SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<m>": "Is the number of the second SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["FCMEQ  <Hd>, <Hn>, <Hm>", "FCMEQ  <V><d>, <V><n>, <V><m>", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FCMEQ  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 720, "asmtemplate": "LDCLRL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic bit clear on word or doubleword in memory, without return", "heading": "STCLR, STCLRL", "para": "Atomic bit clear on word or doubleword in memory, without return, atomically  loads a 32-bit word or 64-bit doubleword from memory, performs a bitwise AND  with the complement of the value held in a register on it, and stores the  result back to memory.  \n* STCLR does not have release semantics. \n* STCLRL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDCLR, LDCLRA, LDCLRAL, LDCLRL. This means:  \n* The encodings in this description are named to match the encodings of LDCLR, \n  LDCLRA, LDCLRAL, LDCLRL. \n* The description of LDCLR, LDCLRA, LDCLRAL, LDCLRL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STCLR  <Ws>, [<Xn|SP>]"]}, {"id": 745, "asmtemplate": "LDSMAXLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic signed maximum on byte in memory", "heading": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB", "para": "Atomic signed maximum on byte in memory atomically loads an 8-bit byte from  memory, compares it against the value held in a register, and stores the  larger value back to memory, treating the values as signed numbers. The value  initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, LDSMAXAB and LDSMAXALB load from \n  memory with acquire semantics. \n* LDSMAXLB and LDSMAXALB store to memory with release semantics. \n* LDSMAXB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STSMAXB, STSMAXLB.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDSMAXAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 815, "asmtemplate": "ST1D    {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]", "brief": "Scatter store doublewords from a vector (vector index)", "heading": "ST1D (scalar plus vector)", "para": "Scatter store doublewords from a vector (vector index). \n\nScatter store of doublewords from the active elements of a vector register to  the memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 8. Inactive elements are not written to memory. \n\nIt has encodings from 4 classes: 32-bit unpacked scaled offset , 32-bit  unpacked unscaled offset , 64-bit scaled offset and 64-bit unscaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #3]", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #3]", "ST1D    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]"]}, {"id": 1060, "asmtemplate": "SYS #3, C7, C3, #5, <Xt>", "brief": "Data Value Prediction Restriction by Context", "heading": "DVP", "para": "Data Value Prediction Restriction by Context prevents data value predictions,  based on information gathered from earlier execution within an particular  execution context, from allowing later speculative execution within that  context to be observable through side-channels. \n\nFor more information, see DVP RCTX, Data Value Prediction Restriction by  Context. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field."}, "encodings": ["DVP  RCTX, <Xt>"]}, {"id": 4, "asmtemplate": "UMOV  <Xd>, <Vn>.<Ts>[<index>]", "brief": "Unsigned Move vector element to general-purpose register", "heading": "UMOV", "para": "Unsigned Move vector element to general-purpose register. This instruction  reads the unsigned integer from the source SIMD&FP register, zero-extends it  to form a 32-bit or 64-bit value, and writes the result to the destination  general-purpose register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis instruction is used by the alias MOV (to general).", "explanations": {"": "\".", "<Ts><Ts><index><index>": "For the 64-reg,UMOV-64-reg variant: is the element index encoded in \"imm5", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Vn>": "Is the name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["UMOV  <Wd>, <Vn>.<Ts>[<index>]"]}, {"id": 1218, "asmtemplate": "LD3H    {<Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load three-halfword structures to three vectors (scalar index)", "heading": "LD3H (scalar plus scalar)", "para": "Contiguous load three-halfword structures to three vectors (scalar index). \n\nContiguous load three-halfword structures, each to the same element number in  three vector registers from the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by three. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive halfwords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD3H    { <Zt1>.H, <Zt2>.H, <Zt3>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 385, "asmtemplate": "ADRP  <Xd>, <label>", "brief": "Form PC-relative address to 4KB page", "heading": "ADRP", "para": "Form PC-relative address to 4KB page adds an immediate value that is shifted  left by 12 bits, to the PC value to form a PC-relative address, with the  bottom 12 bits masked out, and writes the result to the destination register.", "explanations": {"<label>": "Is the program label whose 4KB page address is to be calculated. Its offset from the page address of this instruction, in the range +/-4GB, is encoded as \"immhi:immlo\" times 4096.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ADRP  <Xd>, <label>"]}, {"id": 491, "asmtemplate": "FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point add vector (predicated)", "heading": "FADD (vectors, predicated)", "para": "Floating-point add vector (predicated). \n\nAdd active floating-point elements of the second source vector to  corresponding floating-point elements of the first source vector and  destructively place the results in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FADD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 388, "asmtemplate": "CPY<Zd>.<T>, <Pg>/M, #0", "brief": "Move floating-point +0.0 to vector elements (predicated)", "heading": "FMOV (zero, predicated)", "para": "Move floating-point +0.0 to vector elements (predicated). \n\nMove floating-point constant +0.0 to to each active element in the destination  vector. Inactive elements in the destination vector register remain  unmodified. \n\nThis is a pseudo-instruction of CPY (immediate, merging). This means:  \n* The encodings in this description are named to match the encodings of CPY \n  (immediate, merging). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of CPY (immediate, merging) gives the operational pseudocode \n  for this instruction.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FMOV    <Zd>.<T>, <Pg>/M, #0.0"]}, {"id": 49, "asmtemplate": "AND<Zdn>.<T>, <Zdn>.<T>, #(-<const> - 1)", "brief": "Bitwise clear bits using immediate (unpredicated)", "heading": "BIC (immediate)", "para": "Bitwise clear bits using immediate (unpredicated). \n\nBitwise clear bits using immediate with each 64-bit element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate is a 64-bit value consisting of a single run  of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This instruction  is unpredicated. \n\nThis is a pseudo-instruction of AND (immediate). This means:  \n* The encodings in this description are named to match the encodings of AND \n  (immediate). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of AND (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<T><const>": "Is a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["BIC     <Zdn>.<T>, <Zdn>.<T>, #<const>"]}, {"id": 344, "asmtemplate": "LSRV<Xd>, <Xn>, <Xm>", "brief": "Logical Shift Right (register)", "heading": "LSR (register)", "para": "Logical Shift Right (register) shifts a register value right by a variable  number of bits, shifting in zeros, and writes the result to the destination  register. The remainder obtained by dividing the second source register by the  data size defines the number of bits by which the first source register is  right-shifted. \n\nThis is an alias of LSRV. This means:  \n* The encodings in this description are named to match the encodings of LSRV. \n* The description of LSRV gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["LSR  <Wd>, <Wn>, <Wm>"]}, {"id": 717, "asmtemplate": "LD1B    {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load unsigned bytes to vector (vector index)", "heading": "LD1B (scalar plus vector)", "para": "Gather load unsigned bytes to vector (vector index). \n\nGather load of unsigned bytes to active elements of a vector register from  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally sign or zero-extended from 32 to 64 bits. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector. \n\nIt has encodings from 3 classes: 32-bit unpacked unscaled offset , 32-bit  unscaled offset and 64-bit unscaled offset", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LD1B    { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LD1B    { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 1104, "asmtemplate": "FACGT<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point absolute compare less than", "heading": "FACLT", "para": "Floating-point absolute compare less than. \n\nCompare active absolute values of floating-point elements in the first source  vector being less than corresponding absolute values of elements in the second  source vector, and place the boolean results of the comparison in the  corresponding elements of the destination predicate. Inactive elements in the  destination predicate register are set to zero. Does not set the condition  flags. \n\nThis is a pseudo-instruction of FAC<cc>. This means:  \n* The encodings in this description are named to match the encodings of \n  FAC<cc>. \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of FAC<cc> gives the operational pseudocode for this \n  instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["FACLT   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 903, "asmtemplate": "PRFB    <prfop>, <Pg>, [<Xn|SP>, <Xm>]", "brief": "Contiguous prefetch bytes (scalar index)", "heading": "PRFB (scalar plus scalar)", "para": "Contiguous prefetch bytes (scalar index). \n\nContiguous prefetch of byte elements from the memory address generated by a  64-bit scalar base and scalar index which is added to the base address. After  each element prefetch the index value is incremented, but the index register  is not updated. \n\nThe predicate may be used to suppress prefetches from unwanted addresses.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<prfop><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["PRFB    <prfop>, <Pg>, [<Xn|SP>, <Xm>]"]}, {"id": 699, "asmtemplate": "LDXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", "brief": "Load Exclusive Pair of Registers", "heading": "LDXP", "para": "Load Exclusive Pair of Registers derives an address from a base register  value, loads two 32-bit words or two 64-bit doublewords from memory, and  writes them to two registers. A 32-bit pair requires the address to be  doubleword aligned and is single-copy atomic at doubleword granularity. A  64-bit pair requires the address to be quadword aligned and is single-copy  atomic for each doubleword at doubleword granularity. The PE marks the  physical address being accessed as an exclusive access. This exclusive access  mark is checked by Store Exclusive instructions. See Synchronization and  semaphores. For information about memory accesses see Load/Store addressing  modes.", "explanations": {"<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"]}, {"id": 185, "asmtemplate": "LDUMINL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic unsigned minimum on word or doubleword in memory", "heading": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL", "para": "Atomic unsigned minimum on word or doubleword in memory atomically loads a  32-bit word or 64-bit doubleword from memory, compares it against the value  held in a register, and stores the smaller value back to memory, treating the  values as unsigned numbers. The value initially loaded from memory is returned  in the destination register.  \n* If the destination register is not one of WZR or XZR, LDUMINA and LDUMINAL \n  load from memory with acquire semantics. \n* LDUMINL and LDUMINAL store to memory with release semantics. \n* LDUMIN has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMIN, STUMINL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDUMIN  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 885, "asmtemplate": "SBFM<Xd>, <Xn>, #0, #7", "brief": "Signed Extend Byte", "heading": "SXTB", "para": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to  the size of the register, and writes the result to the destination register. \n\nThis is an alias of SBFM. This means:  \n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SXTB  <Wd>, <Wn>"]}, {"id": 702, "asmtemplate": "WFET  <Xt>", "brief": "Wait For Event with Timeout", "heading": "WFET", "para": "Wait For Event with Timeout is a hint instruction that indicates that the PE  can enter a low-power state and remain there until either a local timeout  event or a wakeup event occurs. Wakeup events include the event signaled as a  result of executing the SEV instruction on any PE in the multiprocessor  system. For more information, see Wait For Event mechanism and Send event. \n\nAs described in Wait For Event mechanism and Send event, the execution of a  WFET instruction that would otherwise cause entry to a low-power state can be  trapped to a higher Exception level. See:  \n* Traps to EL1 of EL0 execution of WFE and WFI instructions. \n* Traps to EL2 of Non-secure EL0 and EL1 execution of WFE and WFI \n  instructions. \n* Traps to EL3 of EL2, EL1, and EL0 execution of WFE and WFI instructions.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rd\" field."}, "encodings": ["WFET  <Xt>"]}, {"id": 941, "asmtemplate": "TBX  <Vd>.<Ta>, {<Vn>.16B }, <Vm>.<Ta>", "brief": "Table vector lookup extension", "heading": "TBX", "para": "Table vector lookup extension. This instruction reads each value from the  vector elements in the index source SIMD&FP register, uses each result as an  index to perform a lookup in a table of bytes that is described by one to four  source table SIMD&FP registers, places the lookup result in a vector, and  writes the vector to the destination SIMD&FP register. If an index is out of  range for the table, the existing value in the vector element of the  destination register is left unchanged. If more than one source register is  used to describe the table, the first source register describes the lowest  bytes of the table. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Vn+3>": "Is the name of the fourth SIMD", "<Vd>": "Is the name of the SIMD", "<Vn+1>": "Is the name of the second SIMD", "<Vn+2>": "Is the name of the third SIMD", "<Ta><Vn>": "For the four register table, three register table and two register table variant: is the name of the first SIMD", "": "FP index register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the SIMD", "<Vn>": "For the single register table variant: is the name of the SIMD"}, "encodings": ["TBX  <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>"]}, {"id": 81, "asmtemplate": "TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Transpose vectors (secondary)", "heading": "TRN2", "para": "Transpose vectors (secondary). This instruction reads corresponding  odd-numbered vector elements from the two source SIMD&FP registers, places  each result into consecutive elements of a vector, and writes the vector to  the destination SIMD&FP register. Vector elements from the first source  register are placed into even-numbered elements of the destination vector,  starting at zero, while vector elements from the second source register are  placed into odd-numbered elements of the destination vector. \n\nBy using this instruction with TRN1, a 2 x 2 matrix can be transposed. \n\nThe following figure shows an example of the operation of TRN1 and TRN2  halfword operations where Q = 0. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["TRN2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 956, "asmtemplate": "LDXRB  <Wt>, [<Xn|SP>{,#0}]", "brief": "Load Exclusive Register Byte", "heading": "LDXRB", "para": "Load Exclusive Register Byte derives an address from a base register value,  loads a byte from memory, zero-extends it and writes it to a register. The  memory access is atomic. The PE marks the physical address being accessed as  an exclusive access. This exclusive access mark is checked by Store Exclusive  instructions. See Synchronization and semaphores. For information about memory  accesses see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDXRB  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 1117, "asmtemplate": "SQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating decrement vector by multiple of 16-bit predicate constraint element count", "heading": "SQDECH (vector)", "para": "Signed saturating decrement vector by multiple of 16-bit predicate constraint  element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. The  results are saturated to the 16-bit signed integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}"]}, {"id": 711, "asmtemplate": "STNT1B  {<Zt>.B }, <Pg>, [<Xn|SP>, <Xm>]", "brief": "Contiguous store non-temporal bytes from vector (scalar index)", "heading": "STNT1B (scalar plus scalar)", "para": "Contiguous store non-temporal bytes from vector (scalar index). \n\nContiguous store non-temporal of bytes from elements of a vector register to  the memory address generated by a 64-bit scalar base and scalar index which is  added to the base address. After each element access the index value is  incremented, but the index register is not updated. Inactive elements are not  written to memory. \n\nA non-temporal store is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["STNT1B  { <Zt>.B }, <Pg>, [<Xn|SP>, <Xm>]"]}, {"id": 206, "asmtemplate": "MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>", "brief": "Move general-purpose register to System Register", "heading": "MSR (register)", "para": "Move general-purpose register to System Register allows the PE to write an  AArch64 System register from a general-purpose register.", "explanations": {"": "The System register names are defined in ", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<systemreg>": "Is a System register name, encoded in the \"o0:op1:CRn:CRm:op2\".", "<Cn>": "Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field.", "<op0><op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field."}, "encodings": ["MSR  (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>"]}, {"id": 1020, "asmtemplate": "FCPY    <Zd>.<T>, <Pg>/M, #<const>", "brief": "Copy 8-bit floating-point immediate to vector elements (predicated)", "heading": "FCPY", "para": "Copy 8-bit floating-point immediate to vector elements (predicated). \n\nCopy a floating-point immediate into each active element in the destination  vector. Inactive elements in the destination vector register remain  unmodified. \n\nThis instruction is used by the alias FMOV (immediate, predicated).", "explanations": {"": "\u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<const>": "Is a floating-point immediate value expressable as ", "<T><Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field."}, "encodings": ["FCPY    <Zd>.<T>, <Pg>/M, #<const>"]}, {"id": 420, "asmtemplate": "FRECPE  <Zd>.<T>, <Zn>.<T>", "brief": "Floating-point reciprocal estimate (unpredicated)", "heading": "FRECPE", "para": "Floating-point reciprocal estimate (unpredicated). \n\nFind the approximate reciprocal of each floating-point element of the source  vector, and place the results in the corresponding elements of the destination  vector. This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FRECPE  <Zd>.<T>, <Zn>.<T>"]}, {"id": 851, "asmtemplate": "LD4W    {<Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load four-word structures to four vectors (scalar index)", "heading": "LD4W (scalar plus scalar)", "para": "Contiguous load four-word structures to four vectors (scalar index). \n\nContiguous load four-word structures, each to the same element number in four  vector registers from the memory address generated by a 64-bit scalar base and  a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by four. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive words in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4W    { <Zt1>.S, <Zt2>.S, <Zt3>.S, <Zt4>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 1014, "asmtemplate": "ST2B    {<Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>, <Xm>]", "brief": "Contiguous store two-byte structures from two vectors (scalar index)", "heading": "ST2B (scalar plus scalar)", "para": "Contiguous store two-byte structures from two vectors (scalar index). \n\nContiguous store two-byte structures, each from the same element number in two  vector registers to the memory address generated by a 64-bit scalar base and a  64-bit scalar index register and added to the base address. After each  structure access the index value is incremented by two. The index register is  not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive bytes in memory which  make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST2B    { <Zt1>.B, <Zt2>.B }, <Pg>, [<Xn|SP>, <Xm>]"]}, {"id": 672, "asmtemplate": "LDR  <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Load Register (register)", "heading": "LDR (register)", "para": "Load Register (register) calculates an address from a base register value and  an offset register value, loads a word from memory, and writes it to a  register. The offset register value can optionally be shifted and extended.  For information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "When "}, "encodings": ["LDR  <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 1220, "asmtemplate": "CLASTA  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>", "brief": "Conditionally extract element after last to SIMD&FP scalar register", "heading": "CLASTA (SIMD&FP scalar)", "para": "Conditionally extract element after last to SIMD&FP scalar register. \n\nFrom the source vector register extract the element after the last active  element, or if the last active element is the final element extract element  zero, and then zero-extend that element to destructively place in the  destination and first source SIMD & floating-point scalar register. If there  are no active elements then destructively zero-extend the least significant  element-size bits of the destination and first source SIMD & floating-point  scalar register.", "explanations": {"": "FP register, encoded in the \"Vdn\" field.", "<Zm>": "Is the name of the source scalable vector register, encoded in the \"Zm\" field.", "<V><dn>": "Is the number [0-31] of the source and destination SIMD", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["CLASTA  <V><dn>, <Pg>, <V><dn>, <Zm>.<T>"]}, {"id": 887, "asmtemplate": "FCVTAU  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector)", "heading": "FCVTAU (vector)", "para": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to  Away (vector). This instruction converts each element in a vector from a  floating-point value to an unsigned integer value using the Round to Nearest  with Ties to Away rounding mode and writes the result to the SIMD&FP  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTAU  <Hd>, <Hn>", "FCVTAU  <V><d>, <V><n>", "FCVTAU  <Vd>.<T>, <Vn>.<T>", "FCVTAU  <Vd>.<T>, <Vn>.<T>"]}, {"id": 438, "asmtemplate": "SUBR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Reversed subtract vectors (predicated)", "heading": "SUBR (vectors)", "para": "Reversed subtract vectors (predicated). \n\nReversed subtract active elements of the first source vector from  corresponding elements of the second source vector and destructively place the  results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["SUBR    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 372, "asmtemplate": "CSDB", "brief": "Consumption of Speculative Data Barrier", "heading": "CSDB", "para": "Consumption of Speculative Data Barrier is a memory barrier that controls  speculative execution and data value prediction. \n\nNo instruction other than branch instructions appearing in program order after  the CSDB can be speculatively executed using the results of any:  \n* Data value predictions of any instructions. \n* PSTATE.{N,Z,C,V} predictions of any instructions other than conditional \n  branch instructions appearing in program order before the CSDB that have not \n  been architecturally resolved. \n* Predictions of SVE predication state for any SVE instructions.  For purposes of the definition of CSDB, PSTATE.{N,Z,C,V} is not considered a  data value. This definition permits:  \n* Control flow speculation before and after the CSDB. \n* Speculative execution of conditional data processing instructions after the \n  CSDB, unless they use the results of data value or PSTATE.{N,Z,C,V} \n  predictions of instructions appearing in program order before the CSDB that \n  have not been architecturally resolved.", "explanations": {}, "encodings": ["CSDB"]}, {"id": 1207, "asmtemplate": "DECP    <Zdn>.<T>, <Pm>.<T>", "brief": "Decrement vector by count of true predicate elements", "heading": "DECP (vector)", "para": "Decrement vector by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to decrement all destination vector elements. \n\nThe predicate size specifier may be omitted in assembler source code, but this  is deprecated and will be prohibited in a future release of the architecture.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field."}, "encodings": ["DECP    <Zdn>.<T>, <Pm>.<T>"]}, {"id": 1001, "asmtemplate": "SHA256SU0  <Vd>.4S, <Vn>.4S", "brief": "SHA256 schedule update 0", "heading": "SHA256SU0", "para": "SHA256 schedule update 0.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the second SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["SHA256SU0  <Vd>.4S, <Vn>.4S"]}, {"id": 33, "asmtemplate": "LDFF1D  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault doublewords to vector (vector index)", "heading": "LDFF1D (scalar plus vector)", "para": "Gather load first-fault doublewords to vector (vector index). \n\nGather load with first-faulting behavior of doublewords to active elements of  a vector register from memory addresses generated by a 64-bit scalar base plus  vector index. The index values are optionally first sign or zero-extended from  32 to 64 bits and then optionally multiplied by 8. Inactive elements will not  cause a read from Device memory or signal faults, and are set to zero in the  destination vector. \n\nIt has encodings from 4 classes: 32-bit unpacked scaled offset , 32-bit  unpacked unscaled offset , 64-bit scaled offset and 64-bit unscaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #3]", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #3]", "LDFF1D  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 713, "asmtemplate": "PFALSE  <Pd>.B", "brief": "Set all predicate elements to false", "heading": "PFALSE", "para": "Set all predicate elements to false. \n\nSet all elements in the destination predicate to false.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["PFALSE  <Pd>.B"]}, {"id": 1182, "asmtemplate": "EORV    <V><d>, <Pg>, <Zn>.<T>", "brief": "Bitwise exclusive OR reduction to scalar", "heading": "EORV", "para": "Bitwise exclusive OR reduction to scalar. \n\nBitwise exclusive OR horizontally across all lanes of a vector, and place the  result in the SIMD&FP scalar destination register. Inactive elements in the  source vector are treated as zero.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["EORV    <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 105, "asmtemplate": "REV     <Pd>.<T>, <Pn>.<T>", "brief": "Reverse all elements in a predicate", "heading": "REV (predicate)", "para": "Reverse all elements in a predicate. \n\nReverse the order of all elements in the source predicate and place in the  destination predicate. This instruction is unpredicated.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<T><Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["REV     <Pd>.<T>, <Pn>.<T>"]}, {"id": 460, "asmtemplate": "LD3W    {<Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load three-word structures to three vectors (scalar index)", "heading": "LD3W (scalar plus scalar)", "para": "Contiguous load three-word structures to three vectors (scalar index). \n\nContiguous load three-word structures, each to the same element number in  three vector registers from the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by three. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive words in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD3W    { <Zt1>.S, <Zt2>.S, <Zt3>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 48, "asmtemplate": "STLLR  <Xt>, [<Xn|SP>{,#0}]", "brief": "Store LORelease Register", "heading": "STLLR", "para": "Store LORelease Register stores a 32-bit word or a 64-bit doubleword to a  memory location, from a register. The instruction also has memory ordering  semantics as described in Load LOAcquire, Store LORelease. For information  about memory accesses, see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STLLR  <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 772, "asmtemplate": "SYS #<op1>, C7, <Cm>, #<op2>, <Xt>", "brief": "Address Translate", "heading": "AT", "para": "Address Translate. For more information, see op0==0b01, cache maintenance, TLB  maintenance, and address translation instructions. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xt>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rt\" field.", "<at_op><op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field."}, "encodings": ["AT  <at_op>, <Xt>"]}, {"id": 351, "asmtemplate": "LD1ROD  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load and replicate four doublewords (scalar index)", "heading": "LD1ROD (scalar plus scalar)", "para": "Contiguous load and replicate four doublewords (scalar index). \n\nLoad four contiguous doublewords to elements of a 256-bit (octaword) vector  from the memory address generated by a 64-bit scalar base address and scalar  index which is multiplied by 8 and added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first four predicate elements are used and higher numbered predicate  elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1ROD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 364, "asmtemplate": "MOVI  <Vd>.2D, #<imm>", "brief": "Move Immediate (vector)", "heading": "MOVI", "para": "Move Immediate (vector). This instruction places an immediate constant into  every vector element of the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<imm>": "Is a 64-bit immediate 'aaaaaaaabbbbbbbbccccccccddddddddeeeeeeeeffffffffgggggggghhhhhhhh', encoded in \"a:b:c:d:e:f:g:h\".", "<T><T><T><imm8>": "Is an 8-bit immediate encoded in \"a:b:c:d:e:f:g:h\".", "<Dd>": "Is the 64-bit name of the SIMD", "": "FP destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD"}, "encodings": ["MOVI  <Vd>.<T>, #<imm8>{, LSL #0}"]}, {"id": 121, "asmtemplate": "SUBS<Xd>, XZR, <Xm>{, <shift> #<amount>}", "brief": "Negate, setting flags", "heading": "NEGS", "para": "Negate, setting flags, negates an optionally-shifted register value, and  writes the result to the destination register. It updates the condition flags  based on the result. \n\nThis is an alias of SUBS (shifted register). This means:  \n* The encodings in this description are named to match the encodings of SUBS \n  (shifted register). \n* The description of SUBS (shifted register) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xm>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["NEGS  <Wd>, <Wm>{, <shift> #<amount>}"]}, {"id": 911, "asmtemplate": "SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", "brief": "SM3TT1A", "heading": "SM3TT1A", "para": "SM3TT1A takes three 128-bit vectors from three source SIMD&FP registers and a  2-bit immediate index value, and returns a 128-bit result in the destination  SIMD&FP register. It performs a three-way exclusive OR of the three 32-bit  fields held in the upper three elements of the first source vector, and adds  the resulting 32-bit value and the following three other 32-bit values:  \n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the three-way exclusive OR. \n* The result of the exclusive OR of the top 32-bit element of the second \n  source vector, Vn, with a rotation left by 12 of the top 32-bit element of \n  the first source vector. \n* A 32-bit element indexed out of the third source vector, Vm.  The result of this addition is returned as the top element of the result. The  other elements of the result are taken from elements of the first source  vector, with the element returned in bits<63:32> being rotated left by 9. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": ", encoded in \"imm2\".", "<Vd>": "Is the name of the SIMD", "<imm2>": "Is a 32-bit element indexed out of ", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SM3TT1A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"]}, {"id": 813, "asmtemplate": "LDUMINLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic unsigned minimum on halfword in memory, without return", "heading": "STUMINH, STUMINLH", "para": "Atomic unsigned minimum on halfword in memory, without return, atomically  loads a 16-bit halfword from memory, compares it against the value held in a  register, and stores the smaller value back to memory, treating the values as  unsigned numbers.  \n* STUMINH does not have release semantics. \n* STUMINLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH. \n* The description of LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STUMINH  <Ws>, [<Xn|SP>]"]}, {"id": 762, "asmtemplate": "SBFM<Xd>, <Xn>, #0, #31", "brief": "Sign Extend Word", "heading": "SXTW", "para": "Sign Extend Word sign-extends a word to the size of the register, and writes  the result to the destination register. \n\nThis is an alias of SBFM. This means:  \n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field."}, "encodings": ["SXTW  <Xd>, <Wn>"]}, {"id": 1251, "asmtemplate": "LD2D    {<Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load two-doubleword structures to two vectors (scalar index)", "heading": "LD2D (scalar plus scalar)", "para": "Contiguous load two-doubleword structures to two vectors (scalar index). \n\nContiguous load two-doubleword structures, each to the same element number in  two vector registers from the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by two. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive doublewords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD2D    { <Zt1>.D, <Zt2>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 221, "asmtemplate": "SQDMLAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed saturating Doubling Multiply-Add Long", "heading": "SQDMLAL, SQDMLAL2 (vector)", "para": "Signed saturating Doubling Multiply-Add Long. This instruction multiplies  corresponding signed integer values in the lower or upper half of the vectors  of the two source SIMD&FP registers, doubles the results, and accumulates the  final results with the vector elements of the destination SIMD&FP register.  The destination vector elements are twice as long as the elements that are  multiplied. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQDMLAL instruction extracts each source vector from the lower half of  each source register, while the SQDMLAL2 instruction extracts each source  vector from the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<m>": "Is the number of the second SIMD", "2<Vd>": "Is the name of the SIMD", "<Va><d>": "Is the number of the SIMD", "<Vb><n>": "Is the number of the first SIMD"}, "encodings": ["SQDMLAL  <Va><d>, <Vb><n>, <Vb><m>", "SQDMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 982, "asmtemplate": "FMOV  <Dd>, <Dn>", "brief": "Floating-point Move register without conversion", "heading": "FMOV (register)", "para": "Floating-point Move register without conversion. This instruction copies the  floating-point value in the SIMD&FP source register to the SIMD&FP destination  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Dn>": "Is the 64-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FMOV  <Hd>, <Hn>"]}, {"id": 800, "asmtemplate": "FDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point divide by vector (predicated)", "heading": "FDIV", "para": "Floating-point divide by vector (predicated). \n\nDivide active floating-point elements of the first source vector by  corresponding floating-point elements of the second source vector and  destructively place the quotient in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FDIV    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 5, "asmtemplate": "FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point minimum with immediate (predicated)", "heading": "FMIN (immediate)", "para": "Floating-point minimum with immediate (predicated). \n\nDetermine the minimum of an immediate and each active floating-point element  of the source vector, and destructively place the results in the corresponding  elements of the source vector. The immediate may take the value +0.0 or +1.0  only. If the element value is NaN then the result is NaN. Inactive elements in  the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FMIN    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 286, "asmtemplate": "SQSHRN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Signed saturating Shift Right Narrow (immediate)", "heading": "SQSHRN, SQSHRN2", "para": "Signed saturating Shift Right Narrow (immediate). This instruction reads each  vector element in the source SIMD&FP register, right shifts and truncates each  result by an immediate value, saturates each shifted result to a value that is  half the original width, puts the final result into a vector, and writes the  vector to the lower or upper half of the destination SIMD&FP register. All the  values in this instruction are signed integer values. The destination vector  elements are half as long as the source vector elements. For rounded results,  see SQRSHRN. \n\nThe SQSHRN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SQSHRN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Va><n>": "Is the number of the first SIMD", "2<Vd>": "Is the name of the SIMD", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["SQSHRN  <Vb><d>, <Va><n>, #<shift>", "SQSHRN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 26, "asmtemplate": "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Floating-point convert to signed integer, rounding toward zero (predicated)", "heading": "FCVTZS", "para": "Floating-point convert to signed integer, rounding toward zero (predicated). \n\nConvert to the signed integer nearer to zero from each active floating-point  element of the source vector, and place the results in the corresponding  elements of the destination vector. Inactive elements in the destination  vector register remain unmodified. \n\nIf the input and result types have a different size the smaller type is held  unpacked in the least significant bits of elements of the larger size. When  the input is the smaller type the upper bits of each source element are  ignored. When the result is the smaller type the results are sign-extended to  fill each destination element. \n\nIt has encodings from 7 classes: Half-precision to 16-bit , Half-precision to  32-bit , Half-precision to 64-bit , Single-precision to 32-bit ,  Single-precision to 64-bit , Double-precision to 32-bit and Double-precision  to 64-bit", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FCVTZS  <Zd>.H, <Pg>/M, <Zn>.H", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.H", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.H", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.S", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.S", "FCVTZS  <Zd>.S, <Pg>/M, <Zn>.D", "FCVTZS  <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 407, "asmtemplate": "AND     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Bitwise AND vectors (predicated)", "heading": "AND (vectors, predicated)", "para": "Bitwise AND vectors (predicated). \n\nBitwise AND active elements of the second source vector with corresponding  elements of the first source vector and destructively place the results in the  corresponding elements of the first source vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["AND     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 252, "asmtemplate": "CBNZ  <Xt>, <label>", "brief": "Compare and Branch on Nonzero", "heading": "CBNZ", "para": "Compare and Branch on Nonzero compares the value in a register with zero, and  conditionally branches to a label at a PC-relative offset if the comparison is  not equal. It provides a hint that this is not a subroutine call or return.  This instruction does not affect the condition flags.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field.", "<label>": "Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4.", "<Xt>": "Is the 64-bit name of the general-purpose register to be tested, encoded in the \"Rt\" field."}, "encodings": ["CBNZ  <Wt>, <label>"]}, {"id": 475, "asmtemplate": "RBIT  <Vd>.<T>, <Vn>.<T>", "brief": "Reverse Bit order (vector)", "heading": "RBIT (vector)", "para": "Reverse Bit order (vector). This instruction reads each vector element from  the source SIMD&FP register, reverses the bits of the element, places the  results into a vector, and writes the vector to the destination SIMD&FP  register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["RBIT  <Vd>.<T>, <Vn>.<T>"]}, {"id": 829, "asmtemplate": "FMOV  <Dd>, #<imm>", "brief": "Floating-point move immediate (scalar)", "heading": "FMOV (scalar, immediate)", "para": "Floating-point move immediate (scalar). This instruction copies a  floating-point immediate constant into the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Sd>": "Is the 32-bit name of the SIMD", "": "FP destination register, encoded in the \"Rd\" field.", "<Hd>": "Is the 16-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<imm>": "Is a signed floating-point constant with 3-bit exponent and normalized 4 bits of precision, encoded in the \"imm8\" field. For details of the range of constants available and the encoding of "}, "encodings": ["FMOV  <Hd>, #<imm>"]}, {"id": 840, "asmtemplate": "FRINTA  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral, to nearest with ties to Away (vector)", "heading": "FRINTA (vector)", "para": "Floating-point Round to Integral, to nearest with ties to Away (vector). This  instruction rounds a vector of floating-point values in the SIMD&FP source  register to integral floating-point values of the same size using the Round to  Nearest with Ties to Away rounding mode, and writes the result to the SIMD&FP  destination register. \n\nA zero input gives a zero result with the same sign, an infinite input gives  an infinite result with the same sign, and a NaN is propagated as for normal  arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<T><T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["FRINTA  <Vd>.<T>, <Vn>.<T>", "FRINTA  <Vd>.<T>, <Vn>.<T>"]}, {"id": 358, "asmtemplate": "LDUMINL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic unsigned minimum on word or doubleword in memory, without return", "heading": "STUMIN, STUMINL", "para": "Atomic unsigned minimum on word or doubleword in memory, without return,  atomically loads a 32-bit word or 64-bit doubleword from memory, compares it  against the value held in a register, and stores the smaller value back to  memory, treating the values as unsigned numbers.  \n* STUMIN does not have release semantics. \n* STUMINL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMIN, LDUMINA, LDUMINAL, LDUMINL. This means:  \n* The encodings in this description are named to match the encodings of \n  LDUMIN, LDUMINA, LDUMINAL, LDUMINL. \n* The description of LDUMIN, LDUMINA, LDUMINAL, LDUMINL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STUMIN  <Ws>, [<Xn|SP>]"]}, {"id": 241, "asmtemplate": "HLT  #<imm>", "brief": "Halt instruction", "heading": "HLT", "para": "Halt instruction. An HLT instruction can generate a Halt Instruction debug  event, which causes entry into Debug state.", "explanations": {"<imm>": "Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."}, "encodings": ["HLT  #<imm>"]}, {"id": 559, "asmtemplate": "LDFF1SH {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]", "brief": "Contiguous load first-fault signed halfwords to vector (scalar index)", "heading": "LDFF1SH (scalar plus scalar)", "para": "Contiguous load first-fault signed halfwords to vector (scalar index). \n\nContiguous load with first-faulting behavior of signed halfwords to elements  of a vector register from the memory address generated by a 64-bit scalar base  and scalar index which is multiplied by 2 and added to the base address. After  each element access the index value is incremented, but the index register is  not updated. Inactive elements will not not cause a read from Device memory or  signal a fault, and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1SH { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]", "LDFF1SH { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #1}]"]}, {"id": 932, "asmtemplate": "CASL  <Xs>, <Xt>, [<Xn|SP>{,#0}]", "brief": "Compare and Swap word or doubleword in memory", "heading": "CAS, CASA, CASAL, CASL", "para": "Compare and Swap word or doubleword in memory reads a 32-bit word or 64-bit  doubleword from memory, and compares it against the value held in a first  register. If the comparison is equal, the value in a second register is  written to memory. If the write is performed, the read and write occur  atomically such that no other modification of the memory location can take  place between the read and write.  \n* CASA and CASAL load from memory with acquire semantics. \n* CASL and CASAL store to memory with release semantics. \n* CAS has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThe architecture permits that the data read clears any exclusive monitors  associated with that location, even if the compare subsequently fails. \n\nIf the instruction generates a synchronous Data Abort, the register which is  compared and loaded, that is <Ws>, or <Xs>, is restored to the value held in  the register before the instruction was executed.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register to be compared and loaded, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be conditionally stored, encoded in the \"Rt\" field."}, "encodings": ["CAS  <Ws>, <Wt>, [<Xn|SP>{,#0}]"]}, {"id": 405, "asmtemplate": "STLUR  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Store-Release Register (unscaled)", "heading": "STLUR", "para": "Store-Release Register (unscaled) calculates an address from a base register  value and an immediate offset, and stores a 32-bit word or a 64-bit doubleword  to the calculated address, from a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STLUR  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 429, "asmtemplate": "LD1B    {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load unsigned bytes to vector (immediate index)", "heading": "LD1B (vector plus immediate)", "para": "Gather load unsigned bytes to vector (immediate index). \n\nGather load of unsigned bytes to active elements of a vector register from  memory addresses generated by a vector base plus immediate index. The index is  in the range 0 to 31. Inactive elements will not cause a read from Device  memory or signal faults, and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, in the range 0 to 31, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LD1B    { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LD1B    { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 901, "asmtemplate": "CSINC  <Xd>, <Xn>, <Xm>, <cond>", "brief": "Conditional Select Increment", "heading": "CSINC", "para": "Conditional Select Increment returns, in the destination register, the value  of the first source register if the condition is TRUE, and otherwise returns  the value of the second source register incremented by 1. \n\nThis instruction is used by the aliases CINC, and CSET.", "explanations": {"<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CSINC  <Wd>, <Wn>, <Wm>, <cond>"]}, {"id": 384, "asmtemplate": "ORR<Zd>.D, <Zn>.D, <Zn>.D", "brief": "Move vector register (unpredicated)", "heading": "MOV (vector, unpredicated)", "para": "Move vector register (unpredicated). \n\nMove vector register. This instruction is unpredicated. \n\nThis is an alias of ORR (vectors, unpredicated). This means:  \n* The encodings in this description are named to match the encodings of ORR \n  (vectors, unpredicated). \n* The description of ORR (vectors, unpredicated) gives the operational \n  pseudocode for this instruction.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["MOV     <Zd>.D, <Zn>.D"]}, {"id": 166, "asmtemplate": "MOVN<Xd>, #<imm16>, LSL #<shift>", "brief": "Move (inverted wide immediate)", "heading": "MOV (inverted wide immediate)", "para": "Move (inverted wide immediate) moves an inverted 16-bit immediate value to a  register. \n\nThis is an alias of MOVN. This means:  \n* The encodings in this description are named to match the encodings of MOVN. \n* The description of MOVN gives the operational pseudocode for this \n  instruction.", "explanations": {"": "/16.", "<imm>": "For the 64-bit variant: is a 64-bit immediate, the bitwise inverse of which can be encoded in \"imm16:hw\".", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MOV  <Wd>, #<imm>"]}, {"id": 339, "asmtemplate": "LDNF1B  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-fault unsigned bytes to vector (immediate index)", "heading": "LDNF1B", "para": "Contiguous load non-fault unsigned bytes to vector (immediate index). \n\nContiguous load with non-faulting behavior of unsigned bytes to elements of a  vector register from the memory address generated by a 64-bit scalar base and  immediate index in the range -8 to 7 which is multiplied by the vector's  in-memory size, irrespective of predication, and added to the base address.  Inactive elements will not not cause a read from Device memory or signal a  fault, and are set to zero in the destination vector. \n\nIt has encodings from 4 classes: 8-bit element , 16-bit element , 32-bit  element and 64-bit element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LDNF1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1B  { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1B  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LDNF1B  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 354, "asmtemplate": "LD1RQH  {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load and replicate eight halfwords (scalar index)", "heading": "LD1RQH (scalar plus scalar)", "para": "Contiguous load and replicate eight halfwords (scalar index). \n\nLoad eight contiguous halfwords to elements of a short, 128-bit (quadword)  vector from the memory address generated by a 64-bit scalar base address and  scalar index which is multiplied by 2 and added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first eight predicate elements are used and  higher numbered predicate elements are ignored.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1RQH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 357, "asmtemplate": "SYS #<op1>, C8, <Cm>, #<op2>{, <Xt>}", "brief": "TLB Invalidate operation", "heading": "TLBI", "para": "TLB Invalidate operation. For more information, see op0==0b01, cache  maintenance, TLB maintenance, and address translation instructions. \n\nThis is an alias of SYS. This means:  \n* The encodings in this description are named to match the encodings of SYS. \n* The description of SYS gives the operational pseudocode for this \n  instruction.", "explanations": {"<op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<tlbi_op><Xt>": "Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field.", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field."}, "encodings": ["TLBI  <tlbi_op>{, <Xt>}"]}, {"id": 1128, "asmtemplate": "AUTDZB  <Xd>", "brief": "Authenticate Data address, using key B", "heading": "AUTDB, AUTDZB", "para": "Authenticate Data address, using key B. This instruction authenticates a data  address, using a modifier and key B. \n\nThe address is in the general-purpose register that is specified by <Xd>. \n\nThe modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for AUTDB. \n* The value zero, for AUTDZB.  If the authentication passes, the upper bits of the address are restored to  enable subsequent use of the address. If the authentication fails, the upper  bits are corrupted and any subsequent use of the address results in a  Translation fault.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["AUTDB  <Xd>, <Xn|SP>"]}, {"id": 200, "asmtemplate": "LASTA   <R><d>, <Pg>, <Zn>.<T>", "brief": "Extract element after last to general-purpose register", "heading": "LASTA (scalar)", "para": "Extract element after last to general-purpose register. \n\nIf there is an active element then extract the element after the last active  element modulo the number of elements from the final source vector register.  If there are no active elements, extract element zero. Then zero-extend and  place the extracted element in the destination general-purpose register.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<R><d>": "Is the number [0-30] of the destination general-purpose register or the name ZR (31), encoded in the \"Rd\" field."}, "encodings": ["LASTA   <R><d>, <Pg>, <Zn>.<T>"]}, {"id": 300, "asmtemplate": "FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>", "brief": "Floating-point multiply by immediate (predicated)", "heading": "FMUL (immediate)", "para": "Floating-point multiply by immediate (predicated). \n\nMultiply by an immediate each active floating-point element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. The immediate may take the value +0.5 or +2.0 only.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["FMUL    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <const>"]}, {"id": 554, "asmtemplate": "LD1D    {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load doublewords to vector (immediate index)", "heading": "LD1D (scalar plus immediate)", "para": "Contiguous load doublewords to vector (immediate index). \n\nContiguous load of doublewords to elements of a vector register from the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements will not not  cause a read from Device memory or signal a fault, and are set to zero in the  destination vector.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD1D    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 960, "asmtemplate": "UZP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>", "brief": "Concatenate even or odd elements from two predicates", "heading": "UZP1, UZP2 (predicates)", "para": "Concatenate even or odd elements from two predicates. \n\nConcatenate adjacent even or odd-numbered elements from the first and second  source predicates and place in elements of the destination predicate. This  instruction is unpredicated. \n\nIt has encodings from 2 classes: Even and Odd", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<T><Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["UZP1    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>", "UZP2    <Pd>.<T>, <Pn>.<T>, <Pm>.<T>"]}, {"id": 1031, "asmtemplate": "LDSMAXLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic signed maximum on byte in memory, without return", "heading": "STSMAXB, STSMAXLB", "para": "Atomic signed maximum on byte in memory, without return, atomically loads an  8-bit byte from memory, compares it against the value held in a register, and  stores the larger value back to memory, treating the values as signed numbers.  \n* STSMAXB does not have release semantics. \n* STSMAXLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB. \n* The description of LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSMAXB  <Ws>, [<Xn|SP>]"]}, {"id": 480, "asmtemplate": "ST3  {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>}, [<Xn|SP>], <Xm>", "brief": "Store multiple 3-element structures from three registers", "heading": "ST3 (multiple structures)", "para": "Store multiple 3-element structures from three registers. This instruction  stores multiple 3-element structures to memory from three SIMD&FP registers,  with interleaving. Every element of each register is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 2 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<T><Vt2>": "Is the name of the second SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Vt3>": "Is the name of the third SIMD"}, "encodings": ["ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]", "ST3  { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 951, "asmtemplate": "LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Logical shift left by vector (predicated)", "heading": "LSL (vectors)", "para": "Logical shift left by vector (predicated). \n\nShift left active elements of the first source vector by corresponding  elements of the second source vector and destructively place the results in  the corresponding elements of the first source vector. The shift amount  operand is a vector of unsigned elements in which all bits are significant,  and not used modulo the element size. Inactive elements in the destination  vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 1256, "asmtemplate": "DUP  <Vd>.<T>, <R><n>", "brief": "Duplicate general-purpose register to vector", "heading": "DUP (general)", "para": "Duplicate general-purpose register to vector. This instruction duplicates the  contents of the source general-purpose register into a scalar or each element  in a vector, and writes the result to the SIMD&FP destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD", "<T><R><n>": "Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field."}, "encodings": ["DUP  <Vd>.<T>, <R><n>"]}, {"id": 624, "asmtemplate": "FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point minimum number (predicated)", "heading": "FMINNM (vectors)", "para": "Floating-point minimum number (predicated). \n\nDetermine the minimum number value of active floating-point elements of the  second source vector and corresponding floating-point elements of the first  source vector and destructively place the results in the corresponding  elements of the first source vector. If one element value is NaN then the  result is the numeric value. Inactive elements in the destination vector  register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMINNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 945, "asmtemplate": "FRINT32X  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to 32-bit Integer, using current rounding mode (vector)", "heading": "FRINT32X (vector)", "para": "Floating-point Round to 32-bit Integer, using current rounding mode (vector).  This instruction rounds a vector of floating-point values in the SIMD&FP  source register to integral floating-point values that fit into a 32-bit  integer size using the rounding mode that is determined by the FPCR, and  writes the result to the SIMD&FP destination register. \n\nA zero input returns a zero result with the same sign. When one of the result  values is not numerically equal to the corresponding input value, an Inexact  exception is raised. When an input is infinite, NaN or out-of-range, the  instruction returns for the corresponding result value the most negative  integer representable in the destination size, and an Invalid Operation  floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<T><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FRINT32X  <Vd>.<T>, <Vn>.<T>"]}, {"id": 775, "asmtemplate": "SBFM<Xd>, <Xn>, #<lsb>, #(<lsb>+<width>-1)", "brief": "Signed Bitfield Extract", "heading": "SBFX", "para": "Signed Bitfield Extract copies a bitfield of <width> bits starting from bit  position <lsb> in the source register to the least significant bits of the  destination register, and sets destination bits above the bitfield to a copy  of the most significant bit of the bitfield. \n\nThis is an alias of SBFM. This means:  \n* The encodings in this description are named to match the encodings of SBFM. \n* The description of SBFM gives the operational pseudocode for this \n  instruction.", "explanations": {"": ".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<lsb>": "For the 64-bit variant: is the bit number of the lsb of the source bitfield, in the range 0 to 63.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<width>": "For the 64-bit variant: is the width of the bitfield, in the range 1 to 64-"}, "encodings": ["SBFX  <Wd>, <Wn>, #<lsb>, #<width>"]}, {"id": 1108, "asmtemplate": "STTR  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Store Register (unprivileged)", "heading": "STTR", "para": "Store Register (unprivileged) stores a word or doubleword from a register to  memory. The address that is used for the store is calculated from a base  register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STTR  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 822, "asmtemplate": "BRKBS   <Pd>.B, <Pg>/Z, <Pn>.B", "brief": "Break before first true condition", "heading": "BRKB, BRKBS", "para": "Break before first true condition. \n\nSets destination predicate elements up to but not including the first active  and true source element to true, then sets subsequent elements to false.  Inactive elements in the destination predicate register remain unmodified or  are set to zero, depending on whether merging or zeroing predication is  selected. Optionally sets the First (N), None (Z), !Last (C) condition flags  based on the predicate result, and the V flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<ZM><Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field."}, "encodings": ["BRKB    <Pd>.B, <Pg>/<ZM>, <Pn>.B", "BRKBS   <Pd>.B, <Pg>/Z, <Pn>.B"]}, {"id": 375, "asmtemplate": "FMINNMP  <V><d>, <Vn>.<T>", "brief": "Floating-point Minimum Number of Pair of elements (scalar)", "heading": "FMINNMP (scalar)", "para": "Floating-point Minimum Number of Pair of elements (scalar). This instruction  compares two vector elements in the source SIMD&FP register and writes the  smallest of the floating-point values as a scalar to the destination SIMD&FP  register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><V><d>": "Is the number of the SIMD"}, "encodings": ["FMINNMP  <V><d>, <Vn>.<T>", "FMINNMP  <V><d>, <Vn>.<T>"]}, {"id": 1175, "asmtemplate": "FMAX  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Maximum (scalar)", "heading": "FMAX (scalar)", "para": "Floating-point Maximum (scalar). This instruction compares the two source  SIMD&FP registers, and writes the larger of the two floating-point values to  the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FMAX  <Hd>, <Hn>, <Hm>"]}, {"id": 152, "asmtemplate": "RSUBHN{2}<Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", "brief": "Rounding Subtract returning High Narrow", "heading": "RSUBHN, RSUBHN2", "para": "Rounding Subtract returning High Narrow. This instruction subtracts each  vector element of the second source SIMD&FP register from the corresponding  vector element of the first source SIMD&FP register, places the most  significant half of the result into a vector, and writes the vector to the  lower or upper half of the destination SIMD&FP register. \n\nThe results are rounded. For truncated results, see SUBHN. \n\nThe RSUBHN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the RSUBHN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "2<Vd>": "Is the name of the SIMD", "<Ta><Vm>": "Is the name of the second SIMD", "<Tb><Vn>": "Is the name of the first SIMD"}, "encodings": ["RSUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"]}, {"id": 503, "asmtemplate": "ST1D    {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Scatter store doublewords from a vector (immediate index)", "heading": "ST1D (vector plus immediate)", "para": "Scatter store doublewords from a vector (immediate index). \n\nScatter store of doublewords from the active elements of a vector register to  the memory addresses generated by a vector base plus immediate index. The  index is a multiple of 8 in the range 0 to 248. Inactive elements are not  written to memory.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST1D    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 483, "asmtemplate": "FCVTMS  <Xd>, <Dn>", "brief": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar)", "heading": "FCVTMS (scalar)", "para": "Floating-point Convert to Signed integer, rounding toward Minus infinity \n(scalar). This instruction converts the floating-point value in the SIMD&FP  source register to a 32-bit or 64-bit signed integer using the Round towards  Minus Infinity rounding mode, and writes the result to the general-purpose  destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Sn>": "Is the 32-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTMS  <Wd>, <Hn>"]}, {"id": 145, "asmtemplate": "REV     <Zd>.<T>, <Zn>.<T>", "brief": "Reverse all elements in a vector (unpredicated)", "heading": "REV (vector)", "para": "Reverse all elements in a vector (unpredicated). \n\nReverse the order of all elements in the source vector and place in the  destination vector. This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["REV     <Zd>.<T>, <Zn>.<T>"]}, {"id": 256, "asmtemplate": "SABDL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Absolute Difference Long", "heading": "SABDL, SABDL2", "para": "Signed Absolute Difference Long. This instruction subtracts the vector  elements of the second source SIMD&FP register from the corresponding vector  elements of the first source SIMD&FP register, places the absolute value of  the results into a vector, and writes the vector to the lower or upper half of  the destination SIMD&FP register. The destination vector elements are twice as  long as the source vector elements. \n\nThe SABDL instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SABDL2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SABDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 437, "asmtemplate": "FMAXP  <V><d>, <Vn>.<T>", "brief": "Floating-point Maximum of Pair of elements (scalar)", "heading": "FMAXP (scalar)", "para": "Floating-point Maximum of Pair of elements (scalar). This instruction compares  two vector elements in the source SIMD&FP register and writes the largest of  the floating-point values as a scalar to the destination SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><V><d>": "Is the number of the SIMD"}, "encodings": ["FMAXP  <V><d>, <Vn>.<T>", "FMAXP  <V><d>, <Vn>.<T>"]}, {"id": 1058, "asmtemplate": "FMOV  <Xd>, <Vn>.D[1]", "brief": "Floating-point Move to or from general-purpose register without conversion", "heading": "FMOV (general)", "para": "Floating-point Move to or from general-purpose register without conversion.  This instruction transfers the contents of a SIMD&FP register to a  general-purpose register, or the contents of a general-purpose register to a  SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Vd>": "Is the name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Hd>": "Is the 16-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Vn>": "Is the name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FMOV  <Wd>, <Hn>"]}, {"id": 440, "asmtemplate": "SADDLP  <Vd>.<Ta>, <Vn>.<Tb>", "brief": "Signed Add Long Pairwise", "heading": "SADDLP", "para": "Signed Add Long Pairwise. This instruction adds pairs of adjacent signed  integer values from the vector in the source SIMD&FP register, places the  result into a vector, and writes the vector to the destination SIMD&FP  register. The destination vector elements are twice as long as the source  vector elements. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the SIMD", "<Vd>": "Is the name of the SIMD"}, "encodings": ["SADDLP  <Vd>.<Ta>, <Vn>.<Tb>"]}, {"id": 423, "asmtemplate": "STRB  <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]", "brief": "Store Register Byte (register)", "heading": "STRB (register)", "para": "Store Register Byte (register) calculates an address from a base register  value and an offset register value, and stores a byte from a 32-bit register  to the calculated address. For information about memory accesses, see  Load/Store addressing modes. \n\nThe instruction uses an offset addressing mode, that calculates the address  used for the memory access from a base register value and an offset register  value. The offset can be optionally shifted and extended.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<extend><amount>": "Is the index shift amount, it must be ", "<Xm>": "When "}, "encodings": ["STRB  <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"]}, {"id": 921, "asmtemplate": "UQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment scalar by multiple of 32-bit predicate constraint element count", "heading": "UQINCW (scalar)", "para": "Unsigned saturating increment scalar by multiple of 32-bit predicate  constraint element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCW  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 314, "asmtemplate": "ST1B    {<Zt>.<T>}, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous store bytes from vector (immediate index)", "heading": "ST1B (scalar plus immediate)", "para": "Contiguous store bytes from vector (immediate index). \n\nContiguous store of bytes from elements of a vector register to the memory  address generated by a 64-bit scalar base and immediate index in the range -8  to 7 which is multiplied by the vector's in-memory size, irrespective of  predication, and added to the base address. Inactive elements are not written  to memory.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST1B    { <Zt>.<T> }, <Pg>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 618, "asmtemplate": "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Floating-point fused Multiply-Add to accumulator (by element)", "heading": "FMLA (by element)", "para": "Floating-point fused Multiply-Add to accumulator (by element). This  instruction multiplies the vector elements in the first source SIMD&FP  register by the specified value in the second source SIMD&FP register, and  accumulates the results in the vector elements of the destination SIMD&FP  register. All the values in this instruction are floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar, half-precision , Scalar,  single-precision and double-precision , Vector, half-precision and Vector,  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"M:Rm\" fields.", "<Vd>": "Is the name of the SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<n>": "Is the number of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<V><d>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "<Vm>": "For the single-precision and double-precision variant: is the name of the second SIMD", "<Ts><index>": "For the half-precision variant: is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields."}, "encodings": ["FMLA  <Hd>, <Hn>, <Vm>.H[<index>]", "FMLA  <V><d>, <V><n>, <Vm>.<Ts>[<index>]", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]", "FMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 557, "asmtemplate": "INCW    <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Increment scalar by multiple of predicate constraint element count", "heading": "INCB, INCD, INCH, INCW (scalar)", "para": "Increment scalar by multiple of predicate constraint element count. \n\nDetermines the number of active elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 4 classes: Byte , Doubleword , Halfword and Word", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["INCB    <Xdn>{, <pattern>{, MUL #<imm>}}", "INCD    <Xdn>{, <pattern>{, MUL #<imm>}}", "INCH    <Xdn>{, <pattern>{, MUL #<imm>}}", "INCW    <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 659, "asmtemplate": "ADDS XZR, <Xn|SP>, #<imm>{, <shift>}", "brief": "Compare Negative (immediate)", "heading": "CMN (immediate)", "para": "Compare Negative (immediate) adds a register value and an optionally-shifted  immediate value. It updates the condition flags based on the result, and  discards the result. \n\nThis is an alias of ADDS (immediate). This means:  \n* The encodings in this description are named to match the encodings of ADDS \n  (immediate). \n* The description of ADDS (immediate) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<imm>": "Is an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field."}, "encodings": ["CMN  <Wn|WSP>, #<imm>{, <shift>}"]}, {"id": 537, "asmtemplate": "SQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Signed saturating add vectors (unpredicated)", "heading": "SQADD (vectors)", "para": "Signed saturating add vectors (unpredicated). \n\nSigned saturating add all elements of the second source vector to  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. Each result element is  saturated to the N-bit element's signed integer range -2(N-1) to (2(N-1) )-1.  This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["SQADD   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 848, "asmtemplate": "ORR<Zdn>.<T>, <Zdn>.<T>, #(-<const> - 1)", "brief": "Bitwise inclusive OR with inverted immediate (unpredicated)", "heading": "ORN (immediate)", "para": "Bitwise inclusive OR with inverted immediate (unpredicated). \n\nBitwise inclusive OR an inverted immediate with each 64-bit element of the  source vector, and destructively place the results in the corresponding  elements of the source vector. The immediate is a 64-bit value consisting of a  single run of ones or zeros repeating every 2, 4, 8, 16, 32 or 64 bits. This  instruction is unpredicated. \n\nThis is a pseudo-instruction of ORR (immediate). This means:  \n* The encodings in this description are named to match the encodings of ORR \n  (immediate). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of ORR (immediate) gives the operational pseudocode for this \n  instruction.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><const>": "Is a 64, 32, 16 or 8-bit bitmask consisting of replicated 2, 4, 8, 16, 32 or 64 bit fields, each field containing a rotated run of non-zero bits, encoded in the \"imm13\" field."}, "encodings": ["ORN     <Zdn>.<T>, <Zdn>.<T>, #<const>"]}, {"id": 126, "asmtemplate": "FCVTPU  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector)", "heading": "FCVTPU (vector)", "para": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity \n(vector). This instruction converts a scalar or each element in a vector from  a floating-point value to an unsigned integer value using the Round towards  Plus Infinity rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTPU  <Hd>, <Hn>", "FCVTPU  <V><d>, <V><n>", "FCVTPU  <Vd>.<T>, <Vn>.<T>", "FCVTPU  <Vd>.<T>, <Vn>.<T>"]}, {"id": 605, "asmtemplate": "ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Zip vectors (secondary)", "heading": "ZIP2", "para": "Zip vectors (secondary). This instruction reads adjacent vector elements from  the upper half of two source SIMD&FP registers as pairs, interleaves the pairs  and places them into a vector, and writes the vector to the destination  SIMD&FP register. The first pair from the first source register is placed into  the two lowest vector elements, with subsequent pairs taken alternately from  each source register. \n\nThis instruction can be used with ZIP1 to interleave two vectors. \n\nThe following figure shows an example of the operation of ZIP1 and ZIP2 with  the arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["ZIP2  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 421, "asmtemplate": "INCP    <Zdn>.<T>, <Pm>.<T>", "brief": "Increment vector by count of true predicate elements", "heading": "INCP (vector)", "para": "Increment vector by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to increment all destination vector elements. \n\nThe predicate size specifier may be omitted in assembler source code, but this  is deprecated and will be prohibited in a future release of the architecture.", "explanations": {"<T><Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["INCP    <Zdn>.<T>, <Pm>.<T>"]}, {"id": 433, "asmtemplate": "LD1SB   {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]", "brief": "Contiguous load signed bytes to vector (scalar index)", "heading": "LD1SB (scalar plus scalar)", "para": "Contiguous load signed bytes to vector (scalar index). \n\nContiguous load of signed bytes to elements of a vector register from the  memory address generated by a 64-bit scalar base and scalar index which is  added to the base address. After each element access the index value is  incremented, but the index register is not updated. Inactive elements will not  not cause a read from Device memory or signal a fault, and are set to zero in  the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1SB   { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>]", "LD1SB   { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>]", "LD1SB   { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>]"]}, {"id": 1262, "asmtemplate": "CPY     <Zd>.<T>, <Pg>/M, <V><n>", "brief": "Copy SIMD&FP scalar register to vector elements (predicated)", "heading": "CPY (SIMD&FP scalar)", "para": "Copy SIMD&FP scalar register to vector elements (predicated). \n\nCopy the SIMD & floating-point scalar source register to each active element  in the destination vector. Inactive elements in the destination vector  register remain unmodified. \n\nThis instruction is used by the alias MOV (SIMD&FP scalar, predicated).", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "": "FP register, encoded in the \"Vn\" field.", "<V><n>": "Is the number [0-31] of the source SIMD", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["CPY     <Zd>.<T>, <Pg>/M, <V><n>"]}, {"id": 478, "asmtemplate": "NEG     <Zd>.<T>, <Pg>/M, <Zn>.<T>", "brief": "Negate (predicated)", "heading": "NEG", "para": "Negate (predicated). \n\nNegate the signed integer value in each active element of the source vector,  and place the results in the corresponding elements of the destination vector.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["NEG     <Zd>.<T>, <Pg>/M, <Zn>.<T>"]}, {"id": 971, "asmtemplate": "SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S", "brief": "SM3SS1", "heading": "SM3SS1", "para": "SM3SS1 rotates the top 32 bits of the 128-bit vector in the first source  SIMD&FP register by 12, and adds that 32-bit value to the two other 32-bit  values held in the top 32 bits of each of the 128-bit vectors in the second  and third source SIMD&FP registers, rotating this result left by 7 and writing  the final result into the top 32 bits of the vector in the destination SIMD&FP  register, with the bottom 96 bits of the vector being written to 0. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": "FP source register, encoded in the \"Ra\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD", "<Va>": "Is the name of the third SIMD"}, "encodings": ["SM3SS1  <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S"]}, {"id": 600, "asmtemplate": "UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Dot Product unsigned arithmetic (vector)", "heading": "UDOT (vector)", "para": "Dot Product unsigned arithmetic (vector). This instruction performs the dot  product of the four unsigned 8-bit elements in each 32-bit element of the  first source register with the four unsigned 8-bit elements of the  corresponding 32-bit element in the second source register, accumulating the  result into the corresponding 32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 64, "asmtemplate": "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]", "brief": "Prefetch Memory (unscaled offset)", "heading": "PRFUM", "para": "Prefetch Memory (unscaled offset) signals the memory system that data memory  accesses from a specified address are likely to occur in the near future. The  memory system can respond by taking actions that are expected to speed up the  memory accesses when they do occur, such as preloading the cache line  containing the specified address into one or more caches. \n\nThe effect of an PRFUM instruction is implementation defined. For more  information, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"": "This syntax is only for encodings that are not accessible using ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<imm5>": "Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<prfop>": "Is the prefetch operation, defined as "}, "encodings": ["PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]"]}, {"id": 1089, "asmtemplate": "LDFF1SW {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]", "brief": "Contiguous load first-fault signed words to vector (scalar index)", "heading": "LDFF1SW (scalar plus scalar)", "para": "Contiguous load first-fault signed words to vector (scalar index). \n\nContiguous load with first-faulting behavior of signed words to elements of a  vector register from the memory address generated by a 64-bit scalar base and  scalar index which is multiplied by 4 and added to the base address. After  each element access the index value is incremented, but the index register is  not updated. Inactive elements will not not cause a read from Device memory or  signal a fault, and are set to zero in the destination vector.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the optional 64-bit name of the general-purpose offset register, defaulting to XZR, encoded in the \"Rm\" field."}, "encodings": ["LDFF1SW { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, <Xm>, LSL #2}]"]}, {"id": 477, "asmtemplate": "ORN  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise OR NOT (shifted register)", "heading": "ORN (shifted register)", "para": "Bitwise OR NOT (shifted register) performs a bitwise (inclusive) OR of a  register value and the complement of an optionally-shifted register value, and  writes the result to the destination register. \n\nThis instruction is used by the alias MVN.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ORN  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 253, "asmtemplate": "B  <label>", "brief": "Branch", "heading": "B", "para": "Branch causes an unconditional branch to a label at a PC-relative offset, with  a hint that this is not a subroutine call or return.", "explanations": {"<label>": "Is the program label to be unconditionally branched to. Its offset from the address of this instruction, in the range +/-128MB, is encoded as \"imm26\" times 4."}, "encodings": ["B  <label>"]}, {"id": 1118, "asmtemplate": "LD1RQW  {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load and replicate four words (scalar index)", "heading": "LD1RQW (scalar plus scalar)", "para": "Contiguous load and replicate four words (scalar index). \n\nLoad four contiguous words to elements of a short, 128-bit (quadword) vector  from the memory address generated by a 64-bit scalar base address and scalar  index which is multiplied by 4 and added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first four predicate elements are used and  higher numbered predicate elements are ignored.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1RQW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 276, "asmtemplate": "CFINV", "brief": "Invert Carry Flag", "heading": "CFINV", "para": "Invert Carry Flag. This instruction inverts the value of the PSTATE.C flag.", "explanations": {}, "encodings": ["CFINV"]}, {"id": 733, "asmtemplate": "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Shift Left (register)", "heading": "SSHL", "para": "Signed Shift Left (register). This instruction takes each signed integer value  in the vector of the first source SIMD&FP register, shifts each value by a  value from the least significant byte of the corresponding element of the  second source SIMD&FP register, places the results in a vector, and writes the  vector to the destination SIMD&FP register. \n\nIf the shift value is positive, the operation is a left shift. If the shift  value is negative, it is a truncating right shift. For a rounding shift, see  SRSHL. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SSHL  <V><d>, <V><n>, <V><m>", "SSHL  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 986, "asmtemplate": "LDFF1D  {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault doublewords to vector (immediate index)", "heading": "LDFF1D (vector plus immediate)", "para": "Gather load first-fault doublewords to vector (immediate index). \n\nGather load with first-faulting behavior of doublewords to active elements of  a vector register from memory addresses generated by a vector base plus  immediate index. The index is a multiple of 8 in the range 0 to 248. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 8 in the range 0 to 248, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDFF1D  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 1000, "asmtemplate": "BLR  <Xn>", "brief": "Branch with Link to Register", "heading": "BLR", "para": "Branch with Link to Register calls a subroutine at an address in a register,  setting register X30 to PC+4.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."}, "encodings": ["BLR  <Xn>"]}, {"id": 712, "asmtemplate": "UQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment scalar by multiple of 8-bit predicate constraint element count", "heading": "UQINCB", "para": "Unsigned saturating increment scalar by multiple of 8-bit predicate constraint  element count. \n\nDetermines the number of active 8-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCB  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 826, "asmtemplate": "CSINV  <Xd>, <Xn>, <Xm>, <cond>", "brief": "Conditional Select Invert", "heading": "CSINV", "para": "Conditional Select Invert returns, in the destination register, the value of  the first source register if the condition is TRUE, and otherwise returns the  bitwise inversion value of the second source register. \n\nThis instruction is used by the aliases CINV, and CSETM.", "explanations": {"<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CSINV  <Wd>, <Wn>, <Wm>, <cond>"]}, {"id": 757, "asmtemplate": "STGP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", "brief": "Store Allocation Tag and Pair of registers", "heading": "STGP", "para": "Store Allocation Tag and Pair of registers stores an Allocation Tag and two  64-bit doublewords to memory, from two registers. The address used for the  store is calculated from the base register and an immediate signed offset  scaled by the Tag granule. The Allocation Tag is calculated from the Logical  Address Tag in the base register. \n\nThis instruction generates an Unchecked access. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"<imm>": "For the signed offset variant: is the optional signed immediate offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the \"simm7\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Xn\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Xt2\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Xt\" field."}, "encodings": ["STGP  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>", "STGP  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!", "STGP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 592, "asmtemplate": "CLASTB  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>", "brief": "Conditionally extract last element to vector register", "heading": "CLASTB (vectors)", "para": "Conditionally extract last element to vector register. \n\nFrom the second source vector register extract the last active element, and  then replicate that element to destructively fill the destination and first  source vector. \n\nIf there are no active elements then leave the destination and source vector  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["CLASTB  <Zdn>.<T>, <Pg>, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 744, "asmtemplate": "STURH  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Store Register Halfword (unscaled)", "heading": "STURH", "para": "Store Register Halfword (unscaled) calculates an address from a base register  value and an immediate offset, and stores a halfword to the calculated  address, from a 32-bit register. For information about memory accesses, see  Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["STURH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 8, "asmtemplate": "CMEQ  <Vd>.<T>, <Vn>.<T>, #0", "brief": "Compare bitwise Equal to zero (vector)", "heading": "CMEQ (zero)", "para": "Compare bitwise Equal to zero (vector). This instruction reads each vector  element in the source SIMD&FP register and if the value is equal to zero sets  every bit of the corresponding vector element in the destination SIMD&FP  register to one, otherwise sets every bit of the corresponding vector element  in the destination SIMD&FP register to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["CMEQ  <V><d>, <V><n>, #0", "CMEQ  <Vd>.<T>, <Vn>.<T>, #0"]}, {"id": 484, "asmtemplate": "LDR  <Xt>, <label>", "brief": "Load Register (literal)", "heading": "LDR (literal)", "para": "Load Register (literal) calculates an address from the PC value and an  immediate offset, loads a word from memory, and writes it to a register. For  information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<label>": "Is the program label from which the data is to be loaded. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDR  <Wt>, <label>"]}, {"id": 136, "asmtemplate": "UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>", "brief": "Unsigned Multiply-Subtract Long", "heading": "UMSUBL", "para": "Unsigned Multiply-Subtract Long multiplies two 32-bit register values,  subtracts the product from a 64-bit register value, and writes the result to  the 64-bit destination register. \n\nThis instruction is used by the alias UMNEGL.", "explanations": {"<Xa>": "Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["UMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"]}, {"id": 319, "asmtemplate": "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Subtract (vector)", "heading": "FSUB (vector)", "para": "Floating-point Subtract (vector). This instruction subtracts the elements in  the vector in the second source SIMD&FP register, from the corresponding  elements in the vector in the first source SIMD&FP register, places each  result into elements of a vector, and writes the vector to the destination  SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FSUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 170, "asmtemplate": "SQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment scalar by multiple of 64-bit predicate constraint element count", "heading": "SQINCD (scalar)", "para": "Signed saturating increment scalar by multiple of 64-bit predicate constraint  element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCD  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 876, "asmtemplate": "XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>", "brief": "Exclusive OR and Rotate", "heading": "XAR", "para": "Exclusive OR and Rotate performs a bitwise exclusive OR of the 128-bit vectors  in the two source SIMD&FP registers, rotates each 64-bit element of the  resulting 128-bit vector right by the value specified by a 6-bit immediate  value, and writes the result to the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA3 is implemented.", "explanations": {"<imm6>": "Is a rotation right, encoded in \"imm6\".", "<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["XAR  <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>"]}, {"id": 418, "asmtemplate": "PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]", "brief": "Prefetch Memory (immediate)", "heading": "PRFM (immediate)", "para": "Prefetch Memory (immediate) signals the memory system that data memory  accesses from a specified address are likely to occur in the near future. The  memory system can respond by taking actions that are expected to speed up the  memory accesses when they do occur, such as preloading the cache line  containing the specified address into one or more caches. \n\nThe effect of an PRFM instruction is implementation defined. For more  information, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"": "/8.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<prfop>": "Is the prefetch operation, defined as ", "<imm5>": "Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<pimm>": "Is the optional positive immediate byte offset, a multiple of 8 in the range 0 to 32760, defaulting to 0 and encoded in the \"imm12\" field as "}, "encodings": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]"]}, {"id": 1131, "asmtemplate": "LD2W    {<Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load two-word structures to two vectors (scalar index)", "heading": "LD2W (scalar plus scalar)", "para": "Contiguous load two-word structures to two vectors (scalar index). \n\nContiguous load two-word structures, each to the same element number in two  vector registers from the memory address generated by a 64-bit scalar base and  a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by two. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive words in memory which  make up each structure. Inactive elements will not cause a read from Device  memory or signal a fault, and the corresponding element is set to zero in each  of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD2W    { <Zt1>.S, <Zt2>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 575, "asmtemplate": "INSR    <Zdn>.<T>, <R><m>", "brief": "Insert general-purpose register in shifted vector", "heading": "INSR (scalar)", "para": "Insert general-purpose register in shifted vector. \n\nShift the destination vector left by one element, and then place a copy of the  least-significant bits of the general-purpose register in element 0 of the  destination vector. This instruction is unpredicated.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><R><m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field."}, "encodings": ["INSR    <Zdn>.<T>, <R><m>"]}, {"id": 453, "asmtemplate": "SXTW    <Zd>.D, <Pg>/M, <Zn>.D", "brief": "Signed byte / halfword / word extend (predicated)", "heading": "SXTB, SXTH, SXTW", "para": "Signed byte / halfword / word extend (predicated). \n\nSign-extend the least-significant sub-element of each active element of the  source vector, and place the results in the corresponding elements of the  destination vector. Inactive elements in the destination vector register  remain unmodified. \n\nIt has encodings from 3 classes: Byte , Halfword and Word", "explanations": {"<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<T><T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["SXTB    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "SXTH    <Zd>.<T>, <Pg>/M, <Zn>.<T>", "SXTW    <Zd>.D, <Pg>/M, <Zn>.D"]}, {"id": 867, "asmtemplate": "FRINT64X  <Dd>, <Dn>", "brief": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar)", "heading": "FRINT64X (scalar)", "para": "Floating-point Round to 64-bit Integer, using current rounding mode (scalar).  This instruction rounds a floating-point value in the SIMD&FP source register  to an integral floating-point value that fits into a 64-bit integer size using  the rounding mode that is determined by the FPCR, and writes the result to the  SIMD&FP destination register. \n\nA zero input returns a zero result with the same sign. When the result value  is not numerically equal to the input value, an Inexact exception is raised.  When the input is infinite, NaN or out-of-range, the instruction returns {for  the corresponding result value} the most negative integer representable in the  destination size, and an Invalid Operation floating-point exception is raised. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Sd>": "Is the 32-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD"}, "encodings": ["FRINT64X  <Sd>, <Sn>"]}, {"id": 656, "asmtemplate": "ST4B    {<Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>, <Xm>]", "brief": "Contiguous store four-byte structures from four vectors (scalar index)", "heading": "ST4B (scalar plus scalar)", "para": "Contiguous store four-byte structures from four vectors (scalar index). \n\nContiguous store four-byte structures, each from the same element number in  four vector registers to the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register and added to the base address. After each  structure access the index value is incremented by four. The index register is  not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive bytes in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["ST4B    { <Zt1>.B, <Zt2>.B, <Zt3>.B, <Zt4>.B }, <Pg>, [<Xn|SP>, <Xm>]"]}, {"id": 255, "asmtemplate": "UQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Unsigned saturating subtract vectors (unpredicated)", "heading": "UQSUB (vectors)", "para": "Unsigned saturating subtract vectors (unpredicated). \n\nUnsigned saturating subtract all elements of the second source vector from  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. Each result element is  saturated to the N-bit element's unsigned integer range 0 to (2N)-1. This  instruction is unpredicated.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["UQSUB   <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 188, "asmtemplate": "ADDHN{2}<Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", "brief": "Add returning High Narrow", "heading": "ADDHN, ADDHN2", "para": "Add returning High Narrow. This instruction adds each vector element in the  first source SIMD&FP register to the corresponding vector element in the  second source SIMD&FP register, places the most significant half of the result  into a vector, and writes the vector to the lower or upper half of the  destination SIMD&FP register. \n\nThe results are truncated. For rounded results, see RADDHN. \n\nThe ADDHN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the ADDHN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vm>": "Is the name of the second SIMD", "<Tb><Vn>": "Is the name of the first SIMD"}, "encodings": ["ADDHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"]}, {"id": 469, "asmtemplate": "SMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B", "brief": "Signed 8-bit integer matrix multiply-accumulate (vector)", "heading": "SMMLA (vector)", "para": "Signed 8-bit integer matrix multiply-accumulate. This instruction multiplies  the 2x8 matrix of signed 8-bit integer values in the first source vector by  the 8x2 matrix of signed 8-bit integer values in the second source vector. The  resulting 2x2 32-bit integer matrix product is destructively added to the  32-bit integer matrix accumulator in the destination vector. This is  equivalent to performing an 8-way dot product per destination element. \n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is  mandatory for implementations that include Advanced SIMD to support it.  ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["SMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"]}, {"id": 308, "asmtemplate": "LDAPR  <Xt>, [<Xn|SP> {,#0}]", "brief": "Load-Acquire RCpc Register", "heading": "LDAPR", "para": "Load-Acquire RCpc Register derives an address from a base register value,  loads a 32-bit word or 64-bit doubleword from the derived address in memory,  and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDAPR  <Wt>, [<Xn|SP> {,#0}]"]}, {"id": 1240, "asmtemplate": "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector)", "heading": "SQRDMLSH (vector)", "para": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half \n(vector). This instruction multiplies the vector elements of the first source  SIMD&FP register with the corresponding vector elements of the second source  SIMD&FP register without saturating the multiply results, doubles the results,  and subtracts the most significant half of the final results from the vector  elements of the destination SIMD&FP register. The results are rounded. \n\nIf any of the results overflow, they are saturated. The cumulative saturation  bit, FPSR.QC, is set if saturation occurs. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQRDMLSH  <V><d>, <V><n>, <V><m>", "SQRDMLSH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 591, "asmtemplate": "USMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B", "brief": "Unsigned and signed 8-bit integer matrix multiply-accumulate (vector)", "heading": "USMMLA (vector)", "para": "Unsigned and signed 8-bit integer matrix multiply-accumulate. This instruction  multiplies the 2x8 matrix of unsigned 8-bit integer values in the first source  vector by the 8x2 matrix of signed 8-bit integer values in the second source  vector. The resulting 2x2 32-bit integer matrix product is destructively added  to the 32-bit integer matrix accumulator in the destination vector. This is  equivalent to performing an 8-way dot product per destination element. \n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is  mandatory for implementations that include Advanced SIMD to support it.  ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD"}, "encodings": ["USMMLA  <Vd>.4S, <Vn>.16B, <Vm>.16B"]}, {"id": 83, "asmtemplate": "MOVZ<Xd>, #<imm16>, LSL #<shift>", "brief": "Move (wide immediate)", "heading": "MOV (wide immediate)", "para": "Move (wide immediate) moves a 16-bit immediate value to a register. \n\nThis is an alias of MOVZ. This means:  \n* The encodings in this description are named to match the encodings of MOVZ. \n* The description of MOVZ gives the operational pseudocode for this \n  instruction.", "explanations": {"<imm>": "For the 64-bit variant: is a 64-bit immediate which can be encoded in \"imm16:hw\".", "": "/16.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<shift>": "For the 64-bit variant: is the amount by which to shift the immediate left, either 0 (the default), 16, 32 or 48, encoded in the \"hw\" field as ", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MOV  <Wd>, #<imm>"]}, {"id": 53, "asmtemplate": "SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Dot Product signed arithmetic (vector)", "heading": "SDOT (vector)", "para": "Dot Product signed arithmetic (vector). This instruction performs the dot  product of the four signed 8-bit elements in each 32-bit element of the first  source register with the four signed 8-bit elements of the corresponding  32-bit element in the second source register, accumulating the result into the  corresponding 32-bit element of the destination register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.DP indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 543, "asmtemplate": "SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S", "brief": "SHA256 schedule update 1", "heading": "SHA256SU1", "para": "SHA256 schedule update 1.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SHA256SU1  <Vd>.4S, <Vn>.4S, <Vm>.4S"]}, {"id": 978, "asmtemplate": "UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unsigned Halving Add", "heading": "UHADD", "para": "Unsigned Halving Add. This instruction adds corresponding unsigned integer  values from the two source SIMD&FP registers, shifts each result right one  bit, places the results into a vector, and writes the vector to the  destination SIMD&FP register. \n\nThe results are truncated. For rounded results, see URHADD. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UHADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1066, "asmtemplate": "ANDS  <Xd>, <Xn>, #<imm>", "brief": "Bitwise AND (immediate), setting flags", "heading": "ANDS (immediate)", "para": "Bitwise AND (immediate), setting flags, performs a bitwise AND of a register  value and an immediate value, and writes the result to the destination  register. It updates the condition flags based on the result. \n\nThis instruction is used by the alias TST (immediate).", "explanations": {"<imm>": "For the 64-bit variant: is the bitmask immediate, encoded in \"N:imms:immr\".", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ANDS  <Wd>, <Wn>, #<imm>"]}, {"id": 157, "asmtemplate": "DECP    <Xdn>, <Pm>.<T>", "brief": "Decrement scalar by count of true predicate elements", "heading": "DECP (scalar)", "para": "Decrement scalar by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to decrement the scalar destination.", "explanations": {"<Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field."}, "encodings": ["DECP    <Xdn>, <Pm>.<T>"]}, {"id": 1137, "asmtemplate": "LDUMAXLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic unsigned maximum on halfword in memory", "heading": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH", "para": "Atomic unsigned maximum on halfword in memory atomically loads a 16-bit  halfword from memory, compares it against the value held in a register, and  stores the larger value back to memory, treating the values as unsigned  numbers. The value initially loaded from memory is returned in the destination  register.  \n* If the destination register is not WZR, LDUMAXAH and LDUMAXALH load from \n  memory with acquire semantics. \n* LDUMAXLH and LDUMAXALH store to memory with release semantics. \n* LDUMAXH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMAXH, STUMAXLH.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDUMAXAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 571, "asmtemplate": "ST3B    {<Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>, <Xm>]", "brief": "Contiguous store three-byte structures from three vectors (scalar index)", "heading": "ST3B (scalar plus scalar)", "para": "Contiguous store three-byte structures from three vectors (scalar index). \n\nContiguous store three-byte structures, each from the same element number in  three vector registers to the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register and added to the base address. After each  structure access the index value is incremented by three. The index register  is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive bytes in memory  which make up each structure. Inactive structures are not written to memory.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["ST3B    { <Zt1>.B, <Zt2>.B, <Zt3>.B }, <Pg>, [<Xn|SP>, <Xm>]"]}, {"id": 403, "asmtemplate": "SQXTN{2}<Vd>.<Tb>, <Vn>.<Ta>", "brief": "Signed saturating extract Narrow", "heading": "SQXTN, SQXTN2", "para": "Signed saturating extract Narrow. This instruction reads each vector element  from the source SIMD&FP register, saturates the value to half the original  width, places the result into a vector, and writes the vector to the lower or  upper half of the destination SIMD&FP register. The destination vector  elements are half as long as the source vector elements. All the values in  this instruction are signed integer values. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nThe SQXTN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SQXTN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Va><n>": "Is the number of the SIMD", "2<Vd>": "Is the name of the SIMD", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["SQXTN  <Vb><d>, <Va><n>", "SQXTN{2}  <Vd>.<Tb>, <Vn>.<Ta>"]}, {"id": 817, "asmtemplate": "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Unsigned Rounding Shift Right and Accumulate (immediate)", "heading": "URSRA", "para": "Unsigned Rounding Shift Right and Accumulate (immediate). This instruction  reads each vector element in the source SIMD&FP register, right shifts each  result by an immediate value, and accumulates the final results with the  vector elements of the destination SIMD&FP register. All the values in this  instruction are unsigned integer values. The results are rounded. For  truncated results, see USRA. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["URSRA  <V><d>, <V><n>, #<shift>", "URSRA  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 242, "asmtemplate": "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Subtract (vector)", "heading": "SUB (vector)", "para": "Subtract (vector). This instruction subtracts each vector element in the  second source SIMD&FP register from the corresponding vector element in the  first source SIMD&FP register, places the result into a vector, and writes the  vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SUB  <V><d>, <V><n>, <V><m>", "SUB  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1257, "asmtemplate": "FCVTAS  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector)", "heading": "FCVTAS (vector)", "para": "Floating-point Convert to Signed integer, rounding to nearest with ties to  Away (vector). This instruction converts each element in a vector from a  floating-point value to a signed integer value using the Round to Nearest with  Ties to Away rounding mode and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTAS  <Hd>, <Hn>", "FCVTAS  <V><d>, <V><n>", "FCVTAS  <Vd>.<T>, <Vn>.<T>", "FCVTAS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 398, "asmtemplate": "PTRUES  <Pd>.<T>{, <pattern>}", "brief": "Initialise predicate from named constraint", "heading": "PTRUE, PTRUES", "para": "Initialise predicate from named constraint. \n\nSet elements of the destination predicate to true if the element number  satisfies the named predicate constraint, or to false otherwise. If the  constraint specifies more elements than are available at the current vector  length then all elements of the destination predicate are set to false. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. Optionally  sets the First (N), None (Z), !Last (C) condition flags based on the predicate  result, and the V flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["PTRUE   <Pd>.<T>{, <pattern>}", "PTRUES  <Pd>.<T>{, <pattern>}"]}, {"id": 390, "asmtemplate": "ORR     <Zd>.D, <Zn>.D, <Zm>.D", "brief": "Bitwise inclusive OR vectors (unpredicated)", "heading": "ORR (vectors, unpredicated)", "para": "Bitwise inclusive OR vectors (unpredicated). \n\nBitwise inclusive OR all elements of the second source vector with  corresponding elements of the first source vector and place the first in the  corresponding elements of the destination vector. This instruction is  unpredicated. \n\nThis instruction is used by the alias MOV (vector, unpredicated).", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["ORR     <Zd>.D, <Zn>.D, <Zm>.D"]}, {"id": 14, "asmtemplate": "SBC<Xd>, XZR, <Xm>", "brief": "Negate with Carry", "heading": "NGC", "para": "Negate with Carry negates the sum of a register value and the value of NOT \n(Carry flag), and writes the result to the destination register. \n\nThis is an alias of SBC. This means:  \n* The encodings in this description are named to match the encodings of SBC. \n* The description of SBC gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xm>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Wm>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["NGC  <Wd>, <Wm>"]}, {"id": 451, "asmtemplate": "CNTP    <Xd>, <Pg>, <Pn>.<T>", "brief": "Set scalar to count of true predicate elements", "heading": "CNTP", "para": "Set scalar to count of true predicate elements. \n\nCounts the number of active and true elements in the source predicate and  places the scalar result in the destination general-purpose register. Inactive  predicate elements are not counted.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the source scalable predicate register, encoded in the \"Pn\" field.", "<Xd>": "Is the 64-bit name of the destination general-purpose register, encoded in the \"Rd\" field."}, "encodings": ["CNTP    <Xd>, <Pg>, <Pn>.<T>"]}, {"id": 1070, "asmtemplate": "SUBR    <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}", "brief": "Reversed subtract from immediate (unpredicated)", "heading": "SUBR (immediate)", "para": "Reversed subtract from immediate (unpredicated). \n\nReversed subtract from an unsigned immediate each element of the source  vector, and destructively place the results in the corresponding elements of  the source vector. This instruction is unpredicated. \n\nThe immediate is an unsigned value in the range 0 to 255, and for element  widths of 16 bits or higher it may also be a positive multiple of 256 in the  range 256 to 65280. \n\nThe immediate is encoded in 8 bits with an optional left shift by 8. The  preferred disassembly when the shift option is specified is \"#<uimm8>, LSL \n#8\". However an assembler and disassembler may also allow use of the shifted  16-bit value unless the immediate is 0 and the shift amount is 8, which must  be unambiguously described as \"#0, LSL #8\".", "explanations": {"<T><imm>": "Is an unsigned immediate in the range 0 to 255, encoded in the \"imm8\" field.", "<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["SUBR    <Zdn>.<T>, <Zdn>.<T>, #<imm>{, <shift>}"]}, {"id": 889, "asmtemplate": "LD4D    {<Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load four-doubleword structures to four vectors (scalar index)", "heading": "LD4D (scalar plus scalar)", "para": "Contiguous load four-doubleword structures to four vectors (scalar index). \n\nContiguous load four-doubleword structures, each to the same element number in  four vector registers from the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by four. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the four  vector registers, or equivalently to the four consecutive doublewords in  memory which make up each structure. Inactive elements will not cause a read  from Device memory or signal a fault, and the corresponding element is set to  zero in each of the four destination vector registers.", "explanations": {"<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field.", "<Zt4>": "Is the name of the fourth scalable vector register to be transferred, encoded as \"Zt\" plus 3 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LD4D    { <Zt1>.D, <Zt2>.D, <Zt3>.D, <Zt4>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 71, "asmtemplate": "SMC  #<imm>", "brief": "Secure Monitor Call", "heading": "SMC", "para": "Secure Monitor Call causes an exception to EL3. \n\nSMC is available only for software executing at EL1 or higher. It is undefined  in EL0. \n\nIf the values of HCR_EL2.TSC and SCR_EL3.SMD are both 0, execution of an SMC  instruction at EL1 or higher generates a Secure Monitor Call exception,  recording it in ESR_ELx, using the EC value 0x17, that is taken to EL3. \n\nIf the value of HCR_EL2.TSC is 1 and EL2 is enabled in the current Security  state, execution of an SMC instruction at EL1 generates an exception that is  taken to EL2, regardless of the value of SCR_EL3.SMD. For more information,  see Traps to EL2 of Non-secure EL1 execution of SMC instructions. \n\nIf the value of HCR_EL2.TSC is 0 and the value of SCR_EL3.SMD is 1, the SMC  instruction is undefined.", "explanations": {"<imm>": "Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."}, "encodings": ["SMC  #<imm>"]}, {"id": 767, "asmtemplate": "FDUP<Zd>.<T>, #<const>", "brief": "Move 8-bit floating-point immediate to vector elements (unpredicated)", "heading": "FMOV (immediate, unpredicated)", "para": "Move 8-bit floating-point immediate to vector elements (unpredicated). \n\nUnconditionally broadcast the floating-point immediate into each element of  the destination vector. This instruction is unpredicated. \n\nThis is an alias of FDUP. This means:  \n* The encodings in this description are named to match the encodings of FDUP. \n* The description of FDUP gives the operational pseudocode for this \n  instruction.", "explanations": {"": "\u00b1n\u00f716\u00d72^r, where n and r are integers such that 16 \u2264 n \u2264 31 and -3 \u2264 r \u2264 4, i.e. a normalized binary floating-point encoding with 1 sign bit, 3-bit exponent, and 4-bit fractional part, encoded in the \"imm8\" field.", "<T><const>": "Is a floating-point immediate value expressable as ", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FMOV    <Zd>.<T>, #<const>"]}, {"id": 331, "asmtemplate": "EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B", "brief": "Three-way Exclusive OR", "heading": "EOR3", "para": "Three-way Exclusive OR performs a three-way exclusive OR of the values in the  three source SIMD&FP registers, and writes the result to the destination  SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA3 is implemented.", "explanations": {"": "FP source register, encoded in the \"Ra\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD", "<Va>": "Is the name of the third SIMD"}, "encodings": ["EOR3  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"]}, {"id": 115, "asmtemplate": "ST1H    {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]", "brief": "Scatter store halfwords from a vector (vector index)", "heading": "ST1H (scalar plus vector)", "para": "Scatter store halfwords from a vector (vector index). \n\nScatter store of halfwords from the active elements of a vector register to  the memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 2. Inactive elements are not written to memory. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["ST1H    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #1]", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #1]", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]", "ST1H    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #1]", "ST1H    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]"]}, {"id": 402, "asmtemplate": "SMLAL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Signed Multiply-Add Long (vector, by element)", "heading": "SMLAL, SMLAL2 (by element)", "para": "Signed Multiply-Add Long (vector, by element). This instruction multiplies  each vector element in the lower or upper half of the first source SIMD&FP  register by the specified vector element in the second source SIMD&FP  register, and accumulates the results with the vector elements of the  destination SIMD&FP register. The destination vector elements are twice as  long as the elements that are multiplied. All the values in this instruction  are signed integer values. \n\nThe SMLAL instruction extracts vector elements from the lower half of the  first source register, while the SMLAL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Ta><Vn>": "Is the name of the first SIMD", "": "FP source register, encoded in the \"Rn\" field.", "2<Vd>": "Is the name of the SIMD"}, "encodings": ["SMLAL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 1148, "asmtemplate": "PACIAZ", "brief": "Pointer Authentication Code for Instruction address, using key A", "heading": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA", "para": "Pointer Authentication Code for Instruction address, using key A. This  instruction computes and inserts a pointer authentication code for an  instruction address, using a modifier and key A. \n\nThe address is:  \n* In the general-purpose register that is specified by <Xd> for PACIA and \n  PACIZA. \n* In X17, for PACIA1716. \n* In X30, for PACIASP and PACIAZ.  The modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xn|SP> for PACIA. \n* The value zero, for PACIZA and PACIAZ. \n* In X16, for PACIA1716. \n* In SP, for PACIASP.  It has encodings from 2 classes: Integer and System", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["PACIA  <Xd>, <Xn|SP>", "PACIA1716"]}, {"id": 211, "asmtemplate": "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Signed Shift Right (immediate)", "heading": "SSHR", "para": "Signed Shift Right (immediate). This instruction reads each vector element in  the source SIMD&FP register, right shifts each result by an immediate value,  places the final result into a vector, and writes the vector to the  destination SIMD&FP register. All the values in this instruction are signed  integer values. The results are truncated. For rounded results, see SRSHR. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SSHR  <V><d>, <V><n>, #<shift>", "SSHR  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 516, "asmtemplate": "DGH", "brief": "Data Gathering Hint", "heading": "DGH", "para": "DGH is a hint instruction. A DGH instruction is not expected to be performance  optimal to merge memory accesses with Normal Non-cacheable or Device-GRE  attributes appearing in program order before the hint instruction with any  memory accesses appearing after the hint instruction into a single memory  transaction on an interconnect.", "explanations": {}, "encodings": ["DGH"]}, {"id": 337, "asmtemplate": "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]", "brief": "Store Register Halfword (immediate)", "heading": "STRH (immediate)", "para": "Store Register Halfword (immediate) stores the least significant halfword of a  32-bit register to memory. The address that is used for the store is  calculated from a base register and an immediate offset. For information about  memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"": "/2.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, a multiple of 2 in the range 0 to 8190, defaulting to 0 and encoded in the \"imm12\" field as "}, "encodings": ["STRH  <Wt>, [<Xn|SP>], #<simm>", "STRH  <Wt>, [<Xn|SP>, #<simm>]!", "STRH  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 728, "asmtemplate": "FNMAD   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>", "brief": "Floating-point negated fused multiply-add vectors (predicated), writing multiplicand [Zdn = -Za + -Zdn * Zm]", "heading": "FNMAD", "para": "Floating-point negated fused multiply-add vectors (predicated), writing  multiplicand [Zdn = -Za + -Zdn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and add to elements of the third (addend) vector without  intermediate rounding. Destructively place the negated results in the  destination and first source (multiplicand) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Za>": "Is the name of the third source scalable vector register, encoded in the \"Za\" field."}, "encodings": ["FNMAD   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>"]}, {"id": 396, "asmtemplate": "LD1ROW  {<Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]", "brief": "Contiguous load and replicate eight words (scalar index)", "heading": "LD1ROW (scalar plus scalar)", "para": "Contiguous load and replicate eight words (scalar index). \n\nLoad eight contiguous words to elements of a 256-bit (octaword) vector from  the memory address generated by a 64-bit scalar base address and scalar index  which is multiplied by 4 and added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first eight predicate elements are used and higher numbered predicate  elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1ROW  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #2]"]}, {"id": 665, "asmtemplate": "CRC32X  <Wd>, <Wn>, <Xm>", "brief": "CRC32 checksum", "heading": "CRC32B, CRC32H, CRC32W, CRC32X", "para": "CRC32 checksum performs a cyclic redundancy check (CRC) calculation on a value  held in a general-purpose register. It takes an input CRC value in the first  source operand, performs a CRC on the input value in the second source  operand, and returns the output CRC value. The second source operand can be 8,  16, 32, or 64 bits. To align with common usage, the bit order of the values is  reversed as part of the operation, and the polynomial 0x04C11DB7 is used for  the CRC calculation. \n\nIn Armv8-A, this is an optional instruction, and in Armv8.1 it is mandatory  for all implementations to implement it. \n\nID_AA64ISAR0_EL1.CRC32 indicates whether this instruction is supported.", "explanations": {"<Wd>": "Is the 32-bit name of the general-purpose accumulator output register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the general-purpose data source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the general-purpose accumulator input register, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose data source register, encoded in the \"Rm\" field."}, "encodings": ["CRC32B  <Wd>, <Wn>, <Wm>"]}, {"id": 183, "asmtemplate": "LDR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Load predicate register", "heading": "LDR (predicate)", "para": "Load predicate register. \n\nLoad a predicate register from a memory address generated by a 64-bit scalar  base, plus an immediate offset in the range -256 to 255 which is multiplied by  the current predicate register size in bytes. This instruction is  unpredicated. \n\nThe load is performed as a stream of bytes containing 8 consecutive predicate  bits in ascending element order, without any endian conversion.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm>": "Is the optional signed immediate vector offset, in the range -256 to 255, defaulting to 0, encoded in the \"imm9h:imm9l\" fields.", "<Pt>": "Is the name of the destination scalable predicate register, encoded in the \"Pt\" field."}, "encodings": ["LDR     <Pt>, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 1029, "asmtemplate": "STXP  <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", "brief": "Store Exclusive Pair of registers", "heading": "STXP", "para": "Store Exclusive Pair of registers stores two 32-bit words or two 64-bit  doublewords from two registers to a memory location if the PE has exclusive  access to the memory address, and returns a status value of 0 if the store was  successful, or of 1 if no store was performed. See Synchronization and  semaphores. A 32-bit pair requires the address to be doubleword aligned and is  single-copy atomic at doubleword granularity. A 64-bit pair requires the  address to be quadword aligned and, if the Store-Exclusive succeeds, it causes  a single-copy atomic update of the 128-bit memory location being updated. For  information about memory accesses see Load/Store addressing modes.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register into which the status result of the store exclusive is written, encoded in the \"Rs\" field. The value returned is:", "<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STXP  <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"]}, {"id": 336, "asmtemplate": "LD3D    {<Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load three-doubleword structures to three vectors (scalar index)", "heading": "LD3D (scalar plus scalar)", "para": "Contiguous load three-doubleword structures to three vectors (scalar index). \n\nContiguous load three-doubleword structures, each to the same element number  in three vector registers from the memory address generated by a 64-bit scalar  base and a 64-bit scalar index register scaled by the element size (LSL  option) and added to the base address. After each structure access the index  value is incremented by three. The index register is not updated by the  instruction. \n\nEach predicate element applies to the same element number in each of the three  vector registers, or equivalently to the three consecutive doublewords in  memory which make up each structure. Inactive elements will not cause a read  from Device memory or signal a fault, and the corresponding element is set to  zero in each of the three destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt3>": "Is the name of the third scalable vector register to be transferred, encoded as \"Zt\" plus 2 modulo 32.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD3D    { <Zt1>.D, <Zt2>.D, <Zt3>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 149, "asmtemplate": "LDFF1W  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault unsigned words to vector (vector index)", "heading": "LDFF1W (scalar plus vector)", "para": "Gather load first-fault unsigned words to vector (vector index). \n\nGather load with first-faulting behavior of unsigned words to active elements  of a vector register from memory addresses generated by a 64-bit scalar base  plus vector index. The index values are optionally first sign or zero-extended  from 32 to 64 bits and then optionally multiplied by 4. Inactive elements will  not cause a read from Device memory or signal faults, and are set to zero in  the destination vector. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #2]", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #2]", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1W  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #2]", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 742, "asmtemplate": "BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B", "brief": "Bit Clear and XOR", "heading": "BCAX", "para": "Bit Clear and Exclusive OR performs a bitwise AND of the 128-bit vector in a  source SIMD&FP register and the complement of the vector in another source  SIMD&FP register, then performs a bitwise exclusive OR of the resulting vector  and the vector in a third source SIMD&FP register, and writes the result to  the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SHA3 is implemented.", "explanations": {"": "FP source register, encoded in the \"Ra\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD", "<Va>": "Is the name of the third SIMD"}, "encodings": ["BCAX  <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"]}, {"id": 1110, "asmtemplate": "SVC  #<imm>", "brief": "Supervisor Call", "heading": "SVC", "para": "Supervisor Call causes an exception to be taken to EL1. \n\nOn executing an SVC instruction, the PE records the exception as a Supervisor  Call exception in ESR_ELx, using the EC value 0x15, and the value of the  immediate argument.", "explanations": {"<imm>": "Is a 16-bit unsigned immediate, in the range 0 to 65535, encoded in the \"imm16\" field."}, "encodings": ["SVC  #<imm>"]}, {"id": 608, "asmtemplate": "LD1RSH  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast signed halfword to vector", "heading": "LD1RSH", "para": "Load and broadcast signed halfword to vector. \n\nLoad a single signed halfword from a memory address generated by a 64-bit  scalar base address plus an immediate offset which is a multiple of 2 in the  range 0 to 126. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 126, defaulting to 0, encoded in the \"imm6\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1RSH  { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "LD1RSH  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 1153, "asmtemplate": "CSINV<Xd>, <Xn>, <Xn>, invert(<cond>)", "brief": "Conditional Invert", "heading": "CINV", "para": "Conditional Invert returns, in the destination register, the bitwise inversion  of the value of the source register if the condition is TRUE, and otherwise  returns the value of the source register. \n\nThis is an alias of CSINV. This means:  \n* The encodings in this description are named to match the encodings of CSINV. \n* The description of CSINV gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<cond>": "Is one of the standard conditions, excluding AL and NV, encoded in the \"cond\" field with its least significant bit inverted.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" and \"Rm\" fields.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["CINV  <Wd>, <Wn>, <cond>"]}, {"id": 853, "asmtemplate": "LDAXP  <Xt1>, <Xt2>, [<Xn|SP>{,#0}]", "brief": "Load-Acquire Exclusive Pair of Registers", "heading": "LDAXP", "para": "Load-Acquire Exclusive Pair of Registers derives an address from a base  register value, loads two 32-bit words or two 64-bit doublewords from memory,  and writes them to two registers. A 32-bit pair requires the address to be  doubleword aligned and is single-copy atomic at doubleword granularity. A  64-bit pair requires the address to be quadword aligned and is single-copy  atomic for each doubleword at doubleword granularity. The PE marks the  physical address being accessed as an exclusive access. This exclusive access  mark is checked by Store Exclusive instructions. See Synchronization and  semaphores. The instruction also has memory ordering semantics as described in  Load-Acquire, Store-Release. For information about memory accesses see  Load/Store addressing modes.", "explanations": {"<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAXP  <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"]}, {"id": 377, "asmtemplate": "LD2H    {<Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load two-halfword structures to two vectors (scalar index)", "heading": "LD2H (scalar plus scalar)", "para": "Contiguous load two-halfword structures to two vectors (scalar index). \n\nContiguous load two-halfword structures, each to the same element number in  two vector registers from the memory address generated by a 64-bit scalar base  and a 64-bit scalar index register scaled by the element size (LSL option) and  added to the base address. After each structure access the index value is  incremented by two. The index register is not updated by the instruction. \n\nEach predicate element applies to the same element number in each of the two  vector registers, or equivalently to the two consecutive halfwords in memory  which make up each structure. Inactive elements will not cause a read from  Device memory or signal a fault, and the corresponding element is set to zero  in each of the two destination vector registers.", "explanations": {"<Zt2>": "Is the name of the second scalable vector register to be transferred, encoded as \"Zt\" plus 1 modulo 32.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt1>": "Is the name of the first scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD2H    { <Zt1>.H, <Zt2>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 567, "asmtemplate": "BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Bitwise Insert if False", "heading": "BIF", "para": "Bitwise Insert if False. This instruction inserts each bit from the first  source SIMD&FP register into the destination SIMD&FP register if the  corresponding bit of the second source SIMD&FP register is 0, otherwise leaves  the bit in the destination register unchanged. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["BIF  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 175, "asmtemplate": "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>", "brief": "Shift Left (immediate)", "heading": "SHL", "para": "Shift Left (immediate). This instruction reads each value from a vector, left  shifts each result by an immediate value, writes the final result to a vector,  and writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["SHL  <V><d>, <V><n>, #<shift>", "SHL  <Vd>.<T>, <Vn>.<T>, #<shift>"]}, {"id": 424, "asmtemplate": "USMMLA  <Zda>.S, <Zn>.B, <Zm>.B", "brief": "Unsigned by signed integer matrix multiply-accumulate", "heading": "USMMLA", "para": "Unsigned by signed integer matrix multiply-accumulate. \n\nThe unsigned by signed integer matrix multiply-accumulate instruction  multiplies the 2\u00d78 matrix of unsigned 8-bit integer values held in each  128-bit segment of the first source vector by the 8\u00d72 matrix of signed 8-bit  integer values in the corresponding segment of the second source vector. The  resulting 2\u00d72 widened 32-bit integer matrix product is then destructively  added to the 32-bit integer matrix accumulator held in the corresponding  segment of the addend and destination vector. This is equivalent to performing  an 8-way dot product per destination element. \n\nThis instruction is unpredicated. \n\nID_AA64ZFR0_EL1.I8MM indicates whether this instruction is implemented.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zda>": "Is the name of the third source and destination scalable vector register, encoded in the \"Zda\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["USMMLA  <Zda>.S, <Zn>.B, <Zm>.B"]}, {"id": 1167, "asmtemplate": "ADD     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Add vectors (unpredicated)", "heading": "ADD (vectors, unpredicated)", "para": "Add vectors (unpredicated). \n\nAdd all elements of the second source vector to corresponding elements of the  first source vector and place the results in the corresponding elements of the  destination vector. This instruction is unpredicated.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["ADD     <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 1018, "asmtemplate": "DRPS", "brief": "Debug restore process state", "heading": "DRPS", "para": "Debug restore process state.", "explanations": {}, "encodings": ["DRPS"]}, {"id": 1011, "asmtemplate": "ADCS  <Xd>, <Xn>, <Xm>", "brief": "Add with Carry, setting flags", "heading": "ADCS", "para": "Add with Carry, setting flags, adds two register values and the Carry flag  value, and writes the result to the destination register. It updates the  condition flags based on the result.", "explanations": {"<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ADCS  <Wd>, <Wn>, <Wm>"]}, {"id": 710, "asmtemplate": "EON  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Bitwise Exclusive OR NOT (shifted register)", "heading": "EON (shifted register)", "para": "Bitwise Exclusive OR NOT (shifted register) performs a bitwise Exclusive OR  NOT of a register value and an optionally-shifted register value, and writes  the result to the destination register.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["EON  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 958, "asmtemplate": "LDSMAXL<Xs>, XZR, [<Xn|SP>]", "brief": "Atomic signed maximum on word or doubleword in memory, without return", "heading": "STSMAX, STSMAXL", "para": "Atomic signed maximum on word or doubleword in memory, without return,  atomically loads a 32-bit word or 64-bit doubleword from memory, compares it  against the value held in a register, and stores the larger value back to  memory, treating the values as signed numbers.  \n* STSMAX does not have release semantics. \n* STSMAXL stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL. \n* The description of LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL gives the operational \n  pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSMAX  <Ws>, [<Xn|SP>]"]}, {"id": 66, "asmtemplate": "LSRV  <Xd>, <Xn>, <Xm>", "brief": "Logical Shift Right Variable", "heading": "LSRV", "para": "Logical Shift Right Variable shifts a register value right by a variable  number of bits, shifting in zeros, and writes the result to the destination  register. The remainder obtained by dividing the second source register by the  data size defines the number of bits by which the first source register is  right-shifted. \n\nThis instruction is used by the alias LSR (register).", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["LSRV  <Wd>, <Wn>, <Wm>"]}, {"id": 707, "asmtemplate": "BICS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise clear predicates", "heading": "BIC, BICS (predicates)", "para": "Bitwise clear predicates. \n\nBitwise AND inverted active elements of the second source predicate with  corresponding elements of the first source predicate and place the results in  the corresponding elements of the destination predicate. Inactive elements in  the destination predicate register are set to zero. Optionally sets the First \n(N), None (Z), !Last (C) condition flags based on the predicate result, and  the V flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["BIC     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "BICS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 227, "asmtemplate": "FABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point absolute difference (predicated)", "heading": "FABD", "para": "Floating-point absolute difference (predicated). \n\nCompute the absolute difference of active floating-point elements of the  second source vector and corresponding floating-point elements of the first  source vector and destructively place the result in the corresponding elements  of the first source vector. Inactive elements in the destination vector  register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FABD    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 510, "asmtemplate": "SUBG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>", "brief": "Subtract with Tag", "heading": "SUBG", "para": "Subtract with Tag subtracts an immediate value scaled by the Tag granule from  the address in the source register, modifies the Logical Address Tag of the  address using an immediate value, and writes the result to the destination  register. Tags specified in GCR_EL1.Exclude are excluded from the possible  outputs when modifying the Logical Address Tag.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Xn\" field.", "<uimm4>": "Is an unsigned immediate, in the range 0 to 15, encoded in the \"uimm4\" field.", "<uimm6>": "Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the \"uimm6\" field.", "<Xd|SP>": "Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the \"Xd\" field."}, "encodings": ["SUBG  <Xd|SP>, <Xn|SP>, #<uimm6>, #<uimm4>"]}, {"id": 931, "asmtemplate": "ST1W    {<Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]", "brief": "Scatter store words from a vector (vector index)", "heading": "ST1W (scalar plus vector)", "para": "Scatter store words from a vector (vector index). \n\nScatter store of words from the active elements of a vector register to the  memory addresses generated by a 64-bit scalar base plus vector index. The  index values are optionally first sign or zero-extended from 32 to 64 bits and  then optionally multiplied by 4. Inactive elements are not written to memory. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["ST1W    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod> #2]", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod> #2]", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, <mod>]", "ST1W    { <Zt>.S }, <Pg>, [<Xn|SP>, <Zm>.S, <mod>]", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D, LSL #2]", "ST1W    { <Zt>.D }, <Pg>, [<Xn|SP>, <Zm>.D]"]}, {"id": 548, "asmtemplate": "BIC     <Zd>.D, <Zn>.D, <Zm>.D", "brief": "Bitwise clear vectors (unpredicated)", "heading": "BIC (vectors, unpredicated)", "para": "Bitwise clear vectors (unpredicated). \n\nBitwise AND inverted all elements of the second source vector with  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. This instruction is  unpredicated.", "explanations": {"<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["BIC     <Zd>.D, <Zn>.D, <Zm>.D"]}, {"id": 1048, "asmtemplate": "UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Unzip vectors (primary)", "heading": "UZP1", "para": "Unzip vectors (primary). This instruction reads corresponding even-numbered  vector elements from the two source SIMD&FP registers, starting at zero,  places the result from the first source register into consecutive elements in  the lower half of a vector, and the result from the second source register  into consecutive elements in the upper half of a vector, and writes the vector  to the destination SIMD&FP register. \n\nThis instruction can be used with UZP2 to de-interleave two vectors. \n\nThe following figure shows an example of the operation of UZP1 and UZP2 with  the arrangement specifier 8B. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["UZP1  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 234, "asmtemplate": "LASTB   <V><d>, <Pg>, <Zn>.<T>", "brief": "Extract last element to SIMD&FP scalar register", "heading": "LASTB (SIMD&FP scalar)", "para": "Extract last element to SIMD&FP scalar register. \n\nIf there is an active element then extract the last active element from the  final source vector register. If there are no active elements, extract the  highest-numbered element. Then place the extracted element in the destination  SIMD&FP register.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["LASTB   <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 576, "asmtemplate": "SUBS  <Xd>, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Subtract (shifted register), setting flags", "heading": "SUBS (shifted register)", "para": "Subtract (shifted register), setting flags, subtracts an optionally-shifted  register value from a register value, and writes the result to the destination  register. It updates the condition flags based on the result. \n\nThis instruction is used by the aliases CMP (shifted register), and NEGS.", "explanations": {"<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SUBS  <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 58, "asmtemplate": "CLZ  <Vd>.<T>, <Vn>.<T>", "brief": "Count Leading Zero bits (vector)", "heading": "CLZ (vector)", "para": "Count Leading Zero bits (vector). This instruction counts the number of  consecutive zeros, starting from the most significant bit, in each vector  element in the source SIMD&FP register, places the result into a vector, and  writes the vector to the destination SIMD&FP register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["CLZ  <Vd>.<T>, <Vn>.<T>"]}, {"id": 916, "asmtemplate": "BFMLAL<bt><Vd>.4S, <Vn>.8H, <Vm>.H[<index>]", "brief": "BFloat16 floating-point widening multiply-add long (by element)", "heading": "BFMLALB, BFMLALT (by element)", "para": "BFloat16 floating-point widening multiply-add long (by element) widens the  even-numbered (bottom) or odd-numbered (top) 16-bit elements in the first  source vector, and the indexed element in the second source vector from  Bfloat16 to single-precision format. The instruction then multiplies and adds  these values to the overlapping single-precision elements of the destination  vector. \n\nThis performs a fused multiply-add without intermediate rounding that honors  all of the control bits in the FPCR that apply to single-precision arithmetic,  including the rounding mode. It can also generate a floating-point exception  that causes cumulative exception bits in the FPSR to be set, or a synchronous  exception to be taken, depending on the enable bits in the FPCR.  ID_AA64ISAR1_EL1.BF16 indicates whether this instruction is supported.", "explanations": {"": "FP source register, in the range V0 to V15, encoded in the \"Rm\" field.", "<index>": "Is the element index, in the range 0 to 7, encoded in the \"H:L:M\" fields.", "<Vm>": "Is the name of the second SIMD", "<Vn>": "Is the name of the first SIMD", "<bt><Vd>": "Is the name of the SIMD"}, "encodings": ["BFMLAL<bt>  <Vd>.4S, <Vn>.8H, <Vm>.H[<index>]"]}, {"id": 967, "asmtemplate": "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point fused Multiply-Subtract from accumulator (vector)", "heading": "FMLS (vector)", "para": "Floating-point fused Multiply-Subtract from accumulator (vector). This  instruction multiplies corresponding floating-point values in the vectors in  the two source SIMD&FP registers, negates the product, adds the result to the  corresponding vector element of the destination SIMD&FP register, and writes  the result to the destination SIMD&FP register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FMLS  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1112, "asmtemplate": "SWPL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Swap word or doubleword in memory", "heading": "SWP, SWPA, SWPAL, SWPL", "para": "Swap word or doubleword in memory atomically loads a 32-bit word or 64-bit  doubleword from a memory location, and stores the value held in a register  back to the same memory location. The value initially loaded from memory is  returned in the destination register.  \n* If the destination register is not one of WZR or XZR, SWPA and SWPAL load \n  from memory with acquire semantics. \n* SWPL and SWPAL store to memory with release semantics. \n* SWP has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["SWP  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 1161, "asmtemplate": "UMSUBL<Xd>, <Wn>, <Wm>, XZR", "brief": "Unsigned Multiply-Negate Long", "heading": "UMNEGL", "para": "Unsigned Multiply-Negate Long multiplies two 32-bit register values, negates  the product, and writes the result to the 64-bit destination register. \n\nThis is an alias of UMSUBL. This means:  \n* The encodings in this description are named to match the encodings of \n  UMSUBL. \n* The description of UMSUBL gives the operational pseudocode for this \n  instruction.", "explanations": {"<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field."}, "encodings": ["UMNEGL  <Xd>, <Wn>, <Wm>"]}, {"id": 879, "asmtemplate": "FNMSB   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>", "brief": "Floating-point negated fused multiply-subtract vectors (predicated), writing multiplicand [Zdn = -Za + Zdn * Zm]", "heading": "FNMSB", "para": "Floating-point negated fused multiply-subtract vectors (predicated), writing  multiplicand [Zdn = -Za + Zdn * Zm]. \n\nMultiply the corresponding active floating-point elements of the first and  second source vectors and subtract from elements of the third (addend) vector  without intermediate rounding. Destructively place the negated results in the  destination and first source (multiplicand) vector. Inactive elements in the  destination vector register remain unmodified.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Za>": "Is the name of the third source scalable vector register, encoded in the \"Za\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field."}, "encodings": ["FNMSB   <Zdn>.<T>, <Pg>/M, <Zm>.<T>, <Za>.<T>"]}, {"id": 533, "asmtemplate": "LDSMAXLH<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic signed maximum on halfword in memory, without return", "heading": "STSMAXH, STSMAXLH", "para": "Atomic signed maximum on halfword in memory, without return, atomically loads  a 16-bit halfword from memory, compares it against the value held in a  register, and stores the larger value back to memory, treating the values as  signed numbers.  \n* STSMAXH does not have release semantics. \n* STSMAXLH stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH. This means:  \n* The encodings in this description are named to match the encodings of \n  LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH. \n* The description of LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STSMAXH  <Ws>, [<Xn|SP>]"]}, {"id": 261, "asmtemplate": "ST1  {<Vt>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Store a single-element structure from one lane of one register", "heading": "ST1 (single structure)", "para": "Store a single-element structure from one lane of one register. This  instruction stores the specified element of a SIMD&FP register to memory. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "\".", "<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["ST1  { <Vt>.B }[<index>], [<Xn|SP>]", "ST1  { <Vt>.B }[<index>], [<Xn|SP>], #1"]}, {"id": 797, "asmtemplate": "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Floating-point fused Multiply-Subtract Long from accumulator (vector)", "heading": "FMLSL, FMLSL2 (vector)", "para": "Floating-point fused Multiply-Subtract Long from accumulator (vector). This  instruction negates the values in the vector of one SIMD&FP register,  multiplies these with the corresponding values in another vector, and  accumulates the product to the corresponding vector element of the destination  SIMD&FP register. The instruction does not round the result of the multiply  before the accumulation. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIn Armv8.2 and Armv8.3, this is an optional instruction. From Armv8.4 it is  mandatory for all implementations to support it. \n\nID_AA64ISAR0_EL1.FHM indicates whether this instruction is supported. \n\nIt has encodings from 2 classes: FMLSL and FMLSL2", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["FMLSL  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "FMLSL2  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 564, "asmtemplate": "MSR  <pstatefield>, #<imm>", "brief": "Move immediate value to Special Register", "heading": "MSR (immediate)", "para": "Move immediate value to Special Register moves an immediate value to selected  bits of the PSTATE. For more information, see Process state, PSTATE. \n\nThe bits that can be written by this instruction are:  \n* PSTATE.D, PSTATE.A, PSTATE.I, PSTATE.F, and PSTATE.SP. \n* If FEAT_SSBS is implemented, PSTATE.SSBS. \n* If FEAT_PAN is implemented, PSTATE.PAN. \n* If FEAT_UAO is implemented, PSTATE.UAO. \n* If FEAT_DIT is implemented, PSTATE.DIT. \n* If FEAT_MTE is implemented, PSTATE.TCO.", "explanations": {"<pstatefield><imm>": "Is a 4-bit unsigned immediate, in the range 0 to 15, encoded in the \"CRm\" field."}, "encodings": ["MSR  <pstatefield>, #<imm>"]}, {"id": 1062, "asmtemplate": "LD1RSW  {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]", "brief": "Load and broadcast signed word to vector", "heading": "LD1RSW", "para": "Load and broadcast signed word to vector. \n\nLoad a single signed word from a memory address generated by a 64-bit scalar  base address plus an immediate offset which is a multiple of 4 in the range 0  to 252. \n\nBroadcast the loaded data into all active elements of the destination vector,  setting the inactive elements to zero. If all elements are inactive then the  instruction will not perform a read from Device memory or cause a data abort.", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 252, defaulting to 0, encoded in the \"imm6\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1RSW  { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>}]"]}, {"id": 654, "asmtemplate": "BRAB  <Xn>, <Xm|SP>", "brief": "Branch to Register, with pointer authentication", "heading": "BRAA, BRAAZ, BRAB, BRABZ", "para": "Branch to Register, with pointer authentication. This instruction  authenticates the address in the general-purpose register that is specified by \n<Xn>, using a modifier and the specified key, and branches to the  authenticated address. \n\nThe modifier is:  \n* In the general-purpose register or stack pointer that is specified by \n  <Xm|SP> for BRAA and BRAB. \n* The value zero, for BRAAZ and BRABZ.  Key A is used for BRAA and BRAAZ, and key B is used for BRAB and BRABZ. \n\nIf the authentication passes, the PE continues execution at the target of the  branch. If the authentication fails, a Translation fault is generated. \n\nThe authenticated address is not written back to the general-purpose register.", "explanations": {"<Xm|SP>": "Is the 64-bit name of the general-purpose source register or stack pointer holding the modifier, encoded in the \"Rm\" field.", "<Xn>": "Is the 64-bit name of the general-purpose register holding the address to be branched to, encoded in the \"Rn\" field."}, "encodings": ["BRAAZ  <Xn>"]}, {"id": 60, "asmtemplate": "B.<cond><label>", "brief": "Branch conditionally", "heading": "B.cond", "para": "Branch conditionally to a label at a PC-relative offset, with a hint that this  is not a subroutine call or return.", "explanations": {"<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<label>": "Is the program label to be conditionally branched to. Its offset from the address of this instruction, in the range +/-1MB, is encoded as \"imm19\" times 4."}, "encodings": ["B.<cond>  <label>"]}, {"id": 1232, "asmtemplate": "LD1ROH  {<Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]", "brief": "Contiguous load and replicate sixteen halfwords (scalar index)", "heading": "LD1ROH (scalar plus scalar)", "para": "Contiguous load and replicate sixteen halfwords (scalar index). \n\nLoad sixteen contiguous halfwords to elements of a 256-bit (octaword) vector  from the memory address generated by a 64-bit scalar base address and scalar  index which is multiplied by 2 and added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. \n\nThe resulting 256-bit vector is then replicated to fill the destination  vector. The instruction requires that the current vector length is at least  256 bits, and if the current vector length is not an integer multiple of 256  bits then the trailing bits in the destination vector are set to zero. \n\nOnly the first sixteen predicate elements are used and higher numbered  predicate elements are ignored. \n\nID_AA64ZFR0_EL1.F64MM indicates whether this instruction is implemented.", "explanations": {"<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1ROH  { <Zt>.H }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #1]"]}, {"id": 588, "asmtemplate": "ORNS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "brief": "Bitwise inclusive OR inverted predicate", "heading": "ORN, ORNS (predicates)", "para": "Bitwise inclusive OR inverted predicate. \n\nBitwise inclusive OR inverted active elements of the second source predicate  with corresponding elements of the first source predicate and place the  results in the corresponding elements of the destination predicate. Inactive  elements in the destination predicate register are set to zero. Optionally  sets the First (N), None (Z), !Last (C) condition flags based on the predicate  result, and the V flag to zero. \n\nIt has encodings from 2 classes: Not setting the condition flags and Setting  the condition flags", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["ORN     <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B", "ORNS    <Pd>.B, <Pg>/Z, <Pn>.B, <Pm>.B"]}, {"id": 1180, "asmtemplate": "FRINTX  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Round to Integral exact, using current rounding mode (vector)", "heading": "FRINTX (vector)", "para": "Floating-point Round to Integral exact, using current rounding mode (vector).  This instruction rounds a vector of floating-point values in the SIMD&FP  source register to integral floating-point values of the same size using the  rounding mode that is determined by the FPCR, and writes the result to the  SIMD&FP destination register. \n\nWhen a result value is not numerically equal to the corresponding input value,  an Inexact exception is raised. A zero input gives a zero result with the same  sign, an infinite input gives an infinite result with the same sign, and a NaN  is propagated as for normal arithmetic. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"<Vd>": "Is the name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["FRINTX  <Vd>.<T>, <Vn>.<T>", "FRINTX  <Vd>.<T>, <Vn>.<T>"]}, {"id": 193, "asmtemplate": "SWPLB  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Swap byte in memory", "heading": "SWPB, SWPAB, SWPALB, SWPLB", "para": "Swap byte in memory atomically loads an 8-bit byte from a memory location, and  stores the value held in a register back to the same memory location. The  value initially loaded from memory is returned in the destination register.  \n* If the destination register is not WZR, SWPAB and SWPALB load from memory \n  with acquire semantics. \n* SWPLB and SWPALB store to memory with release semantics. \n* SWPB has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register to be stored, encoded in the \"Rs\" field."}, "encodings": ["SWPAB  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 634, "asmtemplate": "UMULL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Unsigned Multiply Long (vector, by element)", "heading": "UMULL, UMULL2 (by element)", "para": "Unsigned Multiply Long (vector, by element). This instruction multiplies each  vector element in the lower or upper half of the first source SIMD&FP register  by the specified vector element of the second source SIMD&FP register, places  the results in a vector, and writes the vector to the destination SIMD&FP  register. The destination vector elements are twice as long as the elements  that are multiplied. \n\nThe UMULL instruction extracts vector elements from the lower half of the  first source register, while the UMULL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["UMULL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 268, "asmtemplate": "UQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating decrement vector by multiple of 16-bit predicate constraint element count", "heading": "UQDECH (vector)", "para": "Unsigned saturating decrement vector by multiple of 16-bit predicate  constraint element count. \n\nDetermines the number of active 16-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to decrement all destination vector elements. The  results are saturated to the 16-bit unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception.", "explanations": {"<Zdn>": "Is the name of the source and destination scalable vector register, encoded in the \"Zdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQDECH  <Zdn>.H{, <pattern>{, MUL #<imm>}}"]}, {"id": 23, "asmtemplate": "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Add Pairwise (vector)", "heading": "FADDP (vector)", "para": "Floating-point Add Pairwise (vector). This instruction creates a vector by  concatenating the vector elements of the first source SIMD&FP register after  the vector elements of the second source SIMD&FP register, reads each pair of  adjacent vector elements from the concatenated vector, adds each pair of  values together, places the result into a vector, and writes the vector to the  destination SIMD&FP register. All the values in this instruction are  floating-point values. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Half-precision and Single-precision and  double-precision", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FADDP  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 890, "asmtemplate": "LDFF1H  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]", "brief": "Gather load first-fault unsigned halfwords to vector (vector index)", "heading": "LDFF1H (scalar plus vector)", "para": "Gather load first-fault unsigned halfwords to vector (vector index). \n\nGather load with first-faulting behavior of unsigned halfwords to active  elements of a vector register from memory addresses generated by a 64-bit  scalar base plus vector index. The index values are optionally first sign or  zero-extended from 32 to 64 bits and then optionally multiplied by 2. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector. \n\nIt has encodings from 6 classes: 32-bit scaled offset , 32-bit unpacked scaled  offset , 32-bit unpacked unscaled offset , 32-bit unscaled offset , 64-bit  scaled offset and 64-bit unscaled offset", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the offset scalable vector register, encoded in the \"Zm\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod> #1]", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod> #1]", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, <mod>]", "LDFF1H  { <Zt>.S }, <Pg>/Z, [<Xn|SP>, <Zm>.S, <mod>]", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D, LSL #1]", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Zm>.D]"]}, {"id": 649, "asmtemplate": "FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point maximum number (predicated)", "heading": "FMAXNM (vectors)", "para": "Floating-point maximum number (predicated). \n\nDetermine the maximum number value of active floating-point elements of the  second source vector and corresponding floating-point elements of the first  source vector and destructively place the results in the corresponding  elements of the first source vector. If one element value is NaN then the  result is the numeric value. Inactive elements in the destination vector  register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMAXNM  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 25, "asmtemplate": "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]", "brief": "Store Register Byte (immediate)", "heading": "STRB (immediate)", "para": "Store Register Byte (immediate) stores the least significant byte of a 32-bit  register to memory. The address that is used for the store is calculated from  a base register and an immediate offset. For information about memory  accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Unsigned offset", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the signed immediate byte offset, in the range -256 to 255, encoded in the \"imm9\" field.", "<pimm>": "Is the optional positive immediate byte offset, in the range 0 to 4095, defaulting to 0 and encoded in the \"imm12\" field."}, "encodings": ["STRB  <Wt>, [<Xn|SP>], #<simm>", "STRB  <Wt>, [<Xn|SP>, #<simm>]!", "STRB  <Wt>, [<Xn|SP>{, #<pimm>}]"]}, {"id": 874, "asmtemplate": "INCP    <Xdn>, <Pm>.<T>", "brief": "Increment scalar by count of true predicate elements", "heading": "INCP (scalar)", "para": "Increment scalar by count of true predicate elements. \n\nCounts the number of true elements in the source predicate and then uses the  result to increment the scalar destination.", "explanations": {"<Pm>": "Is the name of the source scalable predicate register, encoded in the \"Pm\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field."}, "encodings": ["INCP    <Xdn>, <Pm>.<T>"]}, {"id": 1188, "asmtemplate": "FCCMP  <Dn>, <Dm>, #<nzcv>, <cond>", "brief": "Floating-point Conditional quiet Compare (scalar)", "heading": "FCCMP", "para": "Floating-point Conditional quiet Compare (scalar). This instruction compares  the two SIMD&FP source register values and writes the result to the PSTATE.{N,  Z, C, V} flags. If the condition does not pass then the PSTATE.{N, Z, C, V}  flags are set to the flag bit specifier. \n\nThis instruction raises an Invalid Operation floating-point exception if  either or both of the operands is a signaling NaN. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<nzcv>": "Is the flag bit specifier, an immediate in the range 0 to 15, giving the alternative state for the 4-bit NZCV condition flags, encoded in the \"nzcv\" field.", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<cond>": "Is one of the standard conditions, encoded in the \"cond\" field in the standard way.", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FCCMP  <Hn>, <Hm>, #<nzcv>, <cond>"]}, {"id": 898, "asmtemplate": "ANDV    <V><d>, <Pg>, <Zn>.<T>", "brief": "Bitwise AND reduction to scalar", "heading": "ANDV", "para": "Bitwise AND reduction to scalar. \n\nBitwise AND horizontally across all lanes of a vector, and place the result in  the SIMD&FP scalar destination register. Inactive elements in the source  vector are treated as all ones.", "explanations": {"": "FP register, encoded in the \"Vd\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<V><d>": "Is the number [0-31] of the destination SIMD"}, "encodings": ["ANDV    <V><d>, <Pg>, <Zn>.<T>"]}, {"id": 1045, "asmtemplate": "LDFF1W  {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault unsigned words to vector (immediate index)", "heading": "LDFF1W (vector plus immediate)", "para": "Gather load first-fault unsigned words to vector (immediate index). \n\nGather load with first-faulting behavior of unsigned words to active elements  of a vector register from memory addresses generated by a vector base plus  immediate index. The index is a multiple of 4 in the range 0 to 124. Inactive  elements will not cause a read from Device memory or signal faults, and are  set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field."}, "encodings": ["LDFF1W  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LDFF1W  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 444, "asmtemplate": "FCVTPS  <Vd>.<T>, <Vn>.<T>", "brief": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector)", "heading": "FCVTPS (vector)", "para": "Floating-point Convert to Signed integer, rounding toward Plus infinity \n(vector). This instruction converts a scalar or each element in a vector from  a floating-point value to a signed integer value using the Round towards Plus  Infinity rounding mode, and writes the result to the SIMD&FP destination  register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTPS  <Hd>, <Hn>", "FCVTPS  <V><d>, <V><n>", "FCVTPS  <Vd>.<T>, <Vn>.<T>", "FCVTPS  <Vd>.<T>, <Vn>.<T>"]}, {"id": 1071, "asmtemplate": "FCVTAS  <Xd>, <Dn>", "brief": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar)", "heading": "FCVTAS (scalar)", "para": "Floating-point Convert to Signed integer, rounding to nearest with ties to  Away (scalar). This instruction converts the floating-point value in the  SIMD&FP source register to a 32-bit or 64-bit signed integer using the Round  to Nearest with Ties to Away rounding mode, and writes the result to the  general-purpose destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Dn>": "Is the 64-bit name of the SIMD", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["FCVTAS  <Wd>, <Hn>"]}, {"id": 366, "asmtemplate": "SEL     <Pd>.B, <Pg>, <Pn>.B, <Pm>.B", "brief": "Conditionally select elements from two predicates", "heading": "SEL (predicates)", "para": "Conditionally select elements from two predicates. \n\nRead active elements from the first source predicate and inactive elements  from the second source predicate and place in the corresponding elements of  the destination predicate. Does not set the condition flags. \n\nThis instruction is used by the alias MOV (predicate, predicated, merging).", "explanations": {"<Pm>": "Is the name of the second source scalable predicate register, encoded in the \"Pm\" field.", "<Pg>": "Is the name of the governing scalable predicate register, encoded in the \"Pg\" field.", "<Pn>": "Is the name of the first source scalable predicate register, encoded in the \"Pn\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["SEL     <Pd>.B, <Pg>, <Pn>.B, <Pm>.B"]}, {"id": 1091, "asmtemplate": "ST1H    {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Scatter store halfwords from a vector (immediate index)", "heading": "ST1H (vector plus immediate)", "para": "Scatter store halfwords from a vector (immediate index). \n\nScatter store of halfwords from the active elements of a vector register to  the memory addresses generated by a vector base plus immediate index. The  index is a multiple of 2 in the range 0 to 62. Inactive elements are not  written to memory. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["ST1H    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]", "ST1H    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 884, "asmtemplate": "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed saturating Rounding Doubling Multiply returning High half", "heading": "SQRDMULH (vector)", "para": "Signed saturating Rounding Doubling Multiply returning High half. This  instruction multiplies the values of corresponding elements of the two source  SIMD&FP registers, doubles the results, places the most significant half of  the final results into a vector, and writes the vector to the destination  SIMD&FP register. \n\nThe results are rounded. For truncated results, see SQDMULH. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQRDMULH  <V><d>, <V><n>, <V><m>", "SQRDMULH  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 1083, "asmtemplate": "USUBW{2}<Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>", "brief": "Unsigned Subtract Wide", "heading": "USUBW, USUBW2", "para": "Unsigned Subtract Wide. This instruction subtracts each vector element of the  second source SIMD&FP register from the corresponding vector element in the  lower or upper half of the first source SIMD&FP register, places the result in  a vector, and writes the vector to the SIMD&FP destination register. All the  values in this instruction are signed integer values. \n\nThe vector elements of the destination register and the first source register  are twice as long as the vector elements of the second source register. \n\nThe USUBW instruction extracts vector elements from the lower half of the  first source register, while the USUBW2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["USUBW{2}  <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"]}, {"id": 1196, "asmtemplate": "WHILELO <Pd>.<T>, <R><n>, <R><m>", "brief": "While incrementing unsigned scalar lower than scalar", "heading": "WHILELO", "para": "While incrementing unsigned scalar lower than scalar. \n\nGenerate a predicate that starting from the lowest numbered element is true  while the incrementing value of the first, unsigned scalar operand is lower  than the second scalar operand and false thereafter up to the highest numbered  element. \n\n \n\nThe full width of the scalar operands is significant for the purposes of  comparison, and the full width first operand is incremented by one for each  destination predicate element, irrespective of the predicate result element  size. The first general-purpose source register is not itself updated. \n\nThe predicate result is placed in the predicate destination register. Sets the  First (N), None (Z), !Last (C) condition flags based on the predicate result,  and the V flag to zero.", "explanations": {"<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field.", "<m>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rm\" field.", "<T><R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field."}, "encodings": ["WHILELO <Pd>.<T>, <R><n>, <R><m>"]}, {"id": 237, "asmtemplate": "YIELD", "brief": "YIELD", "heading": "YIELD", "para": "YIELD is a hint instruction. Software with a multithreading capability can use  a YIELD instruction to indicate to the PE that it is performing a task, for  example a spin-lock, that could be swapped out to improve overall system  performance. The PE can use this hint to suspend and resume multiple software  threads if it supports the capability. \n\nFor more information about the recommended use of this instruction, see The  YIELD instruction.", "explanations": {}, "encodings": ["YIELD"]}, {"id": 208, "asmtemplate": "LDNT1B  {<Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load non-temporal bytes to vector (immediate index)", "heading": "LDNT1B (scalar plus immediate)", "para": "Contiguous load non-temporal bytes to vector (immediate index). \n\nContiguous load non-temporal of bytes to elements of a vector register from  the memory address generated by a 64-bit scalar base and immediate index in  the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  will not not cause a read from Device memory or signal a fault, and are set to  zero in the destination vector. \n\nA non-temporal load is a hint to the system that this data is unlikely to be  referenced again soon.", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LDNT1B  { <Zt>.B }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 323, "asmtemplate": "SQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment scalar by multiple of 8-bit predicate constraint element count", "heading": "SQINCB", "para": "Signed saturating increment scalar by multiple of 8-bit predicate constraint  element count. \n\nDetermines the number of active 8-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCB  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQINCB  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 87, "asmtemplate": "EOR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Bitwise exclusive OR vectors (predicated)", "heading": "EOR (vectors, predicated)", "para": "Bitwise exclusive OR vectors (predicated). \n\nBitwise exclusive OR active elements of the second source vector with  corresponding elements of the first source vector and destructively place the  results in the corresponding elements of the first source vector. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["EOR     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 754, "asmtemplate": "LDTR  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load Register (unprivileged)", "heading": "LDTR", "para": "Load Register (unprivileged) loads a word or doubleword from memory, and  writes it to a register. The address that is used for the load is calculated  from a base register and an immediate offset. \n\nMemory accesses made by the instruction behave as if the instruction was  executed at EL0 if the Effective value of PSTATE.UAO is 0 and either:  \n* The instruction is executed at EL1. \n* The instruction is executed at EL2 when the Effective value of HCR_EL2.{E2H, \n  TGE} is {1, 1}.  Otherwise, the memory access operates with the restrictions determined by the  Exception level at which the instruction is executed. For information about  memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDTR  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 233, "asmtemplate": "SM4E  <Vd>.4S, <Vn>.4S", "brief": "SM4 Encode", "heading": "SM4E", "para": "SM4 Encode takes input data as a 128-bit vector from the first source SIMD&FP  register, and four iterations of the round key held as the elements of the  128-bit vector in the second source SIMD&FP register. It encrypts the data by  four rounds, in accordance with the SM4 standard, returning the 128-bit result  to the destination SIMD&FP register. \n\nThis instruction is implemented only when FEAT_SM4 is implemented.", "explanations": {"<Vd>": "Is the name of the SIMD", "<Vn>": "Is the name of the second SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["SM4E  <Vd>.4S, <Vn>.4S"]}, {"id": 488, "asmtemplate": "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Floating-point Compare Greater than (vector)", "heading": "FCMGT (register)", "para": "Floating-point Compare Greater than (vector). This instruction reads each  floating-point value in the first source SIMD&FP register and if the value is  greater than the corresponding floating-point value in the second source  SIMD&FP register sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><T><Vn>": "Is the name of the first SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["FCMGT  <Hd>, <Hn>, <Hm>", "FCMGT  <V><d>, <V><n>, <V><m>", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "FCMGT  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 595, "asmtemplate": "SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>", "brief": "Signed Multiply-Subtract Long", "heading": "SMSUBL", "para": "Signed Multiply-Subtract Long multiplies two 32-bit register values, subtracts  the product from a 64-bit register value, and writes the result to the 64-bit  destination register. \n\nThis instruction is used by the alias SMNEGL.", "explanations": {"<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xa>": "Is the 64-bit name of the third general-purpose source register holding the minuend, encoded in the \"Ra\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["SMSUBL  <Xd>, <Wn>, <Wm>, <Xa>"]}, {"id": 225, "asmtemplate": "ST2  {<Vt>.<T>, <Vt2>.<T>}, [<Xn|SP>], <Xm>", "brief": "Store multiple 2-element structures from two registers", "heading": "ST2 (multiple structures)", "para": "Store multiple 2-element structures from two registers. This instruction  stores multiple 2-element structures from two SIMD&FP registers to memory,  with interleaving. Every element of each register is stored. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "FP register to be transferred, encoded as \"Rt\" plus 1 modulo 32.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt>": "Is the name of the first or only SIMD", "<T><Vt2>": "Is the name of the second SIMD", "<imm><Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field."}, "encodings": ["ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]", "ST2  { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"]}, {"id": 1193, "asmtemplate": "CLASTB  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>", "brief": "Conditionally extract last element to general-purpose register", "heading": "CLASTB (scalar)", "para": "Conditionally extract last element to general-purpose register. \n\nFrom the source vector register extract the last active element, and then  zero-extend that element to destructively place in the destination and first  source general-purpose register. If there are no active elements then  destructively zero-extend the least significant element-size bits of the  destination and first source general-purpose register.", "explanations": {"<R><dn>": "Is the number [0-30] of the source and destination general-purpose register or the name ZR (31), encoded in the \"Rdn\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["CLASTB  <R><dn>, <Pg>, <R><dn>, <Zm>.<T>"]}, {"id": 1234, "asmtemplate": "LD1RQD  {<Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]", "brief": "Contiguous load and replicate two doublewords (scalar index)", "heading": "LD1RQD (scalar plus scalar)", "para": "Contiguous load and replicate two doublewords (scalar index). \n\nLoad two contiguous doublewords to elements of a short, 128-bit (quadword)  vector from the memory address generated by a 64-bit scalar base address and  scalar index which is multiplied by 8 and added to the base address. \n\nInactive elements will not cause a read from Device memory or signal a fault,  and are set to zero. The resulting short vector is then replicated to fill the  long destination vector. Only the first two predicate elements are used and  higher numbered predicate elements are ignored.", "explanations": {"<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the general-purpose offset register, encoded in the \"Rm\" field."}, "encodings": ["LD1RQD  { <Zt>.D }, <Pg>/Z, [<Xn|SP>, <Xm>, LSL #3]"]}, {"id": 194, "asmtemplate": "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", "brief": "Load Pair of Registers Signed Word", "heading": "LDPSW", "para": "Load Pair of Registers Signed Word calculates an address from a base register  value and an immediate offset, loads two 32-bit words from memory,  sign-extends them, and writes them to two registers. For information about  memory accesses, see Load/Store addressing modes. \n\nIt has encodings from 3 classes: Post-index , Pre-index and Signed offset", "explanations": {"<imm>": "For the signed offset variant: is the optional signed immediate byte offset, a multiple of 4 in the range -256 to 252, defaulting to 0 and encoded in the \"imm7\" field as ", "": "/4.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDPSW  <Xt1>, <Xt2>, [<Xn|SP>], #<imm>", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!", "LDPSW  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 228, "asmtemplate": "FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point reversed subtract vectors (predicated)", "heading": "FSUBR (vectors)", "para": "Floating-point reversed subtract vectors (predicated). \n\nReversed subtract active floating-point elements of the first source vector  from corresponding floating-point elements of the second source vector and  destructively place the results in the corresponding elements of the first  source vector. Inactive elements in the destination vector register remain  unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FSUBR   <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 348, "asmtemplate": "FADD  <Dd>, <Dn>, <Dm>", "brief": "Floating-point Add (scalar)", "heading": "FADD (scalar)", "para": "Floating-point Add (scalar). This instruction adds the floating-point values  of the two source SIMD&FP registers, and writes the result to the destination  SIMD&FP register. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Hm>": "Is the 16-bit name of the second SIMD", "<Hn>": "Is the 16-bit name of the first SIMD", "<Dn>": "Is the 64-bit name of the first SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sm>": "Is the 32-bit name of the second SIMD", "<Sn>": "Is the 32-bit name of the first SIMD", "<Sd>": "Is the 32-bit name of the SIMD", "<Dm>": "Is the 64-bit name of the second SIMD"}, "encodings": ["FADD  <Hd>, <Hn>, <Hm>"]}, {"id": 369, "asmtemplate": "FTSMUL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point trigonometric starting value", "heading": "FTSMUL", "para": "Floating-point trigonometric starting value. \n\nThe FTSMUL instruction calculates the initial value for the FTMAD instruction.  The instruction squares each element in the first source vector and then sets  the sign bit to a copy of bit 0 of the corresponding element in the second  source register, and places the results in the destination vector. This  instruction is unpredicated. \n\nTo compute sin(x) or cos(x) the instruction is executed with elements of the  first source vector set to x, adjusted to be in the range -\u03c0/4 < x \u2264 \u03c0/4. \n\nThe elements of the second source vector hold the corresponding value of the  quadrant q number as an integer not a floating-point value. The value q  satisfies the relationship (2q-1) \u00d7 \u03c0/4 < x \u2264 (2q+1) \u00d7 \u03c0/4.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FTSMUL  <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 954, "asmtemplate": "LD1H    {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load unsigned halfwords to vector (immediate index)", "heading": "LD1H (scalar plus immediate)", "para": "Contiguous load unsigned halfwords to vector (immediate index). \n\nContiguous load of unsigned halfwords to elements of a vector register from  the memory address generated by a 64-bit scalar base and immediate index in  the range -8 to 7 which is multiplied by the vector's in-memory size,  irrespective of predication, and added to the base address. Inactive elements  will not not cause a read from Device memory or signal a fault, and are set to  zero in the destination vector. \n\nIt has encodings from 3 classes: 16-bit element , 32-bit element and 64-bit  element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LD1H    { <Zt>.H }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1H    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1H    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 134, "asmtemplate": "LDUMINLB<Ws>, WZR, [<Xn|SP>]", "brief": "Atomic unsigned minimum on byte in memory, without return", "heading": "STUMINB, STUMINLB", "para": "Atomic unsigned minimum on byte in memory, without return, atomically loads an  8-bit byte from memory, compares it against the value held in a register, and  stores the smaller value back to memory, treating the values as unsigned  numbers.  \n* STUMINB does not have release semantics. \n* STUMINLB stores to memory with release semantics, as described in \n  Load-Acquire, Store-Release.  For information about memory accesses see Load/Store addressing modes. \n\nThis is an alias of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB. This means:  \n* The encodings in this description are named to match the encodings of \n  LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB. \n* The description of LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB gives the \n  operational pseudocode for this instruction.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["STUMINB  <Ws>, [<Xn|SP>]"]}, {"id": 1212, "asmtemplate": "UQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Unsigned saturating increment scalar by multiple of 64-bit predicate constraint element count", "heading": "UQINCD (scalar)", "para": "Unsigned saturating increment scalar by multiple of 64-bit predicate  constraint element count. \n\nDetermines the number of active 64-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the general-purpose register's unsigned integer range. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["UQINCD  <Wdn>{, <pattern>{, MUL #<imm>}}", "UQINCD  <Xdn>{, <pattern>{, MUL #<imm>}}"]}, {"id": 416, "asmtemplate": "SUBHN{2}<Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>", "brief": "Subtract returning High Narrow", "heading": "SUBHN, SUBHN2", "para": "Subtract returning High Narrow. This instruction subtracts each vector element  in the second source SIMD&FP register from the corresponding vector element in  the first source SIMD&FP register, places the most significant half of the  result into a vector, and writes the vector to the lower or upper half of the  destination SIMD&FP register. All the values in this instruction are signed  integer values. \n\nThe results are truncated. For rounded results, see RSUBHN. \n\nThe SUBHN instruction writes the vector to the lower half of the destination  register and clears the upper half, while the SUBHN2 instruction writes the  vector to the upper half of the destination register without affecting the  other bits of the register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vm>": "Is the name of the second SIMD", "<Tb><Vn>": "Is the name of the first SIMD"}, "encodings": ["SUBHN{2}  <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"]}, {"id": 187, "asmtemplate": "LDAPURSB  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load-Acquire RCpc Register Signed Byte (unscaled)", "heading": "LDAPURSB", "para": "Load-Acquire RCpc Register Signed Byte (unscaled) calculates an address from a  base register and an immediate offset, loads a signed byte from memory,  sign-extends it, and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAPURSB  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 1009, "asmtemplate": "STLURH  <Wt>, [<Xn|SP>{, #<simm>}]", "brief": "Store-Release Register Halfword (unscaled)", "heading": "STLURH", "para": "Store-Release Register Halfword (unscaled) calculates an address from a base  register value and an immediate offset, and stores a halfword to the  calculated address, from a 32-bit register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["STLURH  <Wt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 596, "asmtemplate": "LDFF1H  {<Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]", "brief": "Gather load first-fault unsigned halfwords to vector (immediate index)", "heading": "LDFF1H (vector plus immediate)", "para": "Gather load first-fault unsigned halfwords to vector (immediate index). \n\nGather load with first-faulting behavior of unsigned halfwords to active  elements of a vector register from memory addresses generated by a vector base  plus immediate index. The index is a multiple of 2 in the range 0 to 62.  Inactive elements will not cause a read from Device memory or signal faults,  and are set to zero in the destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 2 in the range 0 to 62, defaulting to 0, encoded in the \"imm5\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field."}, "encodings": ["LDFF1H  { <Zt>.S }, <Pg>/Z, [<Zn>.S{, #<imm>}]", "LDFF1H  { <Zt>.D }, <Pg>/Z, [<Zn>.D{, #<imm>}]"]}, {"id": 584, "asmtemplate": "FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>", "brief": "Floating-point Complex Multiply Accumulate", "heading": "FCMLA", "para": "Floating-point Complex Multiply Accumulate. \n\nThis instruction operates on complex numbers that are represented in SIMD&FP  registers as pairs of elements, with the more significant element holding the  imaginary part of the number and the less significant element holding the real  part of the number. Each element holds a floating-point value. It performs the  following computation on the corresponding complex number element pairs from  the two source registers and the destination register:  \n* Considering the complex number from the second source register on an Argand \n  diagram, the number is rotated counterclockwise by 0, 90, 180, or 270 \n  degrees. \n* The two elements of the transformed complex number are multiplied by:The \n  real element of the complex number from the first source register, if the \n  transformation was a rotation by 0 or 180 degrees.The imaginary element of \n  the complex number from the first source register, if the transformation was \n  a rotation by 90 or 270 degrees. \n* The complex number resulting from that multiplication is added to the \n  complex number from the destination register.  The multiplication and addition operations are performed as a fused  multiply-add, without any intermediate rounding. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Vm>": "Is the name of the second SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["FCMLA  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"]}, {"id": 338, "asmtemplate": "FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point maximum (predicated)", "heading": "FMAX (vectors)", "para": "Floating-point maximum (predicated). \n\nDetermine the maximum of active floating-point elements of the second source  vector and corresponding floating-point elements of the first source vector  and destructively place the results in the corresponding elements of the first  source vector. If either element value is NaN then the result is NaN. Inactive  elements in the destination vector register remain unmodified.", "explanations": {"<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FMAX    <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 59, "asmtemplate": "PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend>{<amount>}}]", "brief": "Prefetch Memory (register)", "heading": "PRFM (register)", "para": "Prefetch Memory (register) signals the memory system that data memory accesses  from a specified address are likely to occur in the near future. The memory  system can respond by taking actions that are expected to speed up the memory  accesses when they do occur, such as preloading the cache line containing the  specified address into one or more caches. \n\nThe effect of an PRFM instruction is implementation defined. For more  information, see Prefetch memory. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"": "This syntax is only for encodings that are not accessible using ", "<Wm>": "When ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<imm5>": "Is the prefetch operation encoding as an immediate, in the range 0 to 31, encoded in the \"Rt\" field.", "<prfop>": "Is the prefetch operation, defined as ", "<Xm>": "When "}, "encodings": ["PRFM  (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"]}, {"id": 1233, "asmtemplate": "UCVTF  <Dd>, <Xn>, #<fbits>", "brief": "Unsigned fixed-point Convert to Floating-point (scalar)", "heading": "UCVTF (scalar, fixed-point)", "para": "Unsigned fixed-point Convert to Floating-point (scalar). This instruction  converts the unsigned value in the 32-bit or 64-bit general-purpose source  register to a floating-point value using the rounding mode that is specified  by the FPCR, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped.", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Xn>": "Is the 64-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<Wn>": "Is the 32-bit name of the general-purpose source register, encoded in the \"Rn\" field.", "<fbits>": "For the 64-bit to double-precision, 64-bit to half-precision and 64-bit to single-precision variant: is the number of bits after the binary point in the fixed-point source, in the range 1 to 64, encoded as 64 minus \"scale\".", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["UCVTF  <Hd>, <Wn>, #<fbits>"]}, {"id": 496, "asmtemplate": "MSUB<Xd>, <Xn>, <Xm>, XZR", "brief": "Multiply-Negate", "heading": "MNEG", "para": "Multiply-Negate multiplies two register values, negates the product, and  writes the result to the destination register. \n\nThis is an alias of MSUB. This means:  \n* The encodings in this description are named to match the encodings of MSUB. \n* The description of MSUB gives the operational pseudocode for this \n  instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register holding the multiplicand, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding the multiplier, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["MNEG  <Wd>, <Wn>, <Wm>"]}, {"id": 198, "asmtemplate": "FSUB    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>", "brief": "Floating-point subtract vectors (unpredicated)", "heading": "FSUB (vectors, unpredicated)", "para": "Floating-point subtract vectors (unpredicated). \n\nSubtract all floating-point elements of the second source vector from  corresponding elements of the first source vector and place the results in the  corresponding elements of the destination vector. This instruction is  unpredicated.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<T><Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["FSUB    <Zd>.<T>, <Zn>.<T>, <Zm>.<T>"]}, {"id": 125, "asmtemplate": "MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]", "brief": "Multiply (vector, by element)", "heading": "MUL (by element)", "para": "Multiply (vector, by element). This instruction multiplies the vector elements  in the first source SIMD&FP register by the specified value in the second  source SIMD&FP register, places the results in a vector, and writes the vector  to the destination SIMD&FP register. All the values in this instruction are  unsigned integer values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<T><Vn>": "Is the name of the first SIMD"}, "encodings": ["MUL  <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"]}, {"id": 1016, "asmtemplate": "ASR     <Zd>.<T>, <Zn>.<T>, #<const>", "brief": "Arithmetic shift right by immediate (unpredicated)", "heading": "ASR (immediate, unpredicated)", "para": "Arithmetic shift right by immediate (unpredicated). \n\nShift right by immediate, preserving the sign bit, each element of the source  vector, and place the results in the corresponding elements of the destination  vector. The immediate shift amount is an unsigned value in the range 1 to  number of bits per element. This instruction is unpredicated.", "explanations": {"<T><Zn>": "Is the name of the source scalable vector register, encoded in the \"Zn\" field.", "<const>": "Is the immediate shift amount, in the range 1 to number of bits per element, encoded in \"tsz:imm3\".", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["ASR     <Zd>.<T>, <Zn>.<T>, #<const>"]}, {"id": 312, "asmtemplate": "DUP     <Zd>.<T>, <R><n|SP>", "brief": "Broadcast general-purpose register to vector elements (unpredicated)", "heading": "DUP (scalar)", "para": "Broadcast general-purpose register to vector elements (unpredicated). \n\nUnconditionally broadcast the general-purpose scalar source register into each  element of the destination vector. This instruction is unpredicated. \n\nThis instruction is used by the alias MOV (scalar, unpredicated).", "explanations": {"<T><R><n|SP>": "Is the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["DUP     <Zd>.<T>, <R><n|SP>"]}, {"id": 1102, "asmtemplate": "INDEX   <Zd>.<T>, <R><n>, #<imm>", "brief": "Create index starting from general-purpose register and incremented by immediate", "heading": "INDEX (scalar, immediate)", "para": "Create index starting from general-purpose register and incremented by  immediate. \n\nPopulates the destination vector by setting the first element to the first  signed scalar integer operand and monotonically incrementing the value by the  second signed immediate integer operand for each subsequent element. The  scalar source operand is a general-purpose register in which only the least  significant bits corresponding to the vector element size are used and any  remaining bits are ignored. This instruction is unpredicated.", "explanations": {"<imm>": "Is the signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field.", "<T><R><n>": "Is the number [0-30] of the source general-purpose register or the name ZR (31), encoded in the \"Rn\" field.", "<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field."}, "encodings": ["INDEX   <Zd>.<T>, <R><n>, #<imm>"]}, {"id": 86, "asmtemplate": "INDEX   <Zd>.<T>, #<imm1>, #<imm2>", "brief": "Create index starting from and incremented by immediate", "heading": "INDEX (immediates)", "para": "Create index starting from and incremented by immediate. \n\nPopulates the destination vector by setting the first element to the first  signed immediate integer operand and monotonically incrementing the value by  the second signed immediate integer operand for each subsequent element. This  instruction is unpredicated.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<imm2>": "Is the second signed immediate operand, in the range -16 to 15, encoded in the \"imm5b\" field.", "<T><imm1>": "Is the first signed immediate operand, in the range -16 to 15, encoded in the \"imm5\" field."}, "encodings": ["INDEX   <Zd>.<T>, #<imm1>, #<imm2>"]}, {"id": 882, "asmtemplate": "SQRSHRUN{2}<Vd>.<Tb>, <Vn>.<Ta>, #<shift>", "brief": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate)", "heading": "SQRSHRUN, SQRSHRUN2", "para": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate). This  instruction reads each signed integer value in the vector of the source  SIMD&FP register, right shifts each value by an immediate value, saturates the  result to an unsigned integer value that is half the original width, places  the final result into a vector, and writes the vector to the destination  SIMD&FP register. The results are rounded. For truncated results, see SQSHRUN. \n\nThe SQRSHRUN instruction writes the vector to the lower half of the  destination register and clears the upper half, while the SQRSHRUN2  instruction writes the vector to the upper half of the destination register  without affecting the other bits of the register. \n\nIf saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"<Va><n>": "Is the number of the first SIMD", "2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field.", "<Ta><Vb><d>": "Is the number of the SIMD", "<Tb><Vn>": "Is the name of the SIMD"}, "encodings": ["SQRSHRUN  <Vb><d>, <Va><n>, #<shift>", "SQRSHRUN{2}  <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"]}, {"id": 1134, "asmtemplate": "FSQRT  <Dd>, <Dn>", "brief": "Floating-point Square Root (scalar)", "heading": "FSQRT (scalar)", "para": "Floating-point Square Root (scalar). This instruction calculates the square  root of the value in the SIMD&FP source register and writes the result to the  SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Hn>": "Is the 16-bit name of the SIMD", "<Dn>": "Is the 64-bit name of the SIMD", "<Dd>": "Is the 64-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<Sn>": "Is the 32-bit name of the SIMD", "<Sd>": "Is the 32-bit name of the SIMD"}, "encodings": ["FSQRT  <Hd>, <Hn>"]}, {"id": 866, "asmtemplate": "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0", "brief": "Floating-point Compare Less than zero (vector)", "heading": "FCMLT (zero)", "para": "Floating-point Compare Less than zero (vector). This instruction reads each  floating-point value in the source SIMD&FP register and if the value is less  than zero sets every bit of the corresponding vector element in the  destination SIMD&FP register to one, otherwise sets every bit of the  corresponding vector element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<V><d>": "Is the number of the SIMD", "<Vd>": "Is the name of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCMLT  <Hd>, <Hn>, #0.0", "FCMLT  <V><d>, <V><n>, #0.0", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0", "FCMLT  <Vd>.<T>, <Vn>.<T>, #0.0"]}, {"id": 44, "asmtemplate": "FSCALE  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>", "brief": "Floating-point adjust exponent by vector (predicated)", "heading": "FSCALE", "para": "Floating-point adjust exponent by vector (predicated). \n\nMultiply the active floating-point elements of the first source vector by 2.0  to the power of the signed integer values in the corresponding elements of the  second source vector and destructively place the results in the corresponding  elements of the first source vector. Inactive elements in the destination  vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["FSCALE  <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.<T>"]}, {"id": 552, "asmtemplate": "ST1W    {<Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]", "brief": "Scatter store words from a vector (immediate index)", "heading": "ST1W (vector plus immediate)", "para": "Scatter store words from a vector (immediate index). \n\nScatter store of words from the active elements of a vector register to the  memory addresses generated by a vector base plus immediate index. The index is  a multiple of 4 in the range 0 to 124. Inactive elements are not written to  memory. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional unsigned immediate byte offset, a multiple of 4 in the range 0 to 124, defaulting to 0, encoded in the \"imm5\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zn>": "Is the name of the base scalable vector register, encoded in the \"Zn\" field."}, "encodings": ["ST1W    { <Zt>.S }, <Pg>, [<Zn>.S{, #<imm>}]", "ST1W    { <Zt>.D }, <Pg>, [<Zn>.D{, #<imm>}]"]}, {"id": 310, "asmtemplate": "LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D", "brief": "Logical shift left by 64-bit wide elements (predicated)", "heading": "LSL (wide elements, predicated)", "para": "Logical shift left by 64-bit wide elements (predicated). \n\nShift left active elements of the first source vector by corresponding  overlapping 64-bit elements of the second source vector and destructively  place the results in the corresponding elements of the first source vector.  The shift amount is a vector of unsigned 64-bit doubleword elements in which  all bits are significant, and not used modulo the destination element size.  Inactive elements in the destination vector register remain unmodified.", "explanations": {"<Zdn>": "Is the name of the first source and destination scalable vector register, encoded in the \"Zdn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field."}, "encodings": ["LSL     <Zdn>.<T>, <Pg>/M, <Zdn>.<T>, <Zm>.D"]}, {"id": 1033, "asmtemplate": "USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Dot Product with unsigned and signed integers (vector)", "heading": "USDOT (vector)", "para": "Dot Product vector form with unsigned and signed integers. This instruction  performs the dot product of the four unsigned 8-bit integer values in each  32-bit element of the first source register with the four signed 8-bit integer  values in the corresponding 32-bit element of the second source register,  accumulating the result into the corresponding 32-bit element of the  destination register. \n\nFrom Armv8.2 to Armv8.5, this is an optional instruction. From Armv8.6 it is  mandatory for implementations that include Advanced SIMD to support it.  ID_AA64ISAR1_EL1.I8MM indicates whether this instruction is supported.", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["USDOT  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 292, "asmtemplate": "LDAPURSW  <Xt>, [<Xn|SP>{, #<simm>}]", "brief": "Load-Acquire RCpc Register Signed Word (unscaled)", "heading": "LDAPURSW", "para": "Load-Acquire RCpc Register Signed Word (unscaled) calculates an address from a  base register and an immediate offset, loads a signed word from memory,  sign-extends it, and writes it to a register. \n\nThe instruction has memory ordering semantics as described in Load-Acquire,  Load-AcquirePC, and Store-Release, except that:  \n* There is no ordering requirement, separate from the requirements of a \n  Load-AcquirePC or a Store-Release, created by having a Store-Release \n  followed by a Load-AcquirePC instruction. \n* The reading of a value written by a Store-Release by a Load-AcquirePC \n  instruction by the same observer does not make the write of the \n  Store-Release globally observed.  This difference in memory ordering is not described in the pseudocode. \n\nFor information about memory accesses, see Load/Store addressing modes.", "explanations": {"<simm>": "Is the optional signed immediate byte offset, in the range -256 to 255, defaulting to 0 and encoded in the \"imm9\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDAPURSW  <Xt>, [<Xn|SP>{, #<simm>}]"]}, {"id": 863, "asmtemplate": "LDADDLH  <Ws>, <Wt>, [<Xn|SP>]", "brief": "Atomic add on halfword in memory", "heading": "LDADDH, LDADDAH, LDADDALH, LDADDLH", "para": "Atomic add on halfword in memory atomically loads a 16-bit halfword from  memory, adds the value held in a register to it, and stores the result back to  memory. The value initially loaded from memory is returned in the destination  register.  \n* If the destination register is not WZR, LDADDAH and LDADDALH load from \n  memory with acquire semantics. \n* LDADDLH and LDADDALH store to memory with release semantics. \n* LDADDH has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STADDH, STADDLH.", "explanations": {"<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field."}, "encodings": ["LDADDAH  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 147, "asmtemplate": "DUP<Zd>.<T>, <R><n|SP>", "brief": "Move general-purpose register to vector elements (unpredicated)", "heading": "MOV (scalar, unpredicated)", "para": "Move general-purpose register to vector elements (unpredicated). \n\nUnconditionally broadcast the general-purpose scalar source register into each  element of the destination vector. This instruction is unpredicated. \n\nThis is an alias of DUP (scalar). This means:  \n* The encodings in this description are named to match the encodings of DUP \n  (scalar). \n* The description of DUP (scalar) gives the operational pseudocode for this \n  instruction.", "explanations": {"<Zd>": "Is the name of the destination scalable vector register, encoded in the \"Zd\" field.", "<T><R><n|SP>": "Is the number [0-30] of the general-purpose source register or the name SP (31), encoded in the \"Rn\" field."}, "encodings": ["MOV     <Zd>.<T>, <R><n|SP>"]}, {"id": 104, "asmtemplate": "SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}", "brief": "System instruction", "heading": "SYS", "para": "System instruction. For more information, see Op0 equals 0b01, cache  maintenance, TLB maintenance, and address translation instructions for the  encodings of System instructions. \n\nThis instruction is used by the aliases AT, CFP, CPP, DC, DVP, IC, and TLBI.", "explanations": {"<Cn>": "Is a name 'Cn', with 'n' in the range 0 to 15, encoded in the \"CRn\" field.", "<op1>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op1\" field.", "<Cm>": "Is a name 'Cm', with 'm' in the range 0 to 15, encoded in the \"CRm\" field.", "<op2>": "Is a 3-bit unsigned immediate, in the range 0 to 7, encoded in the \"op2\" field.", "<Xt>": "Is the 64-bit name of the optional general-purpose source register, defaulting to '11111', encoded in the \"Rt\" field."}, "encodings": ["SYS  #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}"]}, {"id": 684, "asmtemplate": "ANDS XZR, <Xn>, <Xm>{, <shift> #<amount>}", "brief": "Test (shifted register)", "heading": "TST (shifted register)", "para": "Test (shifted register) performs a bitwise AND operation on a register value  and an optionally-shifted register value. It updates the condition flags based  on the result, and discards the result. \n\nThis is an alias of ANDS (shifted register). This means:  \n* The encodings in this description are named to match the encodings of ANDS \n  (shifted register). \n* The description of ANDS (shifted register) gives the operational pseudocode \n  for this instruction.", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<amount>": "For the 64-bit variant: is the shift amount, in the range 0 to 63, defaulting to 0 and encoded in the \"imm6\" field,", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<shift><amount>": "For the 32-bit variant: is the shift amount, in the range 0 to 31, defaulting to 0 and encoded in the \"imm6\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register, encoded in the \"Rm\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register, encoded in the \"Rm\" field."}, "encodings": ["TST  <Wn>, <Wm>{, <shift> #<amount>}"]}, {"id": 313, "asmtemplate": "ST4  {<Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>", "brief": "Store single 4-element structure from one lane of four registers", "heading": "ST4 (single structure)", "para": "Store single 4-element structure from one lane of four registers. This  instruction stores a 4-element structure to memory from corresponding elements  of four SIMD&FP registers. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: No offset and Post-index", "explanations": {"": "\".", "<index>": "For the 64-bit variant: is the element index, encoded in \"Q\".", "<Vt3>": "Is the name of the third SIMD", "<Xm>": "Is the 64-bit name of the general-purpose post-index register, excluding XZR, encoded in the \"Rm\" field.", "<Vt>": "Is the name of the first or only SIMD", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Vt4>": "Is the name of the fourth SIMD", "<Vt2>": "Is the name of the second SIMD"}, "encodings": ["ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]", "ST4  { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4"]}, {"id": 696, "asmtemplate": "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0", "brief": "Floating-point Compare Equal to zero (vector)", "heading": "FCMEQ (zero)", "para": "Floating-point Compare Equal to zero (vector). This instruction reads each  floating-point value in the source SIMD&FP register and if the value is equal  to zero sets every bit of the corresponding vector element in the destination  SIMD&FP register to one, otherwise sets every bit of the corresponding vector  element in the destination SIMD&FP register to zero. \n\nThis instruction can generate a floating-point exception. Depending on the  settings in FPCR, the exception results in either a flag being set in FPSR, or  a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 4 classes: Scalar half precision , Scalar  single-precision and double-precision , Vector half precision and Vector  single-precision and double-precision", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<Hn>": "Is the 16-bit name of the SIMD", "<Hd>": "Is the 16-bit name of the SIMD", "<n>": "Is the number of the SIMD", "<T><T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCMEQ  <Hd>, <Hn>, #0.0", "FCMEQ  <V><d>, <V><n>, #0.0", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0", "FCMEQ  <Vd>.<T>, <Vn>.<T>, #0.0"]}, {"id": 232, "asmtemplate": "LDNP  <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]", "brief": "Load Pair of Registers, with non-temporal hint", "heading": "LDNP", "para": "Load Pair of Registers, with non-temporal hint, calculates an address from a  base register value and an immediate offset, loads two 32-bit words or two  64-bit doublewords from memory, and writes them to two registers. \n\nFor information about memory accesses, see Load/Store addressing modes. For  information about Non-temporal pair instructions, see Load/Store Non-temporal  pair.", "explanations": {"": "/8.", "<Wt2>": "Is the 32-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<imm>": "For the 64-bit variant: is the optional signed immediate byte offset, a multiple of 8 in the range -512 to 504, defaulting to 0 and encoded in the \"imm7\" field as ", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xt1>": "Is the 64-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field.", "<Xt2>": "Is the 64-bit name of the second general-purpose register to be transferred, encoded in the \"Rt2\" field.", "<Wt1>": "Is the 32-bit name of the first general-purpose register to be transferred, encoded in the \"Rt\" field."}, "encodings": ["LDNP  <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"]}, {"id": 808, "asmtemplate": "LDUMAXL  <Xs>, <Xt>, [<Xn|SP>]", "brief": "Atomic unsigned maximum on word or doubleword in memory", "heading": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL", "para": "Atomic unsigned maximum on word or doubleword in memory atomically loads a  32-bit word or 64-bit doubleword from memory, compares it against the value  held in a register, and stores the larger value back to memory, treating the  values as unsigned numbers. The value initially loaded from memory is returned  in the destination register.  \n* If the destination register is not one of WZR or XZR, LDUMAXA and LDUMAXAL \n  load from memory with acquire semantics. \n* LDUMAXL and LDUMAXAL store to memory with release semantics. \n* LDUMAX has neither acquire nor release semantics.  For more information about memory ordering semantics see Load-Acquire,  Store-Release. \n\nFor information about memory accesses see Load/Store addressing modes. \n\nThis instruction is used by the alias STUMAX, STUMAXL.", "explanations": {"<Ws>": "Is the 32-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Wt>": "Is the 32-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field.", "<Xs>": "Is the 64-bit name of the general-purpose register holding the data value to be operated on with the contents of the memory location, encoded in the \"Rs\" field.", "<Xt>": "Is the 64-bit name of the general-purpose register to be loaded, encoded in the \"Rt\" field."}, "encodings": ["LDUMAX  <Ws>, <Wt>, [<Xn|SP>]"]}, {"id": 1008, "asmtemplate": "UMLSL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]", "brief": "Unsigned Multiply-Subtract Long (vector, by element)", "heading": "UMLSL, UMLSL2 (by element)", "para": "Unsigned Multiply-Subtract Long (vector, by element). This instruction  multiplies each vector element in the lower or upper half of the first source  SIMD&FP register by the specified vector element of the second source SIMD&FP  register and subtracts the results from the vector elements of the destination  SIMD&FP register. The destination vector elements are twice as long as the  elements that are multiplied. \n\nThe UMLSL instruction extracts vector elements from the lower half of the  first source register, while the UMLSL2 instruction extracts vector elements  from the upper half of the first source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"<Ta><Vn>": "Is the name of the first SIMD", "2<Vd>": "Is the name of the SIMD", "": "FP source register, encoded in the \"Rn\" field."}, "encodings": ["UMLSL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"]}, {"id": 635, "asmtemplate": "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>", "brief": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector)", "heading": "FCVTZS (vector, fixed-point)", "para": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector).  This instruction converts a scalar or each element in a vector from  floating-point to fixed-point signed integer using the Round towards Zero  rounding mode, and writes the result to the SIMD&FP destination register. \n\nA floating-point exception can be generated by this instruction. Depending on  the settings in FPCR, the exception results in either a flag being set in  FPSR, or a synchronous exception being generated. For more information, see  Floating-point exception traps. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the Security state and Exception level in which the instruction is  executed, an attempt to execute the instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<T><Vn>": "Is the name of the SIMD"}, "encodings": ["FCVTZS  <V><d>, <V><n>, #<fbits>", "FCVTZS  <Vd>.<T>, <Vn>.<T>, #<fbits>"]}, {"id": 973, "asmtemplate": "INS<Vd>.<Ts>[<index>], <R><n>", "brief": "Move general-purpose register to a vector element", "heading": "MOV (from general)", "para": "Move general-purpose register to a vector element. This instruction copies the  contents of the source general-purpose register to the specified vector  element in the destination SIMD&FP register. \n\nThis instruction can insert data into individual elements within a SIMD&FP  register without clearing the remaining bits to zero. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nThis is an alias of INS (general). This means:  \n* The encodings in this description are named to match the encodings of INS \n  (general). \n* The description of INS (general) gives the operational pseudocode for this \n  instruction.", "explanations": {"": "FP destination register, encoded in the \"Rd\" field.", "<Ts><index><R><n>": "Is the number [0-30] of the general-purpose source register or ZR (31), encoded in the \"Rn\" field.", "<Vd>": "Is the name of the SIMD"}, "encodings": ["MOV  <Vd>.<Ts>[<index>], <R><n>"]}, {"id": 210, "asmtemplate": "RORV  <Xd>, <Xn>, <Xm>", "brief": "Rotate Right Variable", "heading": "RORV", "para": "Rotate Right Variable provides the value of the contents of a register rotated  by a variable number of bits. The bits that are rotated off the right end are  inserted into the vacated bit positions on the left. The remainder obtained by  dividing the second source register by the data size defines the number of  bits by which the first source register is right-shifted. \n\nThis instruction is used by the alias ROR (register).", "explanations": {"<Xn>": "Is the 64-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Xm>": "Is the 64-bit name of the second general-purpose source register holding a shift amount from 0 to 63 in its bottom 6 bits, encoded in the \"Rm\" field.", "<Wn>": "Is the 32-bit name of the first general-purpose source register, encoded in the \"Rn\" field.", "<Wm>": "Is the 32-bit name of the second general-purpose source register holding a shift amount from 0 to 31 in its bottom 5 bits, encoded in the \"Rm\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["RORV  <Wd>, <Wn>, <Wm>"]}, {"id": 505, "asmtemplate": "LD1W    {<Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "brief": "Contiguous load unsigned words to vector (immediate index)", "heading": "LD1W (scalar plus immediate)", "para": "Contiguous load unsigned words to vector (immediate index). \n\nContiguous load of unsigned words to elements of a vector register from the  memory address generated by a 64-bit scalar base and immediate index in the  range -8 to 7 which is multiplied by the vector's in-memory size, irrespective  of predication, and added to the base address. Inactive elements will not not  cause a read from Device memory or signal a fault, and are set to zero in the  destination vector. \n\nIt has encodings from 2 classes: 32-bit element and 64-bit element", "explanations": {"<imm>": "Is the optional signed immediate vector offset, in the range -8 to 7, defaulting to 0, encoded in the \"imm4\" field.", "<Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Zt>": "Is the name of the scalable vector register to be transferred, encoded in the \"Zt\" field.", "<Xn|SP>": "Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the \"Rn\" field."}, "encodings": ["LD1W    { <Zt>.S }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]", "LD1W    { <Zt>.D }, <Pg>/Z, [<Xn|SP>{, #<imm>, MUL VL}]"]}, {"id": 563, "asmtemplate": "SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]", "brief": "SM3TT2A", "heading": "SM3TT2A", "para": "SM3TT2A takes three 128-bit vectors from three source SIMD&FP register and a  2-bit immediate index value, and returns a 128-bit result in the destination  SIMD&FP register. It performs a three-way exclusive OR of the three 32-bit  fields held in the upper three elements of the first source vector, and adds  the resulting 32-bit value and the following three other 32-bit values:  \n* The bottom 32-bit element of the first source vector, Vd, that was used for \n  the three-way exclusive OR. \n* The 32-bit element held in the top 32 bits of the second source vector, Vn. \n* A 32-bit element indexed out of the third source vector, Vm.  A three-way exclusive OR is performed of the result of this addition, the  result of the addition rotated left by 9, and the result of the addition  rotated left by 17. The result of this exclusive OR is returned as the top  element of the returned result. The other elements of this result are taken  from elements of the first source vector, with the element returned in  bits<63:32> being rotated left by 19. \n\nThis instruction is implemented only when FEAT_SM3 is implemented.", "explanations": {"": ", encoded in \"imm2\".", "<Vd>": "Is the name of the SIMD", "<imm2>": "Is a 32-bit element indexed out of ", "<Vm>": "Is the name of the third SIMD", "<Vn>": "Is the name of the second SIMD"}, "encodings": ["SM3TT2A  <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"]}, {"id": 534, "asmtemplate": "ADDS  <Xd>, <Xn|SP>, #<imm>{, <shift>}", "brief": "Add (immediate), setting flags", "heading": "ADDS (immediate)", "para": "Add (immediate), setting flags, adds a register value and an  optionally-shifted immediate value, and writes the result to the destination  register. It updates the condition flags based on the result. \n\nThis instruction is used by the alias CMN (immediate).", "explanations": {"<imm>": "Is an unsigned immediate, in the range 0 to 4095, encoded in the \"imm12\" field.", "<Wn|WSP>": "Is the 32-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xn|SP>": "Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the \"Rn\" field.", "<Xd>": "Is the 64-bit name of the general-purpose destination register, encoded in the \"Rd\" field.", "<Wd>": "Is the 32-bit name of the general-purpose destination register, encoded in the \"Rd\" field."}, "encodings": ["ADDS  <Wd>, <Wn|WSP>, #<imm>{, <shift>}"]}, {"id": 130, "asmtemplate": "SADDLV  <V><d>, <Vn>.<T>", "brief": "Signed Add Long across Vector", "heading": "SADDLV", "para": "Signed Add Long across Vector. This instruction adds every vector element in  the source SIMD&FP register together, and writes the scalar result to the  destination SIMD&FP register. The destination scalar is twice as long as the  source vector elements. All the values in this instruction are signed integer  values. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"": "FP source register, encoded in the \"Rn\" field.", "<Vn>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD"}, "encodings": ["SADDLV  <V><d>, <Vn>.<T>"]}, {"id": 970, "asmtemplate": "CMPHS<Pd>.<T>, <Pg>/Z, <Zn>.<T>, <Zm>.<T>", "brief": "Compare unsigned lower or same as vector, setting the condition flags", "heading": "CMPLS (vectors)", "para": "Compare unsigned lower or same as vector, setting the condition flags. \n\nCompare active unsigned integer elements in the first source vector being  lower than or same as corresponding unsigned elements in the second source  vector, and place the boolean results of the comparison in the corresponding  elements of the destination predicate. Inactive elements in the destination  predicate register are set to zero. Sets the First (N), None (Z), !Last (C)  condition flags based on the predicate result, and the V flag to zero. \n\nThis is a pseudo-instruction of CMP<cc> (vectors). This means:  \n* The encodings in this description are named to match the encodings of \n  CMP<cc> (vectors). \n* The assembler syntax is used only for assembly, and is not used on \n  disassembly. \n* The description of CMP<cc> (vectors) gives the operational pseudocode for \n  this instruction.", "explanations": {"<Zm>": "Is the name of the second source scalable vector register, encoded in the \"Zm\" field.", "<Zn>": "Is the name of the first source scalable vector register, encoded in the \"Zn\" field.", "<T><Pg>": "Is the name of the governing scalable predicate register P0-P7, encoded in the \"Pg\" field.", "<Pd>": "Is the name of the destination scalable predicate register, encoded in the \"Pd\" field."}, "encodings": ["CMPLS   <Pd>.<T>, <Pg>/Z, <Zm>.<T>, <Zn>.<T>"]}, {"id": 1136, "asmtemplate": "SADDL{2}<Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>", "brief": "Signed Add Long (vector)", "heading": "SADDL, SADDL2", "para": "Signed Add Long (vector). This instruction adds each vector element in the  lower or upper half of the first source SIMD&FP register to the corresponding  vector element of the second source SIMD&FP register, places the results into  a vector, and writes the vector to the destination SIMD&FP register. The  destination vector elements are twice as long as the source vector elements.  All the values in this instruction are signed integer values. \n\nThe SADDL instruction extracts each source vector from the lower half of each  source register, while the SADDL2 instruction extracts each source vector from  the upper half of each source register. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped.", "explanations": {"2<Vd>": "Is the name of the SIMD", "<Tb><Vm>": "Is the name of the second SIMD", "": "FP source register, encoded in the \"Rm\" field.", "<Ta><Vn>": "Is the name of the first SIMD"}, "encodings": ["SADDL{2}  <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"]}, {"id": 31, "asmtemplate": "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>", "brief": "Signed saturating Add", "heading": "SQADD", "para": "Signed saturating Add. This instruction adds the values of corresponding  elements of the two source SIMD&FP registers, places the results into a  vector, and writes the vector to the destination SIMD&FP register. \n\nIf overflow occurs with any of the results, those results are saturated. If  saturation occurs, the cumulative saturation bit FPSR.QC is set. \n\nDepending on the settings in the CPACR_EL1, CPTR_EL2, and CPTR_EL3 registers,  and the current Security state and Exception level, an attempt to execute the  instruction might be trapped. \n\nIt has encodings from 2 classes: Scalar and Vector", "explanations": {"": "FP source register, encoded in the \"Rm\" field.", "<Vd>": "Is the name of the SIMD", "<V><d>": "Is the number of the SIMD", "<n>": "Is the number of the first SIMD", "<m>": "Is the number of the second SIMD", "<T><Vn>": "Is the name of the first SIMD", "<Vm>": "Is the name of the second SIMD"}, "encodings": ["SQADD  <V><d>, <V><n>, <V><m>", "SQADD  <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"]}, {"id": 518, "asmtemplate": "SQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}", "brief": "Signed saturating increment scalar by multiple of 32-bit predicate constraint element count", "heading": "SQINCW (scalar)", "para": "Signed saturating increment scalar by multiple of 32-bit predicate constraint  element count. \n\nDetermines the number of active 32-bit elements implied by the named predicate  constraint, multiplies that by an immediate in the range 1 to 16 inclusive,  and then uses the result to increment the scalar destination. The result is  saturated to the source general-purpose register's signed integer range. A  32-bit saturated result is then sign-extended to 64 bits. \n\nThe named predicate constraint limits the number of active elements in a  single predicate to:  \n* A fixed number (VL1 to VL256)  \n* The largest power of two (POW2)  \n* The largest multiple of three or four (MUL3 or MUL4)  \n* All available, implicitly a multiple of two (ALL). \n\nUnspecified or out of range constraint encodings generate an empty predicate  or zero element count rather than Undefined Instruction exception. \n\nIt has encodings from 2 classes: 32-bit and 64-bit", "explanations": {"<Wdn>": "Is the 32-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<Xdn>": "Is the 64-bit name of the source and destination general-purpose register, encoded in the \"Rdn\" field.", "<pattern><imm>": "Is the immediate multiplier, in the range 1 to 16, defaulting to 1, encoded in the \"imm4\" field."}, "encodings": ["SQINCW  <Xdn>, <Wdn>{, <pattern>{, MUL #<imm>}}", "SQINCW  <Xdn>{, <pattern>{, MUL #<imm>}}"]}]
